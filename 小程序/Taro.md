* taro技术揭秘：taro-cli
> https://juejin.cn/post/6844903633557913608


## 
Taro 在运行时将大部分小程序规范页面生命周期注入到了页面组件中，同时 React 或 Vue 自带的生命周期也是完全可以正常使用的。




////////////////////////////////////////////////////////////////////////////////////////////////////////////
## Taro设计思路

Taro的初心就是做一款能够适配多端的解决方案。


由于微信小程序是不开放不开源的端，我们可以先**把 React** 代码**分析成一颗抽象语法树**，根据这颗树**生成小程序支持的模板代码**，再做一个**小程序 运行时框架** 处理 事件和生命周期 与 小程序框架 兼容，然后把业务代码跑在**运行时框架**就完成了小程序端的适配。

![](https://user-gold-cdn.xitu.io/2018/6/7/163d9f93a840481b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


## 技术选型
![技术选型](https://user-gold-cdn.xitu.io/2018/6/7/163d9f93ae6055b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## Taro各版本区别

Taro 目前有 3 个大版本，但如果按照**架构**来划分的话，Taro 1/2 属于第一代架构，而 Taro 3 则属于第二代架构，两代架构差异巨大，甚至可以完全认为是 2 个框架。不过，这只是对于框架内核而言；对于开发者，Taro 团队已经尽量在保证大版本之间的兼容性，着力降低版本迁移的难度。

### Taro 1/2
**Taro 1/2 属于编译型架构**，主要通过对类 React 代码进行语法编译转换地方式，得到各个端可以运行的代码，再配合非常轻量的运行时适配，以及根据标准组件库、API 进行差异抹平，从而实现多端适配的目的，整体架构如下。

![Taro1 与 Taro2 区别 ](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0671072921454829ab72ce55068c050d~tplv-k3u1fbpfcp-zoom-1.image)

而 Taro 1 与 Taro 2 的都是基于这种架构建立的方案，他们之间的区别主要是 Taro 1 在小程序端是**自建构建体系**，而 Taro 2 则是**所有端都采用 Webpack 进行编译**，可以降低 Taro 自身编译系统的复杂度，同时能够让开发者使用 Webpack 的生态来自定义编译过程和结果。Taro 3  也是基于webpack进行编译的。 

### Taro 3
Taro 3 则可以大致理解为**解释型架构（相对于 Taro 1/2 而言）**，主要通过**在小程序端模拟实现 DOM、BOM API 来让前端框架直接运行在小程序环境中**，从而达到小程序和 H5 统一的目的，而对于生命周期、组件库、API、路由等差异，我们依然可以通过定义统一标准，各端负责各自实现的方式来进行抹平。
![Taro 3](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5670efd4e0a145b28a75d0a171950bfc~tplv-k3u1fbpfcp-zoom-1.image)

### 版本选择的取舍

Taro 1/2 和 Taro 3 之间特性的差异主要体现在开发体验与性能上。

* 从开发体验上看，Taro 3 明显是优于 Taro 1/2 的。
> Taro 3 中可以使用完整的 React、Vue 语法特性来进行开发，在开发体验上让多端开发无限接近于 Web 开发，这对深耕 Web 而初次接触小程序的开发者来说是非常友好的。
> Taro 1/2 在开发时会有诸多限制，尤其是在 JSX 书写上。

* 从性能上看，某些情况下 Taro 1/2 会优于 Taro 3。

不过官方更加推荐使用 Taro 3 来开发多端应用。而且现阶段 Taro 团队的研发重心主要放在 Taro 3 上，新的特性会优先在 Taro 3 上进行尝试

### taro 的 缺点：
