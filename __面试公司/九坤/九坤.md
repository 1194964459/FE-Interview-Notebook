## 单选题

TODO:1、考查布尔值转换

```js
!!null  
!!''
!!1
!!NaN
```

> 答案：false false true false

TODO:2、考查let、var关键字

```js
let num = 2;
var num = 1;
num = 3;
console.log(num);
```

> 答案：SyntaxError
> let不允许重复声明，一个let、一个var  声明同名的变量也不可以，两个var声明同名变量可以

3、考查剩余运算符、typeof类型判断

```js
const func = (...args) => {
    console.log(typeof args)
};

func(29);
```

> 答案：object

4、考查参数传递、类型比较

```js
const func(obj) = {
    if (obj === { a: 1 }) {
        console.log('balabala');
    } else if (obj == { a: 1 }) {
        console.log('balabala....');
    } else {
        console.log('emmmmm') // 具体打印内容记不清了，反正逻辑肯定是走到这里的
    }
}

func({ a: 1 });
```

> 答案：emmmmm

5、考查类型比较，隐式转换

```js
let a = 3;
let b = new Number(3)
let c = 3;
```

> 答案：正确为 a == b、a === c
> typeof b   // object

6、考查类、实例、原型方法

```js
const Person = function (name){
    this.name = name
}

const person = new Person('john');

person.getName();

Person.getName = function () {
    return this.name;
} // 记不清是 Person.getName 还是 Person.prototype.getName 了，如果是 Person.getName 选择 TypeError 如果是 Person.prototype.getName，选择 john
```

> 答案：参考注释

7、考查对象及对象属性

```js
const a = {};
const b = { a : 1 };
const c = { b : 2 };
a[b] = 123;
a[c] = 456;
console.log(a[b]);
```

> 答案：456

> 解析：对象作为属性时，会转化为字符串'[object Object]'，因此a[b]与a[c]都是在修改同一个属性，所以结果是456覆盖了123

8、考查对象、set属性

```js
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty(1)
obj.hasOwnProperty('1')
set.has(3);
set.has('3');
```

> 答案：true true true false

> 解析：hasOwnProperty 判断是否含有某个属性时，会自动转化为字符串

9、考查++自增运算符

```js
let num = 0;
console.log(num++);
console.log(++num);
console.log(num);
```

> 答案：0 2 2

10、下列哪对配置可以实现强缓存与协商缓存

> 答案：Cache-Controll、Expires；Last-Modified、Etag

## 填空题

1、打印输出结果（考查node环境事件循环）

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}

console.log('script start');

async function async2() {
    console.log('async2');
}

async1();

setTimeout(function() {
    console.log('setTimeout');
});

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});

setImmediate(function() {
    console.log('setImmediate');
});

process.nextTick(function() {
    console.log('nextTick');
});

console.log('script end');
```

> 答案：
script start
async1 start
async2
promise1
script end
<!-- 这3个是 微任务，但是nextTick优先级最高，所以先执行 -->
nextTick
async1 end
promise2

setTimeout
setImmediate

2、打印输出结果（考查变量作用域、循环语句中的异步代码执行）

```js
for (var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 0);
}

// TODO:这道题有问题
for (var i = 0; i < 5; i++) {
    setTimeout(console.log(i), 0);
}

for (let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 0);
}
```

> 答案：5,5,5,5,5 0,1,2,3,4 0,1,2,3,4

3、打印输出结果

```js
Promise.resolve().then(() => {
    console.log('then11');
    new Promise(resolve => {
        resolve();
    }).then(() => {
        console.log('then21');
    }).then(() => {
        console.log('then22');
    })
}).then(() => {
    console.log('then12');
})
```

> 答案：
then11
then21
then12
then22

4、打印输出结果

```js
let x, y

new Promise(() => {
    throw new Error();
}).catch((x) => {
    (x = 1), (y = 2);
})

console.log(x, y);
```

> 答案：undefined undefined

## 多选题

1、下列哪几个响应头会影响cookie的传递

A：Access-Control-Allow-Origin

B：Access-Control-Allow-Headers

C：Access-Control-Allow-Credentials

D：Access-Control-Expose-Headers

> 答案：A C

2、下列哪些方式可以触发BFC

A：根元素

B：float值不为none

C：position为absolute或fixed

D：overflow不为visible

E：display为inline-block、flex等

> 答案：A B C D E （全选）

3、下列哪些方法可以解决跨域

A：jsonp

B：cors

C：postMessage

D：websocket

E：node服务转发

> 答案：A B C D E （全选）

## 算法题

1、最大公共子序列（不连续）-> 动态规划
2、a字符串转化为b字符串需要的最少步骤 -> 编辑距离动态规划
3、最长有效括号组合 -> 栈