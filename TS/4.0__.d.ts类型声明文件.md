# .d.ts 类型声明文件

TS 的类型定义文件（.d.ts）是专门用于声明类型信息的文件。仅含类型信息，不会被编译为 JS 代码。解决 “TypeScript 不认识非 TS 代码中的变量/函数/模块” 的问题（避免出现 ```xxx is not defined``` 的类型错误）。

类型定义文件（.d.ts） 中有一堆 declare，declare 关键字主要用于声明类型信息。 

类型声明有什么好处？
1. 类型校验，类型不对会报错
2. 代码编写时，可以自动补全
3. 鼠标悬停时也会提示类型定义、参数说明啥的

主要有两种类型声明文件：
* 全局类型文件：定义了全局可用的类型（如接口、类型别名、枚举等）的 .d.ts 文件。
* 模块类型文件：.d.ts 中有```import/export```

### 如何生成类型声明文件？
答：基于tsc，然后扫描指定目录下的 .ts 文件
```js
tsc --emitDeclarationOnly 
```
它会为每个符合条件的 .ts 文件生成对应的 .d.ts 文件。例如，src/index.ts 会生成 src/index.d.ts。

若不想全部都生成.d.ts 文件，只想针对某个具体的文件 生成，那么直接指定文件路径即可：
```js
tsc --emitDeclarationOnly src/someFile.ts
```

## declare
declare 通常写在类型定义文件（.d.ts）中，不过也可以写在其他类型的文件中。

* declare 声明 如果写在全局作用域中，就会成为全局类型，整个项目都能直接使用，无需导入。
* 若写在模块内部（即包含 import 或 export 的文件中）时，它的作用域被限制在该模块内，不会污染全局，需通过导入才能使用。
```js
// utils.ts（模块，因为有 export）
export function fn() {}

// 模块内的 declare，仅在当前模块有效
declare type ModuleType = string | number;

// 使用模块内声明的类型
const a: ModuleType = "hello";
```

可声命的类型如下：
* 声命全局变量/常量：```declare const 变量名：类型```
* 声明全局函数：```declare function 函数名(参数名：参数类型): 返回类型```
* 声明模块类型：```declare module "模块名"```，需要用 import、export 分别导入导出的
* 声明命名空间：```declare namespace "命名空间名"```，全局模块，通过 ```命名空间名.成员``` 访问，主要是在 *ES 模块普及前使用*。
* 声明全局类型别名(```declare type```)或接口(```declare interface```)：

注意：**用 declare 声明的变量、函数、interface啥的，都是全局可用的**，主要是为了避免与其他模块中的同名实体冲突。如果**仅是模块内使用，可以不用加 declare**。

.d.ts 文件中通常包含以下内容：

## 一、扩展内置类型
为 JavaScript 原生对象（如 Window、Array）扩展自定义属性或方法的类型：

疑问❓：如果在模块内扩展全局类型Window，怎么搞呢？答：见下面的```declare global```
```js
// 扩展 Window 对象
declare interface Window {
  // 添加自定义全局属性
  appConfig: {
    apiBaseUrl: string;
    debug: boolean;
  };
  // 添加自定义全局方法
  trackEvent: (eventName: string) => void;
}

// 扩展 Array 原型方法
declare interface Array<T> {
  // 为数组添加一个 "sum" 方法（假设在 JS 中已实现）
  sum(): number;
}
```

## 二、模块扩展声明
为*已有的模块*补充类型（如给第三方库添加额外方法）：
```js
// 扩展已有的 "vue" 模块
import Vue from 'vue';
declare module 'vue' {
  interface Vue {
    // 为 Vue 实例添加自定义方法
    $myMethod: () => void;
  }
}
```

## 三、声明全局变量/常量
其中，变量可以是个函数变量
```js
// 声明全局变量 jQuery 的类型
declare const jQuery: (selector: string) => {
  html: (content: string) => void;
  css: (key: string, value: string) => void;
};

// 此时使用 jQuery 会有类型提示，且不会报错
jQuery('#app').html('Hello');
```

## 四、声明类型别名、接口
参考：[interface与type](./1.0__interface与type.md)
```js
// interface 声明会合并，所以可以 Window
declare interface Window {
  // 扩展 Window 对象的类型，添加自定义属性
  appConfig: {
    env: string;
    apiUrl: string;
  };
}

declare type Status = 'success' | 'error' | 'pending';
```
使用：
```js
// 访问 Window 上的自定义属性，有类型提示
console.log(window.appConfig.apiUrl);

const status: Status = 'success';
```

## 五、声明一个函数
参考：[TS中声明函数的各种方式](./4.2__TS中声明函数的各种方式.md)

1. **值声明**：会生成可执行代码，是真正可调用的函数。  

实现了一个函数（包含实际逻辑），同时通过 TypeScript 类型系统约束参数和返回值。

```js
// 这是“值声明”，会生成 JS 代码（如 function jQuery(...) { ... }）
function jQuery(selector: string) {
  return {
    html(content: string) { /* 实际逻辑 */ },
    css(key: string, value: string) { /* 实际逻辑 */ },
  };
}
```

2. **类型声明**，仅声明类型
```js
// 这是“类型声明”，仅定义函数类型，不生成代码
type JQueryFn = (selector: string) => {
  html: (content: string) => void;
  css: (key: string, value: string) => void;
};
// 若要关联变量，需再声明变量类型：
const jQuery: JQueryFn = /* 实际实现 */;
```
这种声明仅在类型系统中存在，需手动关联到运行时的值。

## 六、模块类型声明
为没有自带类型的**第三方 JS 模块**补充类型，让 import 或 export 时能获得类型提示。

作用域仅仅只是“模块内”，语法：```declare module "模块名"```

导出：需要使用 export 暴露类型
```js
// 为 "utils" 模块声明类型
declare module "utils" {
  // 导出函数类型
  export function clone<T>(data: T): T;
  
  // 导出接口
  export interface Config {
    timeout: number;
  }
  
  // 导出默认成员
  export default class Tools {
    log(message: string): void;
  }
}
```
导入：使用时通过```import```引入
```js
import { clone, Config } from "utils";
import Tools from "utils";
```

###  declare global
在模块文件（有 import/export 的文件）中**扩展全局类型**，突破模块作用域的限制，**向全局作用域添加类型**。
```js
// 模块文件（因有 import，成为模块）
import type { User } from "./user";

// 在模块中扩展全局类型
declare global {
  // 扩展全局接口
  interface Window {
    currentUser: User;
  }

  // 声明全局类型
  type GlobalStatus = "active" | "inactive";
}
```
注意：**只能用在模块文件中**（不然会报错，因为全局文件无需 declare global）。


## 七、命名空间声明
核心是避免全局变量冲突，用于描述全局作用域中按命名空间组织的代码，主要是在 *ES 模块普及前使用*。作用域是“全局的”。

语法：```declare namespace "命名空间名"```，直接在全局作用域生效。

内部成员无需 export 即可被外部访问（通过 ```命名空间名.成员``` 访问）。

```js
// 声明全局命名空间 MyLib
declare namespace MyLib {
  // 内部接口（无需 export）
  interface User {
    name: string;
  }
  
  // 内部函数
  function getUser(): User;
  
  // 嵌套命名空间
  namespace Validators {
    function isEmail(str: string): boolean;
  }
}
```
使用时直接通过命名空间访问：
```js
const user: MyLib.User = MyLib.getUser();
const isEmail = MyLib.Validators.isEmail("test@example.com");
```

