# 三斜线指令
参考：[TS中如何引入自定义全局类型、npm包的类型、TS内置类型？](https://www.doubao.com/thread/w452011a2139bf842)

[类型声明文件](./4.0__.d.ts类型声明文件.md)

三斜线指令主要用于管理**全局类型文件**的依赖关系，确保类型声明文件能够正确地被引用和合并。

特性：
* 三斜线指令必须放在文件的最顶部，前面只能有其他三斜线指令或空白，不能有代码或普通注释
* 仅对全局类型有效，在模块文件（有 import/export）中效果有限。

三斜线指令 合理的使用原则是：
* 模块化代码中优先用 import 管理依赖。
* 全局类型依赖或特殊场景（如引入 dom 库、兼容非模块代码）时，再考虑三斜线指令。

## 常用的三斜线指令

```/// <reference path="..." />```：**引用本地类型文件**。主要是拆分全局类型到多个 .d.ts 文件时，相互引用。  
不过，由于TS对模块（import/export）的支持完善，现在这种方式用的越来越少了。**对于本地类型文件，更推荐用 import 引入**

```/// <reference types="..." />```：**引用 npm 类型包**，用于引入第三方库的类型声明（通过 @types/xxx 安装的类型包）。  
对于npm 类型包，只要 tsconfig.json 中 **typeRoots 包含 @types**（默认是包含的），TS 会自动扫描 node_modules/@types，无需手动声明。如下：

```/// <reference lib="..." />```：
用于**显式引入 TypeScript 内置的类型库**（如 DOM、ES6 等），这些库定义了 JS 运行时环境的基础类型（如 window、Promise 等）。
替代方案：tsconfig.json 中 的 compilerOptions.**lib 选项**
```js
{
    "compilerOptions": {
        "lib": ["dom", "esnext"],  // TS内置的类型库

        "typeRoots": ["./node_modules/@types", "./src/types"]   // 配置“类型声明文件”编译时的查找目录
        "types": ["node", "jest", "my-custom-types"]  // 明确指定需要包含的类型声明包
    }
}
```

疑问❓：引入TS内置类型时的两种有何不同？
* tsconfig.json 中配置lib选项：
  * 全局配置，一次性解决项目中所有文件对特定类型库的需求；
  * 但不灵活，因为项目中不同文件对类型库的需求差异较大，可能会引入一些不需要的类型，增加编译时的负担。
* 三斜线lib指令：
  * 灵活性高，哪里需要 按需引入特定的类型库即可
  * 假如有多个文件都需要引入相同的类型库，需要在每个文件中重复添加三斜线指令


## 为何三斜线指令现在用的少了？
现代 TypeScript 项目更依赖 ES 模块（import/export）和自动类型发现（@types），导致三斜线指令的使用频率下降：

* 模块化类型文件通过 **import 声明依赖**，无需 **path 指令**。
* **typeRoots 默认包含@types**，可自动识别@types包，无需 **types 指令**。
* 多数项目**无需手动引入内置库**（默认包含常用的 es5、dom 等）。

## 三斜线指令的必要性：
三斜线指令并未被废弃，它在处理**全局类型依赖、内置库引入、非模块化代码兼容**等场景时*仍不可替代*。只是在现代模块化项目中，其使用场景被 import、自动类型发现机制大幅压缩。

### 1. 全局类型文件的依赖管理
当项目中存在多个全局 .d.ts 文件（无 import/export），且它们之间有依赖关系时，```/// <reference path="..." />``` 是唯一可靠的方式。

唯一可靠的方式？是的。
因为：此时若用 import 会将文件转为模块，破坏全局类型的共享性，而三斜线指令是唯一不改变文件性质的依赖声明方式。

```js
// types/base.d.ts（全局基础类型）
declare interface BaseConfig {
  env: string;
}

// types/app.d.ts（依赖 base.d.ts）
/// <reference path="./base.d.ts" />
declare interface AppConfig extends BaseConfig {
  apiUrl: string;
}
```

### 2. 显式引入内置类型库
```/// <reference lib="..." />``` 用于手动指定 TypeScript 内置的类型库（如 dom、es2020），这在某些特殊环境中不可替代。可以按需引入（替代方案：tsconfig.json中的libs 是整个项目中都引入了）

例如：Node.js 项目默认不包含 DOM 类型，若需要使用 window 或 document，必须显式引入：

```js
/// <reference lib="dom" />
// 此时可正常使用 DOM 类型
console.log(window.location.href);
```
这种场景下，没有其他方式能替代 lib 指令的作用。  TODO:

### 3. 兼容非模块化代码
对于遗留的非模块化项目（无 import/export），三斜线指令是组织类型依赖的唯一选择。


## 疑问❓ TypeScript 内置的类型库与第三方npm包有点分不清楚
内置类型库主要定义 JavaScript 语言原生特性 和 运行时环境（如浏览器、Node.js） 的基础类型，例如：

如何区别？
* 看是否需要单独安装：内置类型库随 typescript 一起存在，无需额外安装；第三方包必须通过 npm install 安装。
* 看作用范围：内置类型库覆盖 “所有项目都需要的基础环境”；第三方包只针对特定库或框架（如 React、Vue、jQuery 等）。
* 看引用方式：内置类型库通过 tsconfig.json 的 lib 选项配置（如 "lib": ["es6", "dom"]）；第三方包通过 import 引入或自动被 TS 识别（如 @types 包）。

如何控制内置类型库?
```js
{
  "compilerOptions": {
    "lib": ["es2020", "dom"] // 明确指定加载 ES2020 语言库和 DOM 环境库
  }
}
```
如果不配置 lib，TS 会根据 target（编译目标）自动加载对应版本的内置库（如 target: "es5" 会自动加载 lib.es5.d.ts）。
若项目是 Node.js 环境，通常不需要 dom 库，可只配置 ["es2020", "esnext.asynciterable"]。
