## 什么是泛型

泛型是指在**定义函数、接口或类的时候**，**不预先指定具体的类型，使用时再去指定类型的一种特性**。可以把泛型理解为*代表类型的变量*

我们需要一种方法：使返回值的类型与传入参数的类型是相同的。这时就需要用到 类型变量，它是一种特殊的变量，只用于表示类型而不是值。这样的一种函数，就是泛型函数。


```JS
function identity<T>(arg: T): T {
    return arg;
}
```

类型变量怎么表示？
答：```通常用 <T> 表示```，可以帮助我们捕获用户传入的类型。T 是类型占位符，可替换为任意合法名称。

### 常见的泛型类型：
* 约束对象的泛型接口：```KeyValue<T>```
* 函数泛型：```function 函数名<T>```
* 类泛型：```class 类名<T>```
* 接口泛型：```interface 接口名<T>```  

三者内部都可以直接使用类型变量 T 

怎么使用泛型呢？主要有两种方案，使用时指定类型、不指定类型。

### 示例：约束对象的泛型接口
```js
// 泛型接口：键为string，值为T类型的对象
interface KeyValue<T> {
  key: string;
  value: T;
}

// 使用：值为number类型
const numPair: KeyValue<number> = { key: "age", value: 25 };

// 使用：值为string类型
const strPair: KeyValue<string> = { key: "name", value: "Alice" };
```
### 示例：约束函数的泛型
当需要同时处理多个类型（且类型之间有关联）时，可以使用多个泛型参数（如 ```<T, U, V>```）。

```js
// 泛型函数：合并两个对象（T和U为两个对象的类型）
function merge<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 }; // 返回两者的交叉类型
}

// 使用：合并 { name: string } 和 { age: number }
const person = merge(
  { name: "Alice" },
  { age: 25 }
);

// 类型正确：person 同时有 name 和 age 属性
person.name; // "Alice"（string类型）
person.age; // 25（number类型）
```

### 示例：约束类的泛型
```js
// 定义泛型类：栈的元素类型为 T
class Stack<T> {
  private items: T[] = [];

  // 入栈：接收 T 类型的元素
  push(item: T): void {
    this.items.push(item);
  }

  // 出栈：返回 T 类型的元素
  pop(): T | undefined {
    return this.items.pop();
  }

  // 获取栈顶元素
  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }
}

// 使用：创建存储 number 类型的栈
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
const num: number = numberStack.pop()!; // 2
```

### 示例：约束接口的泛型
里面是个匿名函数，这时候是个 函数类型的接口

参考：[interface中定义函数：具名函数、匿名函数](./interface中定义函数.md)

```js
// 泛型接口：定义一个“输入T，输出T”的函数结构
interface Transformer<T> {
  (value: T): T;
}

// 实现接口：将数字翻倍（T为number）
const double: Transformer<number> = (num) => num * 2;
double(10); // 20（类型检查通过）

// 实现接口：将字符串转为大写（T为string）
const toUpperCase: Transformer<string> = (str) => str.toUpperCase();
toUpperCase("hello"); // "HELLO"（类型检查通过）
```

## 示例：使用泛型的必要性
```js
// 我们希望传入的值是什么类型，返回的值就是什么类型
// 传入的值可以是任意的类型，这时候就可以用到 泛型

// 如果使用 any 的话，就失去了类型检查的意义
function createArray1(length: any, value: any): Array<any> {
    let result: any = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

let result = createArray1(3, 'x');
console.log(result);

// 最傻的写法：每种类型都得定义一种函数
function createArray2(length: number, value: string): Array<string> {
    let result: Array<string> = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

function createArray3(length: number, value: number): Array<number> {
    let result: Array<number> = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

// 或者使用函数重载，写法有点麻烦
function createArray4(length: number, value: number): Array<number>
function createArray4(length: number, value: string): Array<string>
function createArray4(length: number, value: any): Array<any> {
    let result: Array<number> = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

createArray4(6, '666');
```
使用泛型后：
```JS
// 有关联的地方都改成 <T>
function createArray<T>(length: number, value: T): Array<T> {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

// 使用的时候再指定类型
let result = createArray<string>(3, 'x');

// 也可以不指定类型，TS 会自动类型推导
let result2 = createArray(3, 'x');
console.log(result);
```


