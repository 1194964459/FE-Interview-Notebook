# 多路复用

多路复用：在单个传输通道上同时传输多个数据流，从多个方面提高了传输效率。如:
* 减少连接建立开销：允许在一个连接上并发多个请求和响应（HTTP/1.1中，每个请求都需要建立一个单独的TCP连接）
* 避免队头阻塞：http2避免了应用层的对头阻塞，http3彻底解决了对头阻塞问题（应用层、传输层）
    > 应用层的对头阻塞：如 “某个请求卡住，其他请求也发不出去”。  
    > 传输层的对头阻塞：如 “某个数据包丢了，其他已到的包也用不了”。
    > 
    > 对头阻塞只会发生在某一层的 “自身规则” 里，不会跨层影响规则本身。
* 充分利用带宽：

**并发 与 并行的区别**：
| 维度 | 并发（Concurrency）	| 并行（Parallelism）|
| ---- | ---- | ---- |
| 核心逻辑	| **多个任务 “交替执行”**，共享同一资源（如单 CPU 核心）	| **多个任务 “同时执行”**，占用独立资源（如多 CPU 核心）|
| 微观视角	| **同一时间点，只有 1 个任务在执行**（串行交替）	| **同一时间点，有多个任务在同时执行**（真正并行）|
| 宏观视角| 	任务 “看起来在同时推进”（因切换速度快，人无法感知）	| 任务 “确实在同时推进”（物理层面的同步执行）|
| 本质	| 「**任务调度的艺术**」—— 通过 “**时间分片**” 最大化单资源利用率	| 「**资源分配的结果**」—— 通过 “多资源并行” 提升整体效率|

## 一、HTTP/1.1 与 http2、http3多路复用的区别：
* **HTTP/1.1**：
    * *一次 TCP连接 只能处理一个请求-响应。多请求需建立多个连接*
    * *采用持久连接Keep-alive：一个连接可传输多个请求，不过请求需“串行处理”，只能等前一个处理完之后才可以处理下一个）*，存在 **“队头阻塞” 和连接开销大**的问题。
    * 持久连接 本质是“并发”，因底层只有1个 TCP连接（单资源），靠“请求 排队切换”实现多任务推进。
        > 为什么要等待？或排队？   
        > 答：TCP 是 “字节流协议”，数据在传输中是连续的字节序列，没有天然的 “边界”。因此，**为了区分 “哪个字节属于哪个请求/响应”，HTTP/1.1 只能依赖“请求-响应的顺序”：必须等前一个请求的响应完全返回（即前一个请求的字节流结束），才能发送下一个请求**。这就导致了 “串行排队” 的问题。

* **HTTP/2 多路复用**：
    * 通过*流ID 和帧的交错传输，实现了 “单连接多流并行”*，减少了连接建立开销，但仍受限于 TCP 层的队头阻塞（某一流的数据包丢失会阻塞整个连接的帧传输）。
    * 逻辑并行  
* **HTTP/3 多路复用**：
    * 物理并行

| 对比维度| HTTP/1.1 持久连接（Keep-Alive）| 	HTTP/2 多路复用	| HTTP/3 多路复用 |
| ---- | ---- | ---- |---- |
| 底层传输协议| 	基于 TCP |	基于 TCP	| 基于 QUIC（运行在 UDP 上的传输层协议）|
| 复用的核心单位	| 复用 TCP 连接，但请求需串行排队| 	复用 1 个 TCP 连接，用“流（Stream）+ 帧（Frame）” 并行传输	| 复用 1 个 QUIC 连接，用 “流（Stream）+ 帧（Frame）” 并行传输 <br/><br/>**流完全独立** | 
| 队头阻塞问题	| 严重：<br/>同一连接内，**前一个请求阻塞所有后续请求**	| 部分解决：<br/>**应用层无阻塞**，但 **TCP 层仍有队头阻塞**	| 彻底解决：<br/> QUIC 层支持流独立重传，单个流阻塞不影响其他流|
| 并发请求的连接数| 	需建立 6~8 个并行 TCP 连接（浏览器限制）| 	仅需 1 个 TCP 连接|	仅需 1 个 QUIC 连接|
| 头部压缩| 	无（重复头部反复传输）| 	支持 HPACK 压缩	|支持 QPACK 压缩（HPACK 的改进版）|
| 流优先级控制	| 无（只能按请求顺序处理）| 	支持（可给流分配优先级）| 	支持（更精细的流优先级调度）|


## 二、HTTP/2 的多路复用
HTTP/2 通过 **“帧拆分 + 流 ID 标识”** 的设计，在单一 TCP 连接上实现了多个流的并行传输。

HTTP/2 多路复用的本质是：用**二进制帧作为 “最小传输单元”，用流 ID 作为 “*逻辑隔离标识*”，让多个请求/响应的帧在单个 TCP 连接中交错传输，接收端再通过流 ID 拆分重组**。既避免了 HTTP/1.x “多连接占用资源” 的问题，又实现了请求的并发传输（但受限于 TCP 队头阻塞，这也是 HTTP/3 转向 QUIC 的核心原因）

二进制帧的优势是 “**结构紧凑、解析高效**”，且能*通过流ID精准区分不同请求的数据流（在 HTTP/2 中，流与请求/响应的关系是1:1）*，为多路复用提供底层支持。

* 数据包、帧、流的关系：一个流内可以有很多帧，每个帧中都有个流ID（标记该帧属于哪个流）。
    > **流是逻辑单元**：对应一次完整的请求/响应，用流 ID 区分不同交互；   
    > **帧是物理单元**：是流的拆分片段，*携带具体数据*，通过流 ID 归属到对应的流；     
    > **数据包承载帧**：数据包（Packet）是在网络中实际传输的数据单元，一个数据包可以封装一个或多个不同流的不同帧。
* 在 HTTP/2 中，流与请求/响应的关系是1:1，每个 HTTP 请求/响应都完全地消耗掉单个流。通过流 ID 确保消息的正确重组
* HTTP/2 中的**流是双向**的：一个流中可**同时传输**```客户端→服务器（请求）```和```服务器→客户端（响应）```的帧。

> 每个 QUIC 包有自己的编号（Packet Number），帧在包内有独立的偏移量（Stream Offset），**一个流可以经过多个 Packet 传输，但单个帧必须完整地存在于一个 Packet 中**。这样的设计有助于简化数据的处理和重组过程，提高传输效率和可靠性。

### HTTP/2 多路复用的3 个关键技术环节： 
### 1. 用 “二进制帧” 替代 HTTP/1.x 的文本格式（基础/前提）     

HTTP/1.x 以*文本格式传输数据*（如GET /index.html HTTP/1.1），*数据边界模糊且难以拆分*；

HTTP/2 则将所有传输内容（请求行、响应行、头部、正文）都封装成**二进制帧（Frame）**，每个帧包含固定格式的 “帧头” 和 “帧载荷”：    
* **帧头（9 字节）**：关键字段包括**流ID（标记该帧属于哪个流）**、**帧类型**（如 HEADERS 帧存头部、DATA 帧存正文、WINDOW_UPDATE帧  用于流控，告知对端 “当前可接收的字节数”）、**标志位**（控制帧的行为，如*END_STREAM表示流结束*），这是**多路复用的 “身份标识基础”**。
* 帧载荷：存放实际数据（如请求头部信息、响应正文片段）。

    ```js
    // HTTP/2 帧结构（共 9 字节固定头部 + 载荷）：

    +-----------------------------------------------+
    | 长度 (24位) | 类型 (8位) | 标志 (8位) | 流ID (31位) |
    +-----------------------------------------------+
    |                  载荷 (可变长度)                 |
    +-----------------------------------------------+
    ```

### 2. 用 “流（Stream）” 划分独立请求/响应通道（核心）  
“流” 是 HTTP/2 中**逻辑上的 “独立数据通道”**，每个请求/响应对应一个独立的流(对应关系是1:1)，
> 为什么是逻辑上？因为底层的 TCP 压根不认识流、帧，流、帧的相关规范、实现都需要在应用层实现的；  
>     
> 反观 HTTP3 就不一样了，HTTP3中的 QUIC 是原生支持流的，所以应用层的帧是不需要 流ID 的。并且每个流有自己独立的序列号、流量控制、丢包重传确认逻辑，即“流是独立的，流与流之间是隔离的，一个流不影响另一个流”，彻底解决了 TCP 的对头阻塞。   

**流的标识规则**：  
* 流 ID 是 31 位无符号整数，范围 1~2³¹-1，且在一个 TCP 连接中唯一。
* 流 ID 一旦分配，在连接生命周期内不会重复使用，避免混淆。
* *客户端创建的流 ID* 必须是**奇数**，*服务器创建的流 ID* 必须是**偶数**。

**流的创建**：  
* *客户端发起新请求*时，会创建一个新流（奇数的流 ID，如 1、3、5…），并通过HEADERS帧（携带流 ID）发送请求头部。
* *服务器响应*时，使用**相同的流 ID**返回HEADERS帧（响应头部）和DATA帧（响应体），**确保请求与响应在同一个流中关联**。

**流的生命周期状态管理**：  
每个流有明确的生命周期状态（如IDLE、OPEN、HALF_CLOSED、CLOSED），通过 帧头的标志位（如```END_STREAM```）控制流的状态转换！   
* 客户端发送HEADERS帧时设置END_STREAM，表示请求已完成（无请求体）；
* 服务器返回DATA帧时设置END_STREAM，表示响应已完成，流进入CLOSED状态。

**流的特性**：
* **双向性**：一个流中可**同时传输**```客户端→服务器（请求）```和```服务器→客户端（响应）```的帧。
* **有序性**：同一流内的**帧按发送顺序传输**，接收端需**按帧序重组**（保证单个请求/响应的数据完整性）。
    > 虽然**多个流之间的数据可以乱序传输，但在每个流内部，数据的发送和接收要按照顺序进行**。
* **可优先级排序**：通过*帧头的 “优先级” 字段*，*可标记流的重要程度*（如首页 HTML 流优先级高于图片流），*服务器据此分配带宽*。

**流的控制机制**：  
* **流量控制**：
接收端通过*WINDOW_UPDATE帧告知发送端 “当前流可接收的最大字节数”*（类似 TCP 的接收窗口），*防止缓冲区溢出*。
    * 控制粒度：可针对单个流或整个连接（流 ID=0）。
* **优先级设置**：
客户端通过*PRIORITY帧为流设置优先级*（权重 0~255），服务器可根据优先级调整帧的发送顺序（如*优先传输高优先级流的帧*）。

### 3. 多流在单个 TCP 连接中 “混传” 与 “拆分”（实现）
HTTP/2 的核心能力是在**单一 TCP 连接上交错传输多个流的帧**，接收端通过流 ID 将帧重组为完整的 HTTP 消息：

* **发送端**：可以*同时向多个流写入帧*（如先发送流 1 的DATA帧，再发送流 3 的HEADERS帧，再发送流 1 的剩余DATA帧），帧的传输顺序可以不按流 ID 排序。
* **接收端**：通过**每个帧的流 ID，将属于同一流的帧缓存并按顺序重组**（每个流内部的帧必须按发送顺序处理），最终拼接成完整的请求或响应。

## 三、HTTP/3 的多路复用
QUIC中的流在交错传输时，保持流内有序、流间无序的结合：  
* 流内有序：同一流的帧按发送顺序编号（Stream Offset），接收端必须按序重组以保证数据完整性。
* 流间无序：不同流的帧在 UDP 包中可以任意顺序排列，接收端无需等待其他流的帧即可处理当前流的数据。

流的逻辑隔离：
1. 流 ID 与流内偏移量的双重标识  
每个流在创建时会分配唯一的流 ID（Stream ID），而流内的每个数据包则通过 **偏移量（Offset）** 标识其在数据流中的位置。  
```流 A 的数据包可能包含Stream ID=1和Offset=100，表示该包是流 A 中第 100 字节开始的数据。```   
接收端根据这两个字段将数据精准分发到对应流的缓冲区，即使它们位于同一个 UDP 包中，也不会混淆。

2. 独立的流状态机   
每个流维护自己的发送窗口和接收窗口，单流的生命周期（打开、关闭、半关闭）。当流 A 的某个包丢失时，流 A 的发送窗口暂停扩展，但流 B、流 C 的窗口仍可正常滑动。

HTTP/2 和 HTTP/3 均通过 “帧（Frame）” 和 “流（Stream）” 实现多路复用，但由于底层协议不同（HTTP/2 基于 TCP，HTTP/3 基于 QUIC），两者的帧和流在设计目标、结构特性和功能表现上存在显著差异。

```js
// HTTP/3 帧结构（头部字段动态简化，无固定长度）：

+-------------------+-------------------+-------------------+
| 帧类型 (varint)   | 长度 (varint)     | 载荷 (可变长度)    |
+-------------------+-------------------+-------------------+

// 去掉“流 ID” 字段了，因为 QUIC是原生支持流的，可以对流进行标识。HTTP/3 帧无需重复携带
```

3. 与底层协议的配合：**HTTP/2 与 TCP 脱节，HTTP/3 与 QUIC 深度协同**

**HTTP/2 的二进制分帧是 “在 TCP 限制下的妥协方案”。为了在无流感知的 TCP 上实现多路复用，不得不设计复杂的帧结构承载“流管理信息”**；

* **HTTP/2 + TCP**：   
    * TCP 是“无流感知” 的字节流协议，完全不理解HTTP/2 的帧和流。因此：
        * HTTP/2 必须在帧中包含所有流管理信息（如流 ID、优先级），并在应用层实现复杂的帧重组、流调度逻辑。
        * *流的隔离性仅存在于**应用层**的解析逻辑中，而无法在**传输层**实现真正的隔离*。
    * 接收方需```从字节流提取帧 → 解析流 ID → 重组流```，过程繁琐且易出错。
    * TCP 为**整个连接的所有数据分配了一套 “全局连续的序列号”**。 **不管应用层发送的是哪个请求、哪个逻辑流，底层所有字节都在同一个序列号空间中排队**。

* **HTTP/3 + QUIC**：  
    * QUIC是原生支持流的，是 “有流感知” 的传输层协议。可以对流进行标识、隔离、优先级控制、流量控制等。
    * QUIC 原生支持流的创建、关闭、优先级控制。QUIC中的流是独立的，单个流内数据的丢失不影响其他流。
    HTTP/3 帧可直接复用 QUIC 的流管理能力，无需重复编码流信息。   
    * 接收方收到 QUIC 包后，先由 QUIC 层按流 ID 拆分数据，再将同一流的 HTTP/3 帧直接交付应用层

    > **注意**：
    > * **HTTP2与Http3中的流都是逻辑上的流，而非物理上的流**。流只是一个逻辑概念，是逻辑上的虚拟流。实际上并没有物理上的流通道！
    > * **QUIC 的拥塞控制是 “连接级” 的，而非流级。主要是控制全连接网络资源**！

## 四、http2 与 http3 传输数据单位统计：
**HTTP2 单位统计**：  
* 应用层的最小数据单位：帧
* 传输层的最小数据单位：TCP段（多个帧可能被封装在一个 TCP 段中，也可能一个帧被拆分成多个 TCP 段）
* 丢失重传的最小单位：TCP段，与传输层保持一致！（即使只是丢失了一个字节，也会把对应的段内数据全部发送一遍）
    > 即使一个 TCP 段中仅丢失 1 个字节，接收方也会因该段数据不完整而无法确认（TCP 基于段的累积确认机制），发送方超时或收到重复确认后，会**重新传输整个原始 TCP 段**，而非仅补发丢失的那 1 个字节。
* HTTP2是基于TCP的，TCP是面向字节流的协议！

**HTTP3 单位统计：**  
* 应用层的最小数据单位：帧
* 传输层的最小数据单位：数据包（QUIC 协议将一个或多个帧封装在 UDP 数据包，一个包中可能包含了不同流的不同帧！另外，QUIC中是不可能把帧拆分到不同的包中的）
* 丢失重传的最小单位：帧，仅重传丢失的帧
* QUIC 协议通过包编号（Packet Number）来标识每个包，同时通过流 ID、流内偏移量 Offset 来标识帧在流中的位置。

