# TLS 1.2 与 TLS 1.3 中的消息

**前向安全性**（Forward Secrecy，简称 FS 或 PFS）是密码学中的一个重要概念，主要用于**保障通信过程中密钥的安全性**，*即使长期密钥泄露，也不会影响过去已加密通信内容的保密性*。

TLS 1.2 目前仍广泛使用，但是TLS 1.3才是目前主流推荐版本！！

## 基本知识了解
**TLS 协议中主要有三种算法**：
* **1. 密钥交换算法**：也称为“密钥协商”，基于非对称加密算法。用于客户端和服务器安全**协商共享密钥（如预主密钥）**，是握手的核心。
    > ECDHE：前向安全（即使私钥泄露，历史通信也无法解密；但需双方协商支持），（*目前应用最广泛*）。   
    > RSA：无前向安全（*应用次于 ECDHE，但仍有一定存量*。*TLS 1.3 已废除 RSA 密钥交换，仅保留 RSA 用于签名*）   
    > DH：安全性和 RSA 差不多（当前用的最少）
    
* **2. 签名算法**（身份认证，与证书绑定）：通过证书签名，主要用于**验证服务器（或客户端）身份，确保通信对象合法**。
    > RSA  
    > ECDSA（与RSA 签名算法相比，在提供同等安全级别时，所需的密钥长度更短）
    > EdDSA，更高效

* **3. 对称加密算法**：用于后续应用数据加密的**会话密钥所依赖的算法**（如 AES、ChaCha20）。
    > AES-CBC（TLS 1.3中被废除了）
    > AES-GCM (AEAD 模式)
    > ChaCha20-Poly1305  (AEAD 模式)  

**其中 TLS 1.3 中：密钥交换算法（强制且唯一是ECDHE）、对称加密算法（强制 AEAD 模式）**


## TLS 1.2握手中的消息
TLS 1.2 握手过程相对复杂，主要包括客户端问候、服务器问候、证书验证、密钥交换和会话结束确认等步骤，通常需要2 次往返通信 才能完成。

TLS 1.2 中客户端和服务器各发送 2 次请求，每轮请求包含多个消息。

请求与消息：
* **“请求” 更强调逻辑上的交互轮次**（每轮请求可能包含多个消息），而 **“消息”是具体的协议数据单元**。
* 注意：**发送消息只需要 TCP 连接，不需要先发送 “请求”**。

### 一、客户端会给服务器发送2次请求，不同请求传递的消息有：   
1. **第一次请求**：发起握手
    * **Client Hello**

    > 服务器回应：会返回服务器侧的首轮响应消息（见下文服务器请求）。

2. **第二次请求**：完成密钥交换并确认握手（以下消息按顺序发送，逻辑上属于同一轮请求）
    * （可选）**Certificate（双向认证时）**：客户端证书链，证明客户端身份。
    * **Client Key Exchange**（核心密钥材料，如 ECDHE 公钥或加密的预主密钥）；
        * 若为 RSA 密钥交换：用**服务器公钥**加密的预主密钥（**Pre-Master Secret**）。
        * 若为 ECDHE 密钥交换：客户端生成的**临时公钥（Client ECDHE Param）**。
    * （可选）**Certificate Verify（双向认证时）**：客户端用私钥对握手消息流的哈希签名，证明对证书的所有权。
    * **Change Cipher Spec**：告知服务器 “后续消息将用会话密钥加密”；
    * **Finished**（验证握手过程的完整性和密钥的正确性）。用协商的**会话密钥**加密的验证消息，*包含***对所有握手明文消息的哈希值**（验证握手完整性）。
    > 服务器回应：发送最终的Finished消息，确认握手完成。

### 二、服务端给客户端发送2次请求，不同请求传递的消息有：   
1. **第一次请求**：回应客户端初始握手，确认握手参数，提供服务器身份信息和密钥材料。（以下消息按顺序发送，逻辑上属于同一轮响应）：   
    * **Server Hello**：确认 TLS 版本、选定的加密套件、服务器随机数、会话 ID 等。
    * **Certificate**：服务器证书链，证明服务器身份。（注意📢：是可选项，但大多数都用了，所以这里搞成必选；TLS 1.2 与 1.3中）
    * （可选）**Server Key Exchange**：
        * 若为 ECDHE 密钥交换：服务器生成的临时公钥（Server ECDHE Param）。
        * 若为 DH 密钥交换：服务器的 DH 参数。
    * （可选）**Certificate Request**（可选，双向认证时）：要求客户端提供证书。
    * **Server Hello Done** ：标志服务器首轮消息发送完毕，等待客户端回应。

    > 客户端回应：发送上述客户端的第 2 次请求消息。

2. **第二次请求**：确认密钥并完成握手（以下消息按顺序发送，逻辑上属于同一轮响应）：   
* **Change Cipher Spec**：告知客户端 “后续消息将用会话密钥加密”。
* **Finished**：用会话密钥加密的验证消息，包含对所有握手明文消息的哈希值（验证握手完整性）。

    > 客户端不需要回应，客户端只需要验证Finished消息，验证通过后表示当前握手已经完成，双方可以用会话密钥加密通信（即数据传输阶段）。**Finished消息是握手的最终确认信号**


## TLS 1.3握手中的消息
**1. 移除了三种消息：**
* Change Cipher Spec** (**CCS**) 消息，核心移除项  
    * TLS 1.2中，用于显式通知对方 “后续消息将使用协商的会话密钥加密”，无实际数据承载，仅作状态切换标记。
    * TLS 1.3中，将 “加密切换” 逻辑隐式嵌入握手流程—— 服务端发送 Server Hello 后，立即用早期推导的 server_handshake_traffic_secret 加密后续的 Encrypted Extensions、Certificate 等消息；客户端收到加密消息后，自然知晓需切换到加密模式处理。无需额外发送 CCS 消息，通过消息的 “加密状态” 即可同步加密切换时机。

* Client Key Exchange 消息    
    > 将 “密钥交换材料”（如 ECDHE 临时公钥、PSK 标识）直接嵌入 Client Hello 消息的 ```key_share 扩展```中。
* Server Key Exchange 消息   
    > 将服务端的密钥交换材料（临时公钥、签名）嵌入 Server Hello 的 ```key_share 扩展```中，与 Server Hello 合并发送，避免拆分两次消息

**2. 新增了几种密钥**   
这3种都是由 master_secret 派生而来的。master_secret 则是客户端和服务端通过 ECDHE 密钥交换算法，结合双方的随机数以及交换的公钥信息计算得出。
* client_handshake_traffic_secret：客户端用于加密握手消息的密钥。
* application_traffic_secret：：握手完成后，用于加密应用层数据的密钥。
* server_handshake_traffic_secret：服务端用于加密握手消息的密钥。
    * **加密握手消息**：服务端在发送 Server Hello 之后，会使用 server_handshake_traffic_secret 加密后续的握手消息，比如 ```Encrypted Extensions（加密扩展消息）、Certificate（证书消息）、CertificateVerify（证书验证消息） 以及 Finished 消息等```。通过这种方式，从服务端发送的部分消息开始，就进入了加密传输状态，减少了明文消息暴露的风险，提升了握手过程中的安全性。
    * **保障消息完整性**：除了加密消息内容，server_handshake_traffic_secret 还参与**消息认证码（MAC）**的计算，确保消息在传输过程中不被篡改，接收方可以通过验证 MAC 来确认消息的完整性。


