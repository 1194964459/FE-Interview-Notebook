# fetch 和axios 和Ajax区别

参考：https://www.jianshu.com/p/8bc48f8fde75

目录：
* 原生 XMLHttpRequest
* AJax
* Fetch
* Axios

## 1. 原生 XMLHttpRequest

```js
const xhr = new XMLHttpRequest();
    
xhr.open("GET", url, false); // 第三个字段：true（异步）、false（同步）
xhr.setRequestHeader("Content-Type", "application/json");
xhr.onreadystatechange = function () {
    if (xhr.readyState !== 4) return;
    if (xhr.status === 200 || xhr.status === 304) {
        // 
    } else {
        // 
    }
};

xhr.send();
```

## 2. Ajax
AJAX = 异步 JavaScript 和 XML。 是一种用于创建快速动态网页的技术。XMLHttpRequest 是 AJAX 的基础。

以 JQuery ajax 为例，它 是对原生XHR的封装，除此以外还增添了对JSONP的支持。

**用法**：
```js
$.ajax({
    type: 'POST',
    url: url,
    data: data,
    dataType: dataType,
    success: function() {},
    error: function() {}
});
```

**优点**：
* **无需重新加载整个网页的情况下，可以只对网页中的某一部分进行更新**。
* 使用异步的方式与服务器通信，不需要中断操作，
* 避免客户端浏览器在开始渲染之前等待所有数据到达，节省网络带宽。
* 交互性好，提升了用户体验。

**缺点**：
* 本身是针对MVC的编程,不符合现在前端MVVM的浪潮
* JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）
* 不符合关注分离（Separation of Concerns）的原则
* AJAX 不支持 Back和History功能。 在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。


* Ajax应用程序中的安全性较低（容易收到CSRF和XSS攻击)，因为所有文件都是在客户端下载的
* 可能出现网络延迟的问题
* 禁用javascript的浏览器无法使用该应用程序
* 由于安全限制，只能使用它来访问服务于初始页面的主机的信息。如果需要显示来自其他服务器的信息，则无法在AJAX中显示。




## 2. axios
axios 基于promise用于浏览器和node.js的http客户端。

用法：
```js
axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
.then(function (response) {
    console.log(response);
})
.catch(function (error) {
    console.log(error);
});
```
**优点**：
* 从node.js创建http请求
* 在浏览器中创建XMLHttpRequest
* 支持Promise API
* 提供了一些并发请求的接口
* 支持拦截请求和响应
* 转换请求和响应数据
* 取消请求
* 自动转换JSON数据
* 客户端支持防御CSRF/XSRF


## 3. fetch
fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。（然而问题还是有很多）

用法：
```js
try {
    let response = await fetch(url);
    let data = response.json();
    console.log(data);
} catch(e) {
    console.log("Oops, error", e);
}
```

**优点**：
* 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象中
* 更好更方便的写法
* 更加底层，提供的API丰富（request，response）
* 脱离了XHR，是ES规范里新的实现方式

**缺点**：
* fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
* fetch默认不会带cookie，需要添加配置项
* fetch不支持abort,不支持超时控制，使用setTimeout及Promise.reject和Promise.race结合setTimeout实现的超时控制并不能阻止请求过程继续在后台执行，造成了量的浪费
* fetch没有办法原生监测请求的进度，而XHR可以
