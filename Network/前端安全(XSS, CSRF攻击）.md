# 前端安全

参考：
CSRF攻击：https://blog.csdn.net/stpeace/article/details/53512283
XSS攻击：
* https://www.cnblogs.com/tugenhua0707/p/10909284.html
* https://www.freebuf.com/articles/web/185654.html

## XSS 攻击
**XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。**XSS的重点不在于跨站点，而在于脚本的执行。

**XSS的原理是：** 恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。

**XSS攻击分类：**反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为**非持久性XSS攻击**。存储型可以归类为**持久性XSS攻击**。

## CSRF 攻击

CSRF（Cross-site request forgery）即 跨站请求伪造。

攻击者盗用了你的身份，以你的名义发送恶意请求，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。

Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。CSRF攻击攻击原理及过程如下：

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 

### CSRF 漏洞检测：
检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。

### 防御 CSRF 攻击：
目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

**1. 验证 HTTP Referer 字段**
根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。

假如黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站；而用户正常转帐请求的 Referer 值就会是转账按钮所在的页面的 URL。因此，可以利用这一点，如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

**优点：**
* 简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。

**缺点：**
* 不安全。使用验证 Referer 值的方法，就是**把安全性都依赖于第三方（即浏览器）来保障**，从理论上来讲，这样并不安全。
* **Referer 值可篡改。**对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。
* 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。**用户担心侵犯到他们的隐私权，将浏览器设置为在发送请求时不再提供 Referer。**

<br/>
**2. 在请求地址中添加 token 并验证**
**CSRF 攻击之所以能够成功，是因为黑客可以完全 伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie中**，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。**要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token**，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

**优点：**
* 安全性比 Referer检查 高。

**缺点：**
* 该方法的难点在于如何把 token 以参数的形式加入请求。
```JS
// 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成http://url?csrftoken=tokenvalue。 

// 对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了。
```
     
每一个请求都加上 token 是很麻烦的，并且很容易漏掉（解决：一般是在每次页面加载时，使用 js 遍历整个 dom 树， 对所有的 a 和 form 标签后加入 token）；另外，对于页面加载之后动态生成的 html 代码，这种方法就没有作用（解决：需要程序员在编码时手动添加 token。）。

<br/>
**3. 在 HTTP 头中自定义属性并验证**
这种方法也是使用 token 并进行验证，但它并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。

**优点：**
* 解决了上种方法在请求中加入 token 的不便。
* 通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，不用担心 token 会透过 Referer 泄露到其他网站中去。

**缺点：**
* 通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。
* 基于这种方法进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，代价很大。