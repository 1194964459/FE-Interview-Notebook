# 基于ECDHE 的 TLS 握手流程
参考：[TLS握手中的消息，方便理解整个握手流程](./2.2.1__TLS中的消息.md)

本文主要围绕以下几项展开：
* TLS 1.2 握手
* TLS 1.2 握手的会话恢复
* TLS 1.3 握手
* TLS 1.3 握手的核心优化


基于ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，“椭圆曲线临时”迪菲 - 赫尔曼） 算法的握手是目**前应用最广泛的安全握手方式**（**因支持前向安全性**）

### 核心前提
ECDHE 是一种**密钥交换算法**，其核心作用是：通过交换双方的 临时 ECDHE 公钥，各自计算出相同的**预主密钥（Pre-Master Secret）**，再*基于预主密钥*生成用于加密后续通信的**主密钥（Master Secret） 和会话密钥**。

* 「**Ephemeral（临时）**」意味着**每次握手都会生成新的密钥对，即使后续会话被破解，历史通信也不会泄露（前向安全性）**。
* 「**椭圆曲线（EC）**」相比传统 DH 算法，**在相同安全性下密钥长度更短，计算效率更高**。

> 传统的 RSA 算法，是在客户端和服务器间直接传输 预主密钥（Pre-Master Secret）


## 一、TLS 1.2 握手
整个过程可分为**4 个主要阶段**，涉及客户端、服务器、CA（证书颁发机构）三方交互，共传递 4 条关键消息：
### 步骤一、客户端发起握手请求（Client Hello）
客户端向服务器发送第一条消息，包含以下关键信息：

* **支持的协议版本**：如 TLS 1.2。
* **客户端随机数（Client Random）**：一个 32 字节的随机数（用于后续生成主密钥）。
* **支持的椭圆曲线列表**：客户端支持的 EC 曲线（如 secp256r1、x25519 等，*x25519 是目前最常用的曲线之一*）。
* **支持的密码套件列表**：客户端可接受的加密套件，<code>格式为 “密钥交换算法 + 对称加密算法 + 哈希算法”</code>，如：
    > ECDHE-ECDSA-AES128-GCM-SHA256（ECDHE 密钥交换，ECDSA 签名，AES-128-GCM 对称加密，SHA256 哈希）   
    > ECDHE-RSA-AES256-GCM-SHA384（RSA 签名）。  
* **会话 ID（可选）**：若需复用会话可携带，此处为新会话则为空。

### 步骤二、服务器响应（Server Hello + 证书 + 服务器密钥交换 + Server Hello Done）
服务器收到客户端请求后，依次返回 3 条消息：

**1. Server Hello**   
服务器确认握手参数：
* 选定的协议版本（如 TLS 1.2）。
* 服务器随机数（Server Random）：32 字节随机数（与客户端随机数共同用于生成主密钥）。
* 选定的椭圆曲线：从客户端列表中选一个（如 x25519）。
* 选定的密码套件：从客户端列表中选一个（如ECDHE-RSA-AES128-GCM-SHA256，表示用 RSA 对服务器的 ECDHE 公钥进行签名）。  

**2. Certificate（服务器证书）**     
服务器向客户端发送数字证书，包含：
* 服务器域名、**公钥**（服务器的 **RSA** 或 **ECDSA 公钥**，用于*验证后续的数字签名*）。
* 证书颁发机构（CA）的信息及 CA 对证书的数字签名（客户端将通过 CA 根证书验证此签名，确认服务器身份）。
[数字证书的具体生成](./2.2.2__数字签名.md)

**3. Server Key Exchange（服务器密钥交换）**    
这是 *ECDHE 握手的核心消息，服务器生成临时 ECDHE 密钥对并发送*：
* 服务器的**临时 ECDHE 公钥（Server ECDHE Public Key）**：基于选定的椭圆曲线生成（如 x25519 公钥），客户端将用此公钥计算共享密钥。
* **数字签名**：*服务器用自己的私钥*（*CA证书中对应公钥的私钥，如 RSA 私钥*）对以下内容签名，*防止公钥被篡改*：
    * **服务器临时 ECDHE 公钥**。
    * **客户端随机数（Client Random）**和**服务器随机数（Server Random）**（*确保签名与当前会话绑定*）。

**4. Server Hello Done**   
服务器通知客户端：“我的响应已完成，请继续”。


### 步骤三、客户端验证并生成密钥（Client Key Exchange + 证书验证 + 预主密钥计算 + 主密钥生成）
客户端收到服务器消息后，执行以下关键步骤：
简化流程：
> 对服务器的身份验证（基于CA证书）  
> 对服务器的临时 ECDHE 公钥 验证是否可信（基于证书中的公钥解密得到的哈希值，并且哈希一致）  
> 生成客户端临时 ECDHE 密钥对  
> 发送“Client Key Exchange”消息，将 客户端的临时 ECDHE 公钥 传给服务器
> 计算“预主密钥 Pre-Master Secret”（基于 客户端临时 ECDHE 私钥、服务端临时 ECDHE 公钥 这2项生成；这两对临时的密钥 是与会话绑定的）  
> 生成“主密钥 Master Secket”（基于 Pre-Master Secket、Client Random、Server Random 这三项生成）  
> 生成“会话密钥”，包含对称加密密钥、哈希认证码两部分  
> 发送“Change Cipher Spec”消息  
> 发送“Finished”消息  

> 疑问❓：服务器的临时 ECDHE 公钥 是*服务端签名后*再传给客户端的。*客户端的临时 ECDHE 公钥 却是明文传给服务器，它为什么不做签名*？   
> * 回答：签名 主要是做身份认证、完整性、真实性验证。客户端是需要验证服务器身份的，避免被中间人篡改啥的，服务端一般不用验证客户端身份，所以不用签名啥的。


1. **验证服务器证书**  
    * 客户端用内置的 CA 根证书（公钥）解密证书中的数字签名，得到哈希值。
    * 客户端对证书内容（域名、服务器公钥等）重新计算哈希，对比两者是否一致：
        * 若一致：**证书有效，服务器身份可信**。
        * 若不一致：证书被篡改或伪造，握手终止，浏览器提示风险。
        
2. **验证服务器密钥交换消息的签名**  
    * 客户端用服务器证书中的公钥（如 RSA 公钥）解密 “Server Key Exchange” 中的数字签名，得到哈希值。
    * 客户端对服务器临时 ECDHE 公钥、Client Random、Server Random 重新计算哈希，对比是否一致：
        * 若一致：**服务器的临时 ECDHE 公钥未被篡改，可安全使用**。
        * 若不一致：握手终止。

3. **生成客户端临时 ECDHE 密钥对并发送公钥**  
    * 客户端*基于服务器选定的椭圆曲线*（如 x25519），生成自己的**临时 ECDHE 密钥对（私钥仅客户端保存，公钥对外发送）**。
    * 发送**Client Key Exchange消息：包含客户端的临时 ECDHE 公钥**。

4. **计算预主密钥（Pre-Master Secret）**  
**客户端用自己的临时 ECDHE 私钥**，与**服务器的临时 ECDHE 公钥**，通过椭圆曲线 Diffie-Hellman 算法计算出**预主密钥**（*一个随机值，客户端和服务器计算结果完全相同*）。

5. **生成主密钥（Master Secret）**  
客户端基于以下三个参数，通过 PRF（伪随机函数）生成主密钥：
    * 预主密钥（Pre-Master Secret）。
    * 客户端随机数（Client Random）。
    * 服务器随机数（Server Random）。  
    <code>（PRF 公式：Master Secret = PRF(**Pre-Master Secret**, "master secret", **Client Random + Server Random**)）</code>

6. **生成会话密钥**  
主密钥进一步通过 PRF 生成用于实际加密通信的**会话密钥**，包括：
    * **对称加密密钥**（如 AES-GCM 的密钥）。
    * **消息认证码（MAC）密钥**（用于验证数据完整性，TLS 1.2 中 GCM 模式已集成完整性校验，此步骤可简化）。

7. **发送 Change Cipher Spec**   
客户端通知服务器：“后续所有消息将用新生成的会话密钥加密”。

8. **发送 Finished 消息**  
客户端**用会话密钥加密**一个**哈希值（基于握手过程中所有消息的摘要）**，发送给服务器，用于验证双方是否生成了相同的会话密钥：  
<code>哈希值计算：PRF(Master Secret, "client finished", Hash(所有握手消息))</code>。

### 步骤四、服务器生成密钥并确认握手完成（主密钥生成 + 验证客户端 Finished + 发送 Finished）
服务器收到客户端消息后，执行以下步骤：

1. **计算预主密钥（Pre-Master Secret）**   
服务器用自己的临时 ECDHE 私钥，与客户端的临时 ECDHE 公钥，通过同样的椭圆曲线 Diffie-Hellman 算法计算出**预主密钥**（与客户端结果完全相同）。

2. **生成主密钥（Master Secret）**  
服务器用与客户端相同的参数（预主密钥、Client Random、Server Random）和 PRF，生成与客户端完全相同的**主密钥**。

3. **生成会话密钥**  
服务器基于主密钥生成与客户端相同的会话密钥（对称加密密钥、MAC 密钥等）。

4. **验证客户端的 Finished 消息**  
    * 服务器用会话密钥解密客户端的 Finished 消息，得到哈希值，与自己计算的 “所有握手消息摘要” 对比：
        * 若一致：客户端已正确生成会话密钥，双方密钥同步成功。
        * 若不一致：密钥生成失败，握手终止。

5. **发送 Change Cipher Spec**  
服务器通知客户端：“我也将用会话密钥加密后续消息”。

6. **发送 Finished 消息**  
服务器用会话密钥加密一个哈希值（基于握手过程中所有消息的摘要）发送给客户端，格式为：   
<code>PRF(Master Secret, "server finished", Hash(所有握手消息))</code>

7. **客户端验证服务器的 Finished 消息**  
客户端解密并验证服务器的 Finished 消息，确认双方密钥一致后，握手成功。

## 二、TLS 1.2 会话恢复
CCS：即Change Cipher Spec

依赖 Session ID 或 Session Ticket，但恢复时仍需部分重复流程（如```Client Hello 携带 Session ID → 服务端确认 → 客户端发送 CCS → 发送 Finished```），且 Session Ticket 格式较冗余（含大量历史加密参数）。

### Session ticket（会话票据）
TLS 完整握手（尤其是密钥交换过程）需要双方进行复杂的加密计算（如 ECDHE 密钥协商），耗时较长。为了优化重复连接的效率，**让客户端和服务器在首次握手后保存会话信息，后续连接直接复用这些信息，快速建立安全连接**。

**会话复用有两种方式**：**Session ID**和**Session Ticket**。两者的区别：
* **Session ID 需服务端存储会话状态**，扩展性差；
    > 当客户端数量庞大的时候，对服务端的存储压力非常大
* **Session Ticket 由服务端加密会话信息，客户端存储**。恢复会话仍需 1-RTT。


**Session Ticket 具体原理：**

1. **首次握手时生成 Ticket**   
当客户端与服务器完成首次 TLS 握手后，服务器可以生成一个 Session Ticket。这个 Ticket 本质上是一段加密的会话信息，包含：
    * **本次会话使用的加密套件、主密钥**（Master Secret）
    * 会话的有效期等信息。
    * 服务器用**会话票证密钥（Session Ticket Key，对称密钥，由服务器生成并维护）**对这段信息**加密**，然后通过 NewSessionTicket 消息发送给客户端。

2. **客户端保存 Ticket**  
客户端收到 Ticket 后，不会解析其内容（因为是加密的），只是将其缓存起来（通常在内存中，有过期时间）。  

3. **复用会话时使用 Ticket**   
当客户端再次连接同一服务器时，可以在 Client Hello 消息中带上缓存的 Ticket，表明 “希望复用之前的会话”。  

    服务器收到 Ticket 后，使用**同一个会话票证密钥解密**，验证其有效性（如是否过期、是否被篡改）。若验证通过，直接复用 Master Secret 等信息，跳过后续的密钥交换、证书验证等步骤，快速完成握手。

Ticket 复用会话是有安全隐患的：每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。​

## 三、TLS 1.3握手
以“首次连接”（完整握手）讲解，“会话复用”（基于已有的会话密钥快速重连）比首次的精简不少

TLS 1.3 对握手过程进行了大幅优化，*简化了步骤*并减少了*加密套件种类*，**TLS 1.3 强制使用 ECDHE 密钥交换，无需协商**。

目标是提升安全性和减少握手延迟，通常只需**1 次往返通信（2 个消息）** 即可完成，甚至在特定场景下可实现 “0-RTT” 握手。

### 基本握手（1-RTT，首次连接）
适用于客户端与服务器首次建立连接，仅需1 次往返（2 个核心消息交互）即可完成握手。

* **步骤1：客户端问候（Client Hello）**：  
客户端**发送**以下几项：  
    * 支持的 TLS 1.3 版本
    * 加密套件列表（仅保留 ECDHE 等前向安全的套件）、
    * 客户端随机数（Client Random）、
    * **key_share 扩展**：客户端生成临时 ECDHE 密钥对，将**公钥（Client ECDHE Public）放入该扩展**，同时*指定使用的椭圆曲线*
（因为 TLS 1.3 强制使用 ECDHE 密钥交换，无需协商）。

* **步骤2：服务器响应**
    * **Server Hello**（明文，后续流程都是“加密”传送）
        * 确认 TLS 版本（TLS 1.3）。
        * 生成服务端随机数（Server Random）
        * 选定加密套件
        * **key_share 扩展**：服务端生成临时 ECDHE 密钥对，将公钥（Server ECDHE Public）放入该扩展（使用与客户端兼容的椭圆曲线）。  

        > **关键**：此时客户端和服务端已通过 key_share 交换了临时 ECDHE 公钥，可各自计算共享密钥（Pre-Master Secret）：  
        > ```共享密钥 = ECDHE(客户端私钥, 服务端公钥) = ECDHE(服务端私钥, 客户端公钥)```
    * **发送**以下几项内容（这几项都是”加密“传送）：
        * 证书（含公钥）
        * Encrypted Extensions（加密的扩展信息）
        * CertificateVerify（用服务端私钥 对握手消息签名，验证身份）
        * Finished（用握手生成的会话密钥 加密，证明服务端已正确生成密钥）

* **步骤3：客户端验证与响应**：
    * 验证证书和 CertificateVerify 签名，推导会话密钥，发送 Finished（用握手密钥加密，证明客户端已正确生成密钥），握手完成。

* **步骤4：服务端验证**：
    * 用会话密钥解密 客户端 Finished 消息，验证其中的哈希值是否与本地计算结果一致。若一致，则握手完成，后续应用数据 用会话密钥加密传输。

### 0-RTT 握手（复用会话时）
基于PSK：Pre-Shared Key，即：在发送Session Ticket的同时带上应用数据，不用等到服务端确认。

* 客户端在 Client Hello 中携带```psk_identity扩展```（标识预共享密钥），并可附带**0-RTT 数据**（如 HTTP 请求，用历史会话密钥加密）。
* 服务端验证 ```psk_identity``` 有效后，直接复用历史会话密钥，无需重新握手，即可解密并响应 0-RTT 数据，实现 “几乎无延迟” 的连接。

这种复用方法也**有安全隐患**：假如中间人截获PSK后，不断向服务器重复发，增加了服务器被攻击的风险。
> 貌似 TLS 1.2 和 TLS 1.3会话复用时，都是有安全隐患的！

## 四、TLS 1.3 握手的核心优化（对比 TLS 1.2）
四项：RTT、提前交换密钥材料、更早启用加密、移除不安全算法
* **减少往返次数**：从 **TLS 1.2 的 2个RTT（4 次消息交互）**优化为 **1个RTT（2 次消息交互）**，握手速度提升一倍。
* **提前交换密钥材料**：**客户端在 Client Hello 中就发送 ECDHE 公钥，而非像 TLS 1.2 那样单独发送 Client Key Exchange 消息**。
* **更早启用加密**：服务端的 Encrypted Extensions、Certificate 等消息已被加密，避免敏感信息（如证书细节、扩展字段）泄露。
* **移除不安全算法**：废除 RSA 密钥交换、CBC 模式等，仅保留 ECDHE 密钥交换和 AEAD 对称加密，安全性更可控。


## 五、TLS1.2 中，基于RSA、ECDHE密钥交换算法流程上的区别：
1. ECDHE 新增的：   
    * 客户端第一次请求: Client Hello 中新增 支持的椭圆曲线列表

    * 服务端第一次响应：
        * Server Hello：服务器选定的椭圆曲线列表
        * Server key Exchange中：
            * 服务器用自己的私钥对```服务器的临时 ECDHE 公钥、Client Random、Server Random做签名```，发送给客户端

2. 第二个 RTT 中，主要是两者不同的：   
    RSA中：
    * 客户端生成预主密钥(Pre-master Secret)并服务器证书中的公钥加密后传输给服务器
    * 服务端解密获得Pre-master Secret
    * 双方分别基于  Client Random、Server Random、Pre-master Secret 计算出会话密钥..

    ECDHE中：
    * 用服务器的公钥验签名，获取 服务端临时 ECDHE 公钥   
    * 客户端生成自己的临时 ECDHE 密钥对  
    * 双方分别生成 Pre-master Secret
    ```ECDHE(客户端私钥, 服务端公钥) = ECDHE(服务端私钥, 客户端公钥)```

<br/>

> // 步骤2、3的详细步骤如下：
> * **步骤2：服务器响应 Server Hello 及相关消息（客户端首次响应服务器，明文 + 加密）**：
>     * Server Hello（**明文**，后续流程都是“加密”传送）
>         * 确认 TLS 版本（TLS 1.3）。
>         * 生成服务端随机数（Server Random）
>         * 选定加密套件
>         * **key_share 扩展**：服务端生成临时 ECDHE 密钥对，将**公钥（Server ECDHE Public）放入该扩展**（使用与客户端兼容的椭圆曲线）。   
> 
>         **关键**：此时客户端和服务端**已通过 key_share 交换了临时 ECDHE 公钥**，可各自计算**共享密钥（Pre-Master Secret）**：   
>         ```共享密钥 = ECDHE(客户端私钥, 服务端公钥) = ECDHE(服务端私钥, 客户端公钥)```
>     * Encrypted Extensions（加密）  
>         * 发送扩展信息，是加密的（防止被窃取）
>     * Certificate（加密）   
>         * 服务端发送**服务器证书**，用于客户端验证服务端身份，*证书中包含服务端的身份信息（如域名）和公钥（用于验证后续签名），由CA机构签名*。
>     * CertificateVerify（加密）  
>         * 服务端用 **服务端私钥** 对 “握手上下文” 签名（握手上下文包括 Client Hello、Server Hello、Encrypted Extensions、Certificate 等所有消息的哈希值）。
>         * 客户端通过证书中的公钥验证该签名，确认：① 服务端拥有证书私钥（身份合法）；② 握手消息未被篡改。
>     * Finished（加密）
>         * 服务端生成 Finished 消息，包含对 “所有握手消息（至当前为止）” 的哈希验证值（用最终会话密钥加密）。
>         * 作用：证明服务端已正确生成会话密钥，且握手过程完整。
> 
> * **步骤3：客户端验证并发送 Finished 消息（客户端二次响应，加密）**
>     * 验证服务端身份  
>         * 验证证书有效性（检查是否由可信 CA 颁发、是否过期、域名是否匹配等）。  
>         * 用证书里的公钥验证 CertificateVerify 的签名，确认服务端身份和消息完整性。  
>     * 推导会话密钥  
>         * 用客户端临时 ECDHE 私钥 + 服务端临时 ECDHE 公钥，计算共享密钥（Pre-Master Secret）。  
>         * 结合客户端随机数、服务端随机数，通过 HKDF（密钥派生函数）生成最终的会话密钥（包括加密密钥、MAC 密钥等）。  
>     * 发送 Finished 消息（加密）  
>         * 客户端生成 Finished 消息，包含对 “所有握手消息（包括服务端 Finished）” 的哈希验证值（用会话密钥加密）。  
>         * 作用：证明客户端已正确生成会话密钥，且握手过程完整。  
> 
> * **步骤 4：服务端验证并完成握手**   
>     服务端收到客户端 Finished 消息后：   
>     * 用会话密钥解密 Finished 消息，验证其中的哈希值是否与本地计算结果一致。
>     * 验证通过：握手完成，双方进入加密通信阶段，后续应用数据（如 HTTP 请求）均用会话密钥加密传输。
