# 跨域

参考：
* 九种跨域方式实现原理（完整版）：https://juejin.cn/post/6844903767226351623
* 9种常见的前端跨域解决方案（详解）：https://juejin.cn/post/6844903882083024910
* iframe 跨域的几种方案：https://juejin.cn/post/6844903831973675015
* 正确面对跨域：https://juejin.cn/post/6844903521163182088

跨域访问的九种方式：
* Jsonp
* CORS
* Nginx反向代理中转
* Websocket
* PostMessage
* Node中间件代理
* window.name + iframe
* location.hash + iframe
* document.domain + iframe (二级域名相同)


## 什么是跨域？
- 协议
- 域名
- 端口号
三者都一样就是同源，三者只要有一个不同，就不同源。

- 同源策略请求：ajax / fetch
- 非同源(跨域)请求:
在早期的时候，前端和后端没有进行分离，前端和后端都部署在同一台服务器上，他们的ip地址(域名)，端口都相同，
因此不存在跨域的问题。但是在**本地进行开发**的时候，还是会面临跨域的问题，比如：

```js
// 本地的服务器是：
http://127.0.0.1/index.html
```

```js
// 但是，服务器请求的api是：
http://api/baidu.com/getData
```

```js
// 这样的话就会由于域名不同，导致跨域，因此通常会修改host:
127.0.0.1:8080 http://api/baidu.com
```
## 跨域请求的限制
当发生跨域请求时，浏览器会拦截请求或响应，常见的限制包括：  
1. **AJAX 请求被阻止：** XMLHttpRequest 和 Fetch API 默认遵循同源策略，跨域请求会被浏览器拦截。
2. **Cookie、LocalStorage 等数据无法共享：** 不同源的页面无法直接访问对方的 Cookie、LocalStorage 等数据。
3. **DOM 无法访问：** 不同源的页面无法直接操作对方的 DOM 元素。

## 跨域是如何产生的？

在部署服务器的时候，为了保证每个服务器的资源都能够被合理利用，通常我们会将服务器进行拆分：
1. web服务器：项目的静态资源部署在这种服务器上。(aa.baidu.com)
2. data服务器：后台api接口开发等，业务逻辑，数据分析。(api/baidu.com)
3. 图片/音视频服务器：这种请求慢的资源单独部署在服务器上。
4. 第三方服务部署在单独的服务器上。
每一台服务器都有它自己的域名，比如web服务器的域名是`aa.baidu.com`，而后台接口的服务器是`api/baidu.com`，不同的域名，在进行请求时就出现了跨域了。
在日常开发中，服务器分开部署是最常见的，因此，跨域也是工作开发过程中遇到的最多的。

## 跨域的解决方案

### 一、JSONP
浏览器中存在的以下标签：
```html
script
img
link
iframe
...
```
这些标签请求资源时不存在跨域的问题，如下所示无论是通过cdn请求资源还是本地请求资源都不涉及跨域。
```js
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js"></script>
<script src = "./1.js"></script>
```
而JSONP就是利用`script`标签的这种无跨域的特性实现的。
须一致。
![jsonp原理](https://ftp.bmp.ovh/imgs/2021/03/183348b65c44d9e6.png)

如上图所示：JSONP的流程大致如下：
1. 通过script的src标签发送一个请求，请求中传递一个`callback`参数，这个参数可以是任意的，参数的值是定义的一个全局函数。
2. 服务器端接收到请求，就会拿到callback这个参数，然后它开始准备返回数据，将返回的数据和接收的函数进行包装，包装成一个函数带参数执行的字符串，'func('+JSON.stringify(data)+'))'；
3. 客户端接收到参数以后会执行这个函数，函数的参数就是服务器端返回的数据。

**JSONP的特点：**
1. 必须基于script之类的标签
2. func最好是个全局函数
3. jsonp必须跟服务器端统一设置，callback参数必须跟后端一致。

**JSONP的优缺点：**
* 优点：兼容性好，支持老浏览器
* 缺点：
  1. 安全性较低（容易受到 XSS 攻击）、只支持 GET 请求、需要服务器配合实现。
  2. 所有的script,link等资源文件请求都是get请求，因此JSONP也只能实现get请求。
  3. jsonp返回的内容会默认执行，因此如果被拦截后返回一个垃圾代码，可能也会带来安全问题。


### 二、CORS跨域资源共享
浏览器的 “同源策略” 会拦截跨域请求，但如果服务器返回的响应头中包含 Access-Control-Allow-Origin 等 CORS 相关头，浏览器会放行。

跨源资源共享 (CORS) 是一种基于HTTP 头的机制！

现代浏览器支持在 API 容器中（如：MLHttpRequest 或 Fetch）使用 CORS，以降低跨源 HTTP 请求所带来的风险。

什么情况下需要 CORS ？
* XMLHttpRequest 或 Fetch 发起的跨源 HTTP 请求。
* Web 字体 (CSS 中通过 @font-face 使用跨源字体资源)
* WebGL 贴图
* 使用 drawImage 将 Images/video 画面绘制到 canvas


对于复杂请求来说，会先进行一次 options 预检请求，检查服务器是否会允许要发送的真实请求。
* 在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。
* 在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证。
* 预检请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。
* 预检请求不会对服务器资源产生影响
* 大多数浏览器不支持针对于预检请求的重定向。如果一个预检请求发生了重定向，浏览器将报告错误，有两种方式规避上述报错行为：在服务端去掉对预检请求的重定向、将实际请求变成一个简单请求。

参考：[预检请求详情](./0.1__预检请求.md)

### 三、http-proxy
需要配合webpack和webpack-dev-server使用。

### 四、nginx实现代理
参考：[Nginx解决跨域](./2.0__Nginx解决跨域.md)

### 五、postMessage
参考：[MDN中 的 posstMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)
