# 数字签名
参考：  
[签名与加密对比](./2.2.3__签名与加密对比.md)

[签名机制中的“不可否认性”是如何验证的？](./2.2.4__签名机制中的不可否认性.md)

以 “A 向 B 发送文件” 为例：
    A 在发送 “**原始文件 + 数字签名（A的私钥 对原始文件计算得到的哈希值 加密后的结果）**” 时，同时附上自己的**数字证书（证书中包含 A 的公钥、身份信息及 CA 签名）**。

**整个过程貌似有2个签名？**
1. CA用自己的私钥 对服务器的公钥、身份信息 做签名，这个签名包含在“数字证书”中
2. 服务器用自己的私钥 对要发送的信息 做签名

**整个过程客户端要验证的：**（数字签名的验证本质是 “双重验证”：既要确认签名来源（身份），也要确保信息未被篡改）
1. 发送方的公钥是否可信？（非常关键）
2. 摘要是否和发送方传的一致？

**前提条件**：客户端预装了 CA 的根证书（公钥）。根证书是 “信任的起点”，客户端通过预装这些根证书，才能确认 “哪些机构颁发的数字证书是可信的”。

## 数字证书
**1. 定义：**  
数字证书是由权威机构（CA）颁发的 “电子文件”，包含三大核心信息：  
* 持有者的身份信息（如服务器域名、个人 / 机构名称）；
* 持有者的公钥；
* CA 用自己的私钥对上述信息生成的摘要 做的数字签名（即：对上述信息先做摘要算法，然后再用 CA 私钥 对摘要加密，也就是做数字签名）。

**2. 核心作用：**
* **证明公钥的归属**：通过 CA 的权威背书，确认 “证书中的公钥确实属于该身份持有者”，**解决 “公钥被伪造” 的问题**。
* **构建信任链**：客户端预装 CA 的根证书（包含 CA 公钥），可通过验证 CA 的签名确认证书真实性，从而确认服务器身份，进而信任证书中的公钥。

**3. 数字证书何时携带？**
* （1）需要每次携带的场景：强调实时身份验证，如：
    * **HTTPS 首次握手**：浏览器与服务器首次建立连接时，服务器必须向浏览器发送数字证书（含公钥），浏览器通过验证证书确认服务器身份后，才能生成对称加密密钥进行后续通信。  
    * **单次 API 调用（无会话机制）**：在没有会话缓存的 API 通信中（如开放平台的单次接口请求），调用方需携带证书证明身份，接收方通过证书验证公钥合法性，避免伪造请求。  

    原因：双方缺乏预先存储的信任信息（如缓存的证书或公钥），必须通过每次携带证书确保身份可信。  

* （2）无需每次携带的场景：依赖缓存或会话机制。如： 
    * **HTTPS 长连接 / 会话复用**：浏览器与服务器完成首次握手并验证证书后，会缓存服务器的证书（或公钥），在同一会话的后续请求中（如浏览同一网站的不同页面），无需再次传输证书，直接使用缓存的公钥进行加密通信。

    原因：双方已通过首次验证建立信任，缓存证书可避免重复传输冗余信息，提升通信效率。  

## 数字签名
数字签名是一种结合密码学技术的安全机制，用于**验证电子文档的完整性、真实性和不可否认性**，*相当于传统手写签名在数字世界的安全替代方案*。它通过数学算法**确保信息在传输或存储过程中未被篡改，且能确认发送者身份**。

一、数字签名的核心作用

* 身份认证：确认信息发送者的真实身份，防止他人冒充。
* 完整性验证：保证信息在传输或存储过程中未被篡改。
* 不可否认性：发送者无法否认已发送的信息（类似手写签名的法律效应）。

二、数字签名的工作原理  

数字签名基于**非对称加密算法（如 RSA、DSA、ECDSA 等）**，涉及两个密钥：  
* **私钥：**由**发送者独家持有**，用于生成签名。
* **公钥**：公开可查，用于验证签名（*通常绑定在发送者的数字证书中*）。

数字签名的具体流程分为**签名生成**和**签名验证**两步：
* **签名生成（发送方）**：
    * 发送者*对原始信息进行哈希计算*（如 SHA-256），生成固定长度的*哈希值（摘要）*，用于浓缩信息特征。
    * 用*发送者的私钥*对哈希值加密，生成*数字签名*。
    * 将原始信息、数字签名一并发送给接收方。
* **签名验证（接收方）**：
    * *接收方用发送者的公钥*对数字签名解密，得到一个哈希值（发送方计算的摘要）。
    * 接收方对收到的原始信息*重新计算哈希值*。
    * 对比两个哈希值：
        * 若一致：说明：(1)信息未被篡改，(2)签名确实由发送方私钥生成。（来源真实性验证通过，因为公**钥能解开的签名一定是配对的私钥生成的**）。
        * 若不一致：信息被篡改，或签名来自伪造者。
    > 关键技术：**哈希函数**  
    > 哈希函数是数字签名的核心辅助技术，其特点包括：  
        > 1. 固定输出：无论输入信息长度如何，输出哈希值长度固定（如 SHA-256 输出 256 位）。  
        > 2. 不可逆性：无法从哈希值反推原始信息。  
        > 3. 抗碰撞性：*很难找到两个不同的信息生成相同的哈希值*（确保篡改会被发现）。
        > 4. 唯一性：同一原始信息会生成唯一的哈希值，哪怕原始信息有 1 比特的改动，哈希值也会完全不同（“雪崩效应”）。 
    > 
    > 常用哈希算法：SHA-1（已不安全）、SHA-256、SHA-3 等。

三、数字签名中的身份认证、完整性/真实性/不可否认性 验证 区别与联系

假设用户 A 给用户 B 发一份 “电子合同”，并附带自己的数字签名，B 需要确认 “这份合同确实是 A 发的（真实性）”。

* **身份认证** (验证A的身份，**确认公钥的归属**)：
B 通过“CA证书”确认 “签名中用到的公钥，确实属于A”，这一步就是“身份认证”。只有先做身份认证后，才能做后续的完整性、真实性、不可否认性验证。

* **完整性** (防止篡改)：确保“**信息内容** 没被修改”，防的是”攻击者“，防止攻击者 篡改信息；   
* **真实性** (防止伪造)：确保“**信息来源** 可信、不是伪造的”，防的是”攻击者“，防止攻击者 用自己的假私钥 伪造签名等；  
* **不可否认性** (防止抵赖，防的是”签名生成者“)：确保“签名者事后无法抵赖自己的行为”，如：签名者说，...不是我发送的，这个签名不是我生成的；**避免签名者事后抵赖**。  

**真实性 是依赖 完整性的**，假如内容被篡改了，就没必要验证它的来源是否可信了。    

真实性、不可否认性，都是依据```只有 “发送方的私钥” 能生成 “被发送方的公钥解密通过的签名”```这个特性来的，假如用发送者的公钥解不开签名，那来源就不可靠。因为私钥是唯一的，只有发送方才有，只有它才能生成被公钥解开的签名。



四、疑问❓：
发送者的公钥是如何拿到的呢？（以 “A 向 B 发送文件” 为例）
1. 在**封闭、可信环境（如内网）下**，接收方可通过下面2种方式直接获取公钥，无需验证其真实性：
    * 线下提前交换：如使用U盘
    * 随消息一同发送：A 在发送 “原始文件 + 数字签名” 时，额外附上自己的公钥。此时**接收方 B 默认信任该公钥**（前提是双方已确认不会被中间人篡改，如小范围私密通信）。
2. 在**互联网等开放场景中**：**必须通过数字证书获取公钥**，*利用 CA 的权威验证公钥真实性*。流程如下：
    * （1）发送方提供数字证书 
    A 在发送 “**原始文件 + 数字签名（A的私钥 对原始文件计算得到的哈希值 加密后的结果）**” 时，同时附上自己的**数字证书（证书中包含 A 的公钥、身份信息及 CA 签名）**。
        > 疑问❓：这个证书怎么生成呢？    
        > 回答：A 生成密钥对后，向 CA 提交 “自己的公钥 + 身份信息（如姓名、域名）”，**CA 验证 A 的身份后，用 CA 私钥对这些信息签名，生成包含 “A 的公钥、A 的身份、CA 签名” 的数字证书（即 A 的证书）**。
        > 
        > 更详细的流程如下：  
        > **1. 服务器向 CA 提交 “证书申请”**  
        > 服务器生成密钥对后，会将自己的公钥、身份信息（如域名、组织名称）等打包成 “证书签名请求（CSR）”，提交给 CA（如 Let's Encrypt、VeriSign 等）。
        > **2.CA 验证服务器的身份**  
        > CA 收到 CSR 后，会验证服务器的真实身份（如验证域名所有权：给域名管理员发邮件、解析特定 DNS 记录等）。只有验证通过，CA 才会继续处理。  
        > **3. CA 颁发数字证书**    
        > 验证通过后，CA 对 “服务器公钥 + 身份信息” 计算哈希值，并*用CA 自己的私钥加密哈希值*，生成 “CA 的数字签名”；然后，CA 将 “服务器身份信息 + 服务器公钥 + CA 的数字签名” 打包，形成 “服务器的数字证书”，颁发给服务器。  
        > **4. 服务器部署证书**  
        > 服务器将 CA 颁发的数字证书（包含公钥）部署到自己的服务中（如 HTTPS 服务器配置证书），用于向客户端证明身份。

    * （2）接收方验证证书，提取公钥  
    B 通过以下步骤确认证书合法性，进而获取可信公钥：
        * 验证证书签名：用**预装的 CA 根证书（含 CA 公钥）解密证书中的 CA 签名**，确认证书未被篡改（CA 签名的作用类似 “公章”，证明证书内容真实）。
        * 核对身份信息：检查证书中记录的 A 的身份（如域名、公司名称）是否与实际发送者一致（避免证书被他人盗用）。
        * 提取公钥：若证书验证通过（这时说明A的公钥是真实可信的、不是伪造的），直接从证书中提取 A 的公钥，用于后续数字签名的验证。

五、疑问❓：
数字签名过程中，攻击者不可能用“假的信息”生成“假的摘要”，然后用“假的密钥对”做签名生成，把“假的公钥”给到客户端做验证，会存在这种情况吗？  
**回答**：  
* **理论风险**：攻击者 “全套伪造”（假信息、假摘要、假密钥对、假公钥）在技术上可行，*核心漏洞是公钥归属无法验证*。  
* **实际防范**：通过数字证书和 CA 的信任链，接收方可以确认公钥的真实性，从而避免此类攻击。这也是现代数字签名体系必须依赖可信第三方的根本原因。  

**没有 CA 和数字证书，数字签名的 “身份认证” 功能会失效；有了 CA 的背书，公钥的真实性才能得到保障。**

原因如下：  
1. 攻击场景的可行性：“全套伪造” 的逻辑漏洞
表面上验证 “通过”，但接收方**实际获取的是伪造信息，且误信了攻击者的身份**。
2. 核心问题：**如何确保 “公钥确实属于发送方”**？如果没有机制验证公钥的归属，“公钥伪造” 就可能导致整个签名体系失效。
3. 防范机制：数字证书与 CA 的作用
为解决公钥真实性问题，数字签名体系引入了数字证书和可信第三方（CA）： 

    > 数字证书的本质：由 CA 颁发的 “公钥身份证”，包含以下核心信息：  
        > * 发送方的身份信息（如名称、域名等）；  
        > * 发送方的真实公钥；  
        > * CA 对上述信息的签名（用 CA 的私钥加密的证书哈希值）。  
    >     
    > 验证流程的补充：
        > * 发送方在发送签名信息时，需同时附上自己的数字证书；  
        > * 接收方首先验证证书的真实性：用 CA 的根公钥（预装在操作系统、浏览器中，默认可信）解密证书中的 CA 签名，对比证书内容的哈希值，确认证书未被篡改且确实由 CA 颁发；  
    > 从验证通过的证书中提取发送方的真实公钥，再用该公钥验证信息签名。

**为何能防范伪造？**
* 攻击者若想伪造证书，必须用 CA 的私钥签名（否则接收方用 CA 根公钥验证时会失败），但 CA 的私钥是高度保密的，攻击者无法获取；
* 若攻击者自行生成 “假证书”（无 CA 签名），接收方会因无法验证证书来源而拒绝信任其包含的公钥。


## 根CA证书
### 1. 什么是CA 根证书？
CA（证书颁发机构）是**网络世界的 “可信第三方”**，负责为服务器、个人等实体颁发数字证书（证明 “公钥属于该实体”）。而**根证书是 CA 自己给自己颁发的证书**，包含两部分关键信息：

* CA 的公钥（用于验证 CA 颁发的其他证书）；
* CA 的身份信息（如机构名称、有效期等），以及 CA 用自己的私钥对这些信息的签名（自签名）。

根证书的核心作用：**作为整个信任链的 “锚点”，所有由该 CA 颁发的证书，最终都要通过根证书来验证合法性**。

### 2. 为什么客户端要 “预装” 根证书？
客户端（如浏览器、操作系统、手机 APP）无法凭空判断 “某个 CA 是否可信”，因此**需要提前内置一批经过筛选的、全球公认的可信 CA 根证书**。这就像现实中，我们会默认信任政府机构、知名企业的公章，而不会信任来历不明的印章。

客户端预装 CA 根证书，本质是**提前植入 “信任基准”，让数字证书的验证有一个可信的起点**。*没有这些预装的根证书，客户端无法判断服务器证书的真伪，整个数字签名和加密体系的安全性就无从谈起*。

### 根证书何时预装？
**根证书通常在客户端（软件或设备）出厂、安装或首次部署时被预先写入证书库，后续会通过更新机制动态调整**。主要有：
* **操作系统**的根证书预装，主要在系统发布或安装时被写入系统级证书库
* **浏览器**的根证书预装，主要有2种  
    * 依赖系统证书库的浏览器（如 Chrome、Edge）：不单独预装根证书，直接调用操作系统的根证书库。  
    * 自带独立证书库的浏览器（如 Firefox）：在浏览器安装包中内置独立的根证书列表
* **移动设备**（手机、平板）的根证书预装
    * **出厂时**：手机厂商（如苹果、华为、小米）会在设备出厂前，将可信 CA 根证书预装到系统证书库中。
    * **系统更新时**：通过 OTA 系统更新（如 iOS 升级、Android 大版本更新），设备会同步更新根证书列表（如移除不安全的 CA，添加新的可信 CA）。
* 根证书的 “动态更新”（非预装，但重要）：除了首次预装，根证书列表会通过以下方式动态调整，确保安全性
    * 系统 / 软件更新
    * 手动添加 / 删除：但不建议删除系统默认的可信 CA* 