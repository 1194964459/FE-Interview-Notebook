# Fetch

参考：[阮一峰讲解Fetch](https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html)

fetch()是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。浏览器原生支持该对象。基于 Promise 实现，支持 async/await。

**用法**：
```js
try {
    let response = await fetch(url);
    let data = response.json();
    console.log(data);
} catch(e) {
    console.log("Oops, error", e);
}
```

核心配置：
* credentials：指定是否发送 Cookie。
    * same-origin：默认值，只有同源请求时发送 Cookie。
    * include：不管同源请求，还是跨域请求，一律发送 Cookie。
    * omit：不携带
* mode：指定请求的模式。默认值为cors，允许跨域请求。
* signal：指定一个 AbortSignal 实例，用于取消fetch()请求

## Fetch 缺点
fetch只对网络错误、跨域或无法连接才报错，对**400，500都当做成功的请求**，需手动判断`response.ok`(布尔值), 
* `response.ok`的取值：true对应 HTTP 请求的状态码 200 到 299，false对应其他的状态码。
* 疑问❓：为什么 404/500 不会触发 reject？答：Fetch认为，只要浏览器成功接收到了服务器的 “响应”（无论响应内容是数据还是错误提示），就认为请求 “完成了”，Promise 就会 resolve。
```js
fetch('https://api.example.com/nonexistent')
.then(response => {
    // 关键步骤：判断 ok，不满足则抛错
    if (!response.ok) {
    // 抛出的错误可以携带状态码和状态文本
    throw new Error(`请求失败：${response.status} ${response.statusText}`);
    }
    // 只有 ok 为 true 时才解析数据
    return response.json();
})
.then(data => {
    console.log('正常数据：', data);
})
.catch(error => {
    console.error('错误处理：', error.message); // 打印“请求失败：404 Not Found”
});
```

## Fetch 与 XHR 比较，从六点分析：
是否有模块化设计？是否通过数据流处理数据？
超时、中止请求、请求进度获取、Cookie等凭证是否自动发送？

* **模块化设计**：
    * 符合关注分离，API分散在 Response、Request、Headers三个对象中
    * xhr 是输入、输出、状态都在同一个接口管理，比较混乱；
        > xhr中属性、事件、方法，甚至返回的response 及 status啥的，都是挂载在同一个 xhr 对象上的。（参考：[XHR完整示例](./5.1__xhr.md)）

* **fetch 通过数据流 处理数据**，可以分块读取；xhr 不支持数据流，所有的数据必须放在缓存里，不可以分块读取。
    ```js
    response.json() // 将 Stream 对象转成json
    response.text()：解析为文本字符串。
    response.blob()：解析为二进制 Blob 对象（如图片、文件）。
    ```
* fetch没有自带的 中止请求方法，需配合 AbortController才行；xhr 直接调用abort() 方法即可
* fetch没有自带的 超时控制方法，需结合setTimeout、AbortController 自行实现；xhr 中 直接用timeout属性控制即可！
```js
// 创建控制器和信号
const controller = new AbortController();
const { signal } = controller;

// 超时后通过控制器终止请求
setTimeout(() => {
  controller.abort(); // 真正终止请求的网络连接
}, 3000);

// 发起请求时关联信号
fetch('https://api.example.com/slow', { signal })
  .then(response => console.log('请求成功'))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('请求超时并已被终止'); // 正确终止请求
    } else {
      console.log('其他错误：', error);
    }
  });
```

* fetch**没有办法 原生监测请求的进度**，而 xhr可以
* fetch 与 xhr 在同域、跨域场景下是否携带Cookie等凭证，各种情况如下：

## XHR 和 Fetch 是如何对Cookie进行处理的？
两者的跨域请求，在默认情况下都是不会携带 Cookie 等凭证的！具体区别如下：

* XHR：通过 withCredentials 控制跨域场景下是否携带 Cookie、HTTP 认证信息等凭据。注意，该属性仅作用于跨域请求。同源请求中，不管 withCredentials值 是true 还是 false，都不会影响浏览器自动携带 Cookie的事实！
    * 跨域场景默认是不携带cookie的；因为 withCredentials默认值为false
    * 若想携带需前后端互相配合：
        * 前端：使用xhr时，`withCredentials：true`。若使用Axios库，`axios.defaults.withCredentials = true; // 设置全局默认值`
        * 后端：添加响应头`Access-Control-Allow-Credentials: true`，并且 `Access-Control-Allow-Origin 不能设置为 *`

* Fetch中，通过 credentials 控制是否携带凭据（Cookie、HTTP 认证信息等）。同域请求下，credentials若为omit，是不会携带凭证的；这点与 xhr 有很大不同，xhr 是只要在同域的请求，不管withCredentials属性值设置成什么样 都会携带凭证。

    credentials的不同配置：

    | 取值	| 核心作用| 
    | ---- | ---- |
    | 'same-origin'（默认）	| 仅在同域请求时携带凭据，跨域请求不携带。| 
    | 'include'	| 同域和跨域请求均携带凭据（跨域需后端配合 CORS 规则）。| 
    | 'omit'| 	不携带任何凭据（无论同域还是跨域）。| 

    * 跨域场景下，若想携带Cookie等凭证，前端应将 credentials 设为 include；后端处理同 xhr 一致（添加响应头`Access-Control-Allow-Credentials: true`，并且 `Access-Control-Allow-Origin 不能设置为 *`）

* Token 通常通过 HTTP 请求头（如 `Authorization: Bearer <token>`）传递，不受同源策略限制，跨域请求时只需服务端允许自定义头（Access-Control-Allow-Headers: Authorization）即可，配置简单。