# SSL/TLS 详解

**前向安全性**（Forward Secrecy，简称 FS 或 PFS）是密码学中的一个重要概念，主要用于**保障通信过程中密钥的安全性**，*即使长期密钥泄露，也不会影响过去已加密通信内容的保密性*。

TLS 1.2 目前仍广泛使用，但是TLS 1.3才是目前主流推荐版本！！

## 基本知识了解
**TLS 协议中主要有三种算法**：
* **1. 密钥交换算法**：用于客户端和服务器安全**协商共享密钥（如预主密钥）**，是握手的核心。
    > ECDHE：前向安全（即使私钥泄露，历史通信也无法解密；但需双方协商支持），（*目前应用最广泛*）。   
    > RSA：无前向安全（*应用次于 ECDHE，但仍有一定存量*。TLS 1.3 已废除 RSA 密钥交换，仅保留 RSA 用于签名）   
    > DH：安全性和 RSA 差不多（当前用的最少）
* **2. 签名算法**（身份认证，与证书绑定）：通过证书签名，主要用于**验证服务器（或客户端）身份，确保通信对象合法**。
    > RSA  
    > ECDSA（与RSA 签名算法相比，在提供同等安全级别时，所需的密钥长度更短）
    > EdDSA，更高效

* **3. 对称加密算法**：用于后续应用数据加密的**会话密钥所依赖的算法**（如 AES、ChaCha20）。
    > AES-CBC（TLS 1.3中被废除了）
    > AES-GCM (AEAD 模式)
    > ChaCha20-Poly1305  (AEAD 模式)  

**其中 TLS 1.3 中：密钥交换算法（强制且唯一是ECDHE）、对称加密算法（强制 AEAD 模式）**

TODO:TLS 1.2 与 1.3 握手 有啥区别？

## TLS 1.2握手

TLS 1.2 中客户端和服务器各发送 2 次请求，每轮请求包含多个消息。

请求与消息：
* **“请求” 更强调逻辑上的交互轮次**（每轮请求可能包含多个消息），而 **“消息”是具体的协议数据单元**。
* 注意：**发送消息只需要 TCP 连接，不需要先发送 “请求”**。

TODO:这是1.2的？还是1.3的？
### 一、客户端会给服务器发送2次请求，不同请求传递的消息有：   
1. **第一次请求**：发起握手
    * **Client Hello**

    > 服务器回应：会返回服务器侧的首轮响应消息（见下文服务器请求）。

2. **第二次请求**：完成密钥交换并确认握手（以下消息按顺序发送，逻辑上属于同一轮请求）
    * （可选）**Certificate（双向认证时）**：客户端证书链，证明客户端身份。
    * **Client Key Exchange**（核心密钥材料，如 ECDHE 公钥或加密的预主密钥）；
        * 若为 RSA 密钥交换：用**服务器公钥**加密的预主密钥（**Pre-Master Secret**）。
        * 若为 ECDHE 密钥交换：客户端生成的**临时公钥（Client ECDHE Param）**。
    * （可选）**Certificate Verify（双向认证时）**：客户端用私钥对握手消息流的哈希签名，证明对证书的所有权。
    * **Change Cipher Spec**：告知服务器 “后续消息将用会话密钥加密”；
    * **Finished**（验证握手过程的完整性和密钥的正确性）。用协商的**会话密钥**加密的验证消息，*包含***对所有握手明文消息的哈希值**（验证握手完整性）。
TODO:Finished中的实现细节
    > 服务器回应：发送最终的Finished消息，确认握手完成。

### 二、服务端给客户端发送2次请求，不同请求传递的消息有：   
1. **第一次请求**：回应客户端初始握手，确认握手参数，提供服务器身份信息和密钥材料。（以下消息按顺序发送，逻辑上属于同一轮响应）：   
    * **Server Hello**：确认 TLS 版本、选定的加密套件、服务器随机数、会话 ID 等。
    * **Certificate**：服务器证书链，证明服务器身份。（注意📢：是可选项，但大多数都用了，所以这里搞成必选；TLS 1.2 与 1.3中）
    * （可选）**Server Key Exchange**：
        * 若为 ECDHE 密钥交换：服务器生成的临时公钥（Server ECDHE Param）。
        * 若为 DH 密钥交换：服务器的 DH 参数。
    * （可选）**Certificate Request**（可选，双向认证时）：要求客户端提供证书。
    * **Server Hello Done** ：标志服务器首轮消息发送完毕，等待客户端回应。

    > 客户端回应：发送上述客户端的第 2 次请求消息。

2. **第二次请求**：确认密钥并完成握手（以下消息按顺序发送，逻辑上属于同一轮响应）：   
* **Change Cipher Spec**：告知客户端 “后续消息将用会话密钥加密”。
* **Finished**：用会话密钥加密的验证消息，包含对所有握手明文消息的哈希值（验证握手完整性）。

    > 客户端不需要回应，客户端只需要验证Finished消息，验证通过后表示当前握手已经完成，双方可以用会话密钥加密通信（即数据传输阶段）。**Finished消息是握手的最终确认信号**


## TLS 1.2 握手过程

TLS 1.2 中基于 ECDHE 的加密套件命名格式为ECDHE-<认证算法>-<加密算法>-<哈希算法>


TLS 1.2 握手过程相对复杂，主要包括客户端问候、服务器问候、证书验证、密钥交换和会话结束确认等步骤，通常需要2 次往返通信 才能完成。

**握手过程中，所有消息在传输时均为明文，直到双方发送 Change Cipher Spec 后才切换为加密通信**。



///////////////////////////////////
TLS 1.2 中通过 RSA 或 ECDHE 等方式，用服务端公钥加密预主密钥（或交换临时公钥），确保只有服务端能解密并生成会话密钥；

TLS 1.3 简化了握手流程，但仍通过非对称加密（如 ECDHE）完成密钥材料的安全交换。
///////////////////////////////////


## TLS 1.3握手

以“首次连接”（完整握手）讲解，“会话复用”（基于已有的会话密钥快速重连）后面再讲，比首次的精简不少


TLS 1.3 对握手过程进行了大幅优化，简化了*步骤*并减少了*加密套件种类*，**TLS 1.3 强制使用 ECDHE 密钥交换**，无需协商。

目标是提升安全性和减少握手延迟，通常只需**1 次往返通信（2 个消息）** 即可完成，甚至在特定场景下可实现 “0-RTT” 握手。

### 基本握手（1-RTT，首次连接）
适用于客户端与服务器首次建立连接，仅需1 次往返（2 个核心消息交互）即可完成握手。

* **客户端问候（Client Hello）**：  
客户端**发送**以下几项：  
    * 支持的 TLS 1.3 版本
    * 加密套件列表（仅保留 ECDHE 等前向安全的套件）、
    * 客户端随机数（Client Random）、
    * 客户端临时公钥（Client ECDHE Param），因为 TLS 1.3 强制使用 ECDHE 密钥交换，无需协商。

* **服务器响应**：
    * 服务器**选择**加密套件，
    * **生成**服务器随机数（Server Random）、临时公钥（Server ECDHE Param），
    * **发送**证书（含公钥）、服务器临时公钥，
    * 并直接**计算**出预主密钥和会话密钥。
* **服务器** **同时发送** “Change Cipher Spec” 和 “Finished” 消息（用会话密钥加密）。
* **客户端**收到后，验证证书和服务器信息，计算会话密钥，发送 “Change Cipher Spec” 和 “Finished” 消息，握手完成。

### 0-RTT 握手（复用会话时）
* 若客户端与服务器之前建立过会话，客户端会在 “Client Hello” 中携带会话票据（Session Ticket，由服务器之前发送，包含会话密钥相关信息）和 “0-RTT 数据”（可在握手未完成时提前发送加密的应用数据，如 HTTP 请求）。
* 服务器验证会话票据有效后，直接恢复会话密钥，双方无需重新计算密钥，握手几乎瞬间完成，极大减少延迟。


### Session ticket
Session ticket（会话票据） 是一种用于实现会话复用（Session Resumption）的机制，目的是在客户端与服务器之间重复建立连接时，跳过完整的握手过程，从而减少延迟、节省计算资源。

TLS 完整握手（尤其是密钥交换过程）需要双方进行复杂的加密计算（如 ECDHE 密钥协商），耗时较长。为了优化重复连接的效率，让客户端和服务器在首次握手后保存会话信息，后续连接直接复用这些信息，快速建立安全连接。

Session Ticket 就是实现这种复用的一种方式（另一种常见方式是 Session ID）。

**具体原理：**

**1.首次握手时生成 Ticket**   
当客户端与服务器完成首次 TLS 握手后，服务器可以生成一个 Session Ticket。这个 Ticket 本质上是一段加密的会话信息，包含：
* 本次会话使用的加密套件、主密钥（Master Secret）
* 会话的有效期等信息。
* 服务器会用自己的私有密钥对这段信息加密，然后通过 NewSessionTicket 消息发送给客户端。

**2. 客户端保存 Ticket**  
客户端收到 Ticket 后，不会解析其内容（因为是加密的），只是将其缓存起来（通常在内存中，有过期时间）。  

**3. 复用会话时使用 Ticket**   
当客户端再次连接同一服务器时，可以在 Client Hello 消息中带上缓存的 Ticket，表明 “希望复用之前的会话”。  

服务器收到 Ticket 后，用自己的私有密钥解密，验证其有效性（如是否过期、是否被篡改）。如果有效，就可以直接使用 Ticket 中保存的主密钥等信息，跳过后续的密钥交换、证书验证等步骤，快速完成握手。