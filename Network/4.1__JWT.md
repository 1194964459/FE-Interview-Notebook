# JSON Web Token（缩写 JWT） 

参考：
秋天不落叶：https://juejin.cn/post/6844904034181070861#heading-3

阮一峰：http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html


JSON Web Token（缩写 JWT）是一种**基于 JSON 的轻量级身份认证和数据交换规范**，通过**数字签名**确保信息的完整性和真实性，广泛用于跨域认证、API 授权等场景。
> 数字签名详见：[数字签名](./2.2.2__数字签名.md)

核心原理：**用数字签名保证令牌不被篡改**，让服务端无需存储会话即可验证用户身份，是现代 Web 应用中主流的认证方案之一。 

核心细节：**“服务端生成一个包含用户信息的令牌，客户端存储并在后续请求中携带，服务端通过验证令牌合法性实现无状态认证”**

注意：
* **签名生成、签名验证 都在服务端进行**！
* **客户端的主要是存储和传递 Token**！

## 一、JWT 出现的背景及原因

JWT 的必要性可简单概括为：为**分布式、跨平台**场景提供**轻量、无状态、可验证**的身份认证与数据交换方案。

它解决了传统 Session 认证在**分布式系统中 “状态共享难”**“跨服务认证复杂” 的问题，同时**适配移动端、小程序等非浏览器环境**，通过**自包含的签名**信息实现高效的**跨域/跨服务身份验证**，简化了现代应用的认证流程。

**1. 分布式系统与微服务架构的兴起**  
随着互联网应用的规模化，系统架构从单体应用逐渐演进为分布式系统和微服务架构。
* 传统的单点认证方案（如服务端用 Session 存储用户状态）存在Session共享问题
* 跨服务认证成本高：微服务间调用时，每个服务都需要重复验证用户身份。

    > JWT 的无状态特性（自身包含完整的身份信息，无需依赖服务端存储）完美适配了分布式场景：服务端无需保存用户状态，任何服务只要能验证 JWT 的签名，就能直接确认用户身份，大幅简化了跨服务、跨服务器的认证流程。

**2. 传统认证方案的局限性**    
在 JWT 出现前，主流的身份认证方案（如 Session-Cookie、OAuth1.0）存在明显短板：
* Session-Cookie 的弊端：
    * 依赖服务端存储（内存/数据库），当用户量激增时，存储压力大，且不利于水平扩展。
    * 容易受到 CSRF（跨站请求伪造）攻击，需要额外措施（如 Token 验证、Referer 检查）防护。
    * *仅适用于浏览器场景，难以支持移动端、小程序等非 Cookie 环境*。
* OAuth1.0 的复杂性：
OAuth1.0 虽支持第三方认证，但签名流程复杂（需要对请求参数逐个签名），实现成本高，且不兼容部分 HTTP 客户端，难以普及。

**3. 跨平台、跨域数据交换的需求**  
随着移动互联网和多端应用（Web、App、小程序、第三方服务）的普及，跨平台数据交换的需求日益迫切：
* 不同平台（如浏览器、iOS 客户端、Android 客户端）的通信方式不同（例如，移动端通常不支持 Cookie），需要一种**通用的身份凭证格式**。
* 第三方服务集成（如用微信登录第三方应用）时，需要一种**安全、轻量**的方式传递用户身份信息，同时确保信息未被篡改。

JWT **基于 JSON 格式**（轻量、易解析，支持多语言）和 **Base64 编码**，**天然适合跨平台场景**；同时，其**内置的签名机制（如 HS256、RS256）能保证数据的完整性和发送方身份的可信性**，满足跨域数据交换的**安全**需求。

## 二、JWT的结构
JWT 由三部分组成，用.分隔，格式为：Header.Payload.Signature，每部分都经过 Base64URL 编码（一种 URL 安全的 Base64 变体）。

**1. Header（头部）**  
声明令牌类型（typ: "JWT"）和签名算法（如HS256、RS256）。经过 Base64URL 编码后成为第一部分
```js
{ 
    "alg": "HS256", 
    "typ": "JWT" 
}
```
**2. Payload（载荷）**
* 作用：存储需要传递的**非敏感信息**（如用户 ID、角色、过期时间），包含三种声明：
* **标准声明**（可选）：exp（过期时间）、iat（签发时间）、sub（主题）等；
* **自定义声明**：如userId: "123"、role: "admin"。
```js 
{ "sub": "123", "name": "Alice", "exp": 1672531200 }
```
经过 Base64URL 编码后成为第二部分

**3.  Signature（签名）**
* 作用：防止令牌被篡改，是 JWT 的安全核心。
* 生成逻辑：
    * 拼接编码后的 Header 和 Payload：**data** = Header编码 + "." + Payload编码；
    * 使用 Header 中声明的算法（如 HS256）和密钥，**对data计算签名**：
        * HS256：signature = HMAC-SHA256(data, 共享密钥)
            > HS256 会将密钥与数据混合后进行 SHA-256 哈希运算，生成固定长度（256 位）的签名。
        * RS256：signature = RSA-SHA256(data, 私钥)
            > RSA 签名会先对data进行 SHA-256 哈希，再用私钥对哈希值加密，生成签名。
    * 对签名进行 Base64URL 编码，成为**第三部分**。


最后，将用Base64URL 编码后的 Header、Payload、 Signature 用 . 连接，得到最终的 JWT

## 三、JWT 的工作流程（以用户登录为例）
1. 客户端请求登录：用户提交账号密码到服务器；
2. 服务器验证并生成 JWT：验证通过后，服务器根据用户信息生成 Header、Payload，结合密钥计算签名，拼接成 JWT 返回给客户端；
3. 客户端存储 JWT：客户端将 JWT 存于localStorage、sessionStorage或cookie中；
4. 后续请求携带 JWT：客户端每次请求时，在 HTTP 头Authorization中携带 JWT（格式：`Bearer <token>`）；
5. 服务器**验证 JWT**：
    * 服务端拆分 JWT 为 Header、Payload、Signature；
    * 用公钥（public key） 对 Signature 进行解密和验证：  
        * 公钥可解密出*原始哈希值*，同时服务器对data重新计算 SHA-256 哈希；
        * 若两个哈希值一致，说明 Token **未被篡改且确实由私钥持有者签发**。再查看过期时间啥的，都验证通过后，可解析 Payload 获取用户信息，处理请求；
        * 若不一致，Token 无效（如令牌篡改、过期）。

## 四、JWT的使用方式
客户端收到服务器返回的 JWT，可以**储存**在 Cookie 里面，也可以储存在 localStorage。
> 避免存储在localStorage/SessionStorage：易被 XSS 窃取，建议用cookie并开启HttpOnly、SameSite、Secure属性（禁止 JS 读取，且仅通过 HTTPS 传输、防御CSRF）；

此后，客户端每次与服务器通信，都要带上这个 JWT。

**使用方式**：
1. 放在 HTTP 请求的头信息Authorization字段里面。
```js
Authorization: Bearer <token>
```
2. 跨域的时候，JWT 就放在 **POST 请求的数据体**里面。
3. 通过 URL 传输
```js
http://www.example.com/user?token=xxx
```

## 五、签名算法选择（默认是HS256）
1. HS256（HMAC-SHA256）：**对称加密**，服务器和客户端共用一个密钥，实现简单，但密钥泄露风险高，适合内部系统；

    > 1. HS256（HMAC-SHA256）是一种基于哈希的消息认证码算法，通过**密钥**和**哈希函数**（SHA256） 结合，实现对数据的完整性校验和身份验证。其核心逻辑是：发送方用密钥对数据生成一个 “签名”，接收方用相同的密钥验证签名，若签名一致则说明数据未被篡改且发送方身份可信。
    > 2. HS256 仅适用于信任度极高的双方（如服务端内部模块通信）

    <br/>
    JWT实现过程若是基于HS256算法的话：服务端生成一个密钥（Secret Key），并确保该密钥**仅在服务端保存**（绝不泄露给客户端，否则签名会被伪造）。  
    <br/>

2. RS256（RSA-SHA256）：**非对称加密**，用**私钥签名、公钥验证**，安全性更高，适合**开放 API（如第三方登录）**。
    > 密钥持有方不同：
    >   * **服务端**：必须持有**私钥**（用于生成 JWT 签名，核心机密，绝不能泄露）；
    >   * **客户端 / 第三方**：可以持有**公钥**（用于验证 JWT 是否由对应私钥签名，公钥可公开）。

    > 流程示例：
    >   1. 服务端用私钥对 data（Header编码 + "." + Payload编码）签名生成 JWT，返回给前端或第三方；
    >   2. 前端若需验证 JWT 合法性（如检查是否被篡改），可使用公钥验证签名；
    >   3. 服务端接收 JWT 时，同样用私钥对应的公钥（或直接用私钥反向验证）确认签名。

### 两种算法比较 
以JWT为例，两种算法比较结果如下，默认使用的是HS256（HMAC-SHA256）
| 算法	| 密钥类型	| 服务端持有 |	客户端 / 第三方可持有| 性能 | 核心用途差异|
|  ----  | ----  |----  | ----  |----  |----  |
| HS256	| 单一共享密钥	|是（唯一持有者）|	否（禁止持有）|计算速度快（对称加密效率高）|	适合服务端内部验证，无第三方参与（如前后端分离系统），HS256 足够且效率更高|
| RS256	| 私钥 + 公钥对	|私钥（必须持有）|	公钥（可公开持有）|	计算速度较慢（非对称加密复杂） | 适合第三方验证场景（（如开放 API、跨服务认证），必须用 RS256（公钥可安全分发给第三方）。|

### 签名的主要作用
* **防篡改**：确保 JWT 在传输过程中未被修改。**任何对 Header 或 Payload 的改动都会导致签名验证失败**。
    * 例如：攻击者试图修改 Payload 中的userId为他人 ID，重新编码后签名会与原始签名不一致，服务器会拒绝该 Token。  
* **验证来源**：证明 Token 确实由持有密钥的合法服务器签发。
    * 对 HS256：只有知道共享密钥的一方才能生成有效的签名；
    * 对 RS256：只有持有私钥的服务器才能生成签名，公钥可安全分发给客户端用于验证。

## 六、JWT 的优势
* **无状态**：服务端无需存储会话信息（对比传统 session 认证），减轻服务器负担，适合分布式系统。
* **跨域支持**：JWT 通过 HTTP 头部传递，天然支持跨域认证（如前后端分离、微服务架构）。
* **自包含**：Payload 可携带用户基本信息，减少服务端查询数据库的次数。
* **紧凑性**：体积小，可通过 URL、POST 参数或 HTTP 头轻松传输。
* **安全性**：可通过签名确保信息不被篡改（对称加密或非对称加密）。


## 七、常见问题
* **Token 无法废除**：JWT 一旦签发无法主动撤销，若用户登出，需客户端删除本地 Token，或服务器维护 “黑名单”（需额外存储，牺牲无状态优势）；
* Payload 过大：JWT 体积过大会增加请求开销，需控制 Payload 信息量。


## 八、安全注意事项
* 敏感信息不存Payload：Payload 仅编码不加密，禁止存放密码、token 等敏感数据。
* 密钥安全：
    * HS256 的共享密钥必须严格保密（仅服务端持有）；
    * RS256 的私钥绝不能泄露，公钥可公开。
* 合理设置过期时间（exp）：exp字段避免令牌长期有效，降低被盗用风险（如：1小时）。
* 防止篡改：签名是 JWT 的核心安全保障，必须使用强算法（如 HS256、RS256，避免 MD5、SHA1）。
* 实现 Token 刷新机制：过期前用旧 Token 换取新 Token（如 “访问 Token + 刷新 Token” 模式）。  TODO:
