# Nginx解决跨域

Nginx 是一款高性能的 Web 服务器和反向代理服务器，广泛用于处理高并发请求和实现负载均衡。


## 一、跨域问题的本质：浏览器的同源策略
跨域问题的根源是浏览器的**同源策略（Same-Origin Policy）**，这是一种安全机制，限制不同源的网页脚本（如 JavaScript）对当前页面资源的访问。

* **同源定义**：两个 URL 的**协议、域名、端口必须完全一致**，否则视为不同源。

例如：
> 客户端页面：http://frontend.com:8080（协议 http，域名 frontend.com，端口 8080）<br/><br/>
> 后端接口：http://api.backend.com:3000（协议相同，但域名不同）→ **跨域**。

* **跨域限制场景**：当客户端脚本（如 AJAX、Fetch）直接请求不同源的后端接口时，浏览器会拦截响应，提示跨域错误（如 Access to fetch at 'xxx' from origin 'xxx' has been blocked by CORS policy）。

## 二、Nginx 解决跨域的核心原理：反向代理中转
Nginx 解决跨域的核心思路是作为 “中间代理”，让客户端与 Nginx 同源，Nginx 再与后端服务器通信（此时浏览器不参与 Nginx 与后端的通信，无同源限制）。具体流程如下：

1. **客户端与 Nginx 同源：**

客户端页面和 Nginx 服务器配置为相同的协议、域名和端口（例如客户端页面 http://example.com，Nginx 也部署在 http://example.com）。*此时客户端请求 Nginx 属于 “同源请求”，浏览器不拦截。*

2. **Nginx 转发请求到后端：**

Nginx 接收到客户端请求后，通过**反向代理（proxy_pass）**将请求转发到实际的后端服务器（可能跨域，如 http://api.backend.com）。由于 Nginx 与后端的通信是服务器之间的 HTTP 通信，不受浏览器同源策略限制，因此可以正常获取响应。

3. **Nginx 返回响应给客户端：**

后端服务器的响应经 Nginx 中转后返回给客户端，*浏览器看到的是来自 “同源” Nginx 的响应，因此不拦截，跨域问题解决。*

**注意：如果不同源的话，浏览器在请求、响应时都会被拦截。**

## 三、Nginx 解决跨域的具体配置方案
Nginx 解决跨域的配置主要通过两方面实现：

1. **反向代理转发**：将客户端对 Nginx 的请求转发到后端服务器。
2. **跨域头配置**：如果需要直接允许跨域（而非代理中转），可通过添加 **CORS 响应头**放行。


**方案 1：反向代理中转（推荐）**

通过代理让客户端与 Nginx 同源，隐藏后端跨域问题。  

示例配置：

```js
// 定义虚拟主机（Virtual Host）的配置单元
server {
    listen 80;
    server_name example.com;  // 客户端页面的域名（与客户端同源）

    # 代理客户端对后端接口的请求
    location /api/ {  # 客户端请求路径：http://example.com/api/xxx
        proxy_pass http://api.backend.com:3000/;  # 转发到后端接口：http://api.backend.com:3000/xxx
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # 静态资源服务（客户端页面）
    location / {
        root /path/to/frontend;  # 客户端页面的静态文件目录
        index index.html;
    }
}
```

**效果：** 客户端通过 http://example.com/api/xxx 访问接口，与 Nginx 同源（example.com），浏览器不拦截；Nginx 转发到后端 api.backend.com，服务器间通信无跨域限制。


**方案 2：直接配置 CORS 响应头（允许跨域）**

如果客户端无法与 Nginx 同源（例如客户端是 http://frontend.com，Nginx 是 http://backend.com），可通过 Nginx 向前端返回 CORS 头，告知浏览器允许跨域。

示例配置：
```js
server {
    listen 80;
    server_name backend.com;  # 后端服务器域名

    # 允许跨域的核心配置
    add_header Access-Control-Allow-Origin http://frontend.com;  # 允许指定源跨域
    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;  # 允许的请求方法
    add_header Access-Control-Allow-Headers Content-Type,Authorization;  # 允许的请求头
    add_header Access-Control-Allow-Credentials true;  # 允许携带Cookie

    # 处理预检请求（OPTIONS）
    if ($request_method = 'OPTIONS') {
        return 204;  # 预检请求直接返回成功
    }

    # 转发到后端服务器
    location / {
        proxy_pass http://backend_server;
    }
}
```
**效果：**  浏览器收到后端响应时，看到 Access-Control-Allow-Origin: http://frontend.com，会允许前端脚本访问响应数据，从而解决跨域。

## 四、Nginx 解决跨域的优势
1. **无前端侵入：** 无需修改前端代码，仅通过服务器配置即可解决，尤其适合前端无法修改的场景。  
2. **隐藏后端细节：** 通过代理路径（如 /api/）隐藏真实后端地址，提高安全性。
3. **灵活性高：** 可针对不同路径、不同源配置不同的跨域规则，支持复杂场景。  
4. **性能优异：** Nginx 作为轻量级服务器，转发效率高，几乎不增加额外性能开销。  

## 五、注意事项
1. **反向代理 vs CORS 头：**    
    * 反向代理更适合生产环境，尤其当后端接口不希望直接暴露给前端时。
    * CORS 头配置更简单，但需明确指定允许的源（避免 * 带来的安全风险）。

2. **预检请求（OPTIONS）：**      
    * 对于非简单请求（如带自定义头、PUT/DELETE 方法），浏览器会先发送 OPTIONS 预检请求，需配置 Nginx 正确响应（如返回 204）。

3. **Cookie 跨域：**  
若需要携带 Cookie 跨域，需同时满足：
    * 前端请求添加 withCredentials: true
    * Nginx 配置 Access-Control-Allow-Credentials true
    * Access-Control-Allow-Origin 不能为 *，必须指定具体域名。

### 总结
Nginx 解决跨域的核心逻辑是通过**反向代理中转请求**，让客户端与 Nginx 同源，从而绕过浏览器的同源策略限制；或通过配置 CORS 响应头明确告知浏览器允许跨域。两种方案各有适用场景，其中反向代理因安全性和灵活性更常用于生产环境。
