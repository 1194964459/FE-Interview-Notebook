# HTTP3 是如何保证可靠性的？
QUIC 的可靠性是**以“确认-重传”为核心，流量控制、拥塞控制为保障，连接迁移、帧结构、加密为补充** 的全方位设计：

* “数据包 ACK + 精准重传” 解决 UDP 丢包问题，避免冗余重传；以“选择新确认”为主（256个ACK块）！
* “流量控制” 避免*接收端溢出*，
* “拥塞控制” 避免*网络拥塞导致批量丢包*；
* “连接迁移” *保障网络切换时的连续性*，
* “帧结构” 保障*数据有序，不重复，没损坏(校验和)*；
* “内置 TLS1.3 加密” 防止数据被篡改、伪造 

所有机制共同作用，实现了比 TCP 更适配现代网络（多流、移动切换）的可靠传输。

## 一、可靠性保障的六大措施：
1. **基于包号的精准重传**（与 ACK 联动，避免 TCP 的 “冗余重传”）

    * QUIC 的重传机制与 “数据包确认” 深度绑定， “按包号精准重传丢失的包”即可。
    * TCP是重传 “丢失字节之后的所有后续字节”（即使后续字节已成功到达）。

2. **流级+连接级 双层流量控制**（防止接收端 “被淹没”）   
    * 流量控制的核心目标是：避免发送太快，导致接收端缓存溢出 从而丢弃数据。
    * TCP 仅支持 “连接级” 流量控制！

3. 灵活且鲁棒的拥塞控制（避免 “网络拥塞导致的批量丢包”）
    * **与 ACK机制 协同**：QUIC 的 ACK 帧会携带 “**往返时间（RTT）**”“**丢包率**” 等网络状态信息，拥塞控制模块基于这些实时数据动态调整发送窗口（如 RTT 增大时减小窗口，避免拥塞加剧）；  
    * 更快的拥塞响应：**因 QUIC 按包确认，丢包检测更精准、延迟更低**，拥塞控制模块能更快感知网络状态变化（如快速发现丢包并降低发送速率），减少 “拥塞扩散” 的风险。

4. 连接迁移（避免 “网络切换导致的连接中断”）
    * TCP 连接的标识是 “源 IP + 源端口 + 目的 IP + 目的端口”（四元组），若设备切换网络（如从 Wi-Fi 切到 5G），IP 或端口会变化，导致 TCP 连接中断，需重新握手建立连接，之前传输的数据可能丢失。
    * QUIC 则通过 “连接 ID（Connection ID）” 替代四元组标识连接，从根本上解决了“网络切换导致的连接中断”问题，确保传输过程的连续性。

5. 帧结构与数据有序性保障（解决 “乱序、重复、数据损坏”）  
QUIC 并非直接传输原始数据，而是将数据拆分为“帧（Frame）”进行传输（类似TCP的段，但更灵活），不同类型的帧承担不同职责：
    * 数据帧：携带实际数据，每个数据帧会关联 “流 ID” 和 “偏移量（Offset）”（标记该帧数据在流中的位置）；
        * 即使数据帧因网络乱序到达，接收端也能通过 “流 ID + 偏移量” 将数据还原到正确的流和位置，保证 “流内数据有序”
    * 重置帧(RESET_STREAM)：若某流发生错误（如请求被取消），发送端可发送该帧终止流，避免无效数据传输；
    * ping帧：检测连接活性，若连接失效，及时释放资源或重连。

    此外，QUIC 对**每个帧都有校验和(Checksum)**，接收端若检测到校验和不匹配，会直接丢弃该帧并通过 ACK 标记为丢失，触发重传，这**解决了 “数据损坏” 的问题**。

6. 内置加密与完整性校验（防止 “数据篡改、伪造”）  
    * 可靠性不仅包括 “数据能到达”，还包括 “数据未被篡改”。  
    * QUIC从设计之初就 内置TLS加密（HTTP/3 强制要求加密），所有传输的数据（包括 QUIC 头部的部分字段、帧数据）都经过加密和完整性校验：
 
## 二、TCP 或 QUIC 传输时包丢失了，重传的是什么？
### 1. TCP 重传的是？
TCP是“字节流协议”，**若某段丢失，需重传 “丢失字节之后的所有后续字节”**（即使后续字节已成功到达）--- 基于TCP默认的累计确认。
> “段”是封装字节的载体。
> 不过若支持“SACK”的话，仅重传丢失的块即可；但是TCP的 SACK 仅支持3~4个块，且有兼容性问题。

举个具体例子：
假设发送方要传 1000 字节的数据流，按 MSS（最大段大小）拆成 3 个 TCP 段：
* 段1：字节 0-399（序号 = 0，确认号 = 0）
* 段2：字节 400-799（序号 = 400，确认号 = 0）
* 段3：字节 800-999（序号 = 800，确认号 = 0）

**情况 1：段2（400-799）丢失**  
接收方收到段1（0-399）后，会回复确认号 = 400（意思是 “我已经收到了 0-399 字节，下一步要 400 开始的字节”）；   
但接收方没收到段2，*后续收到段3*（800-999）时，发现字节流 “断了”（400-799 缺失），此时*不会确认段3*，仍会重复回复 “确认号 = 400”。

此时发送方的重传逻辑是：
 
* 发送方通过 “**确认号 = 400**” 判断：“**字节 400 及之后的内容，接收方都没确认**”不管是段2 丢了，还是段3 丢了，逻辑上都是 “400 开始的字节流不连续”）。   
* 因此，**发送方会 从字节 400 开始，把后续所有 “已发送但未确认的字节” 重新封装成段重传**—— 也就是重传 “400-999 字节”（可能封装成 1 个段，也可能拆成多个段，但核心是 “从缺失点开始的所有未确认字节”）。
    > 重传的“400-999 字节”：原始段2、段3的所有字节，尽管段3之前已经成功到达！  
    > 只要前面的字节流断了，后续段也会被一起重传（因为接收方**不确认，发送方认为它们“未被成功接收”**, 只有被确认过的才可信）。

### 2. QUIC 重传的是？
**QUIC 基于“包号” 定位丢失数据，仅重传 “丢失的包”即可**。具体怎么实现：

**丢包检测逻辑**：
接收端通过 ACK帧 明确标记 “已接收的包号范围” 和“缺失的包号”（例如 ACK 帧中会包含 “最大已接收包号”、“缺失包号列表”）。发送端结合**超时重传(RTO)** 和 **快速重传(Fast Retransmit)** 两种方式检测丢包：
* 超时重传：若某包超过 RTO 时间未收到 ACK，直接重传该包；
* 快速重传：若收到 3 个以上 “包含相同缺失包号” 的 ACK（类似 TCP 的快速重传触发条件），无需等待 RTO，立即重传该丢失包。

继续用上面的例子，同样传 1000 字节，拆成 3 个 QUIC 包：
* 包1：字节 0-399（包号 = 1）
* 包2：字节 400-799（包号 = 2）
* 包3：字节 800-999（包号 = 3）

**情况 1：包2 丢失**  
接收方收到 包1(包号1) 和 包3(包号3) 后，会回复一个确认帧（ACK Frame），**明确告知：“包1、3 已收到，包2 丢失”（QUIC 支持 “选择性确认”，直接定位丢失的包号）**。

此时 QUIC 的重传逻辑是：  
* 发送方通过 ACK 帧明确知道 “只有包2 丢了”，因此只重传 “包2” 这一个数据包，*不会涉及包3（因为包3 已被确认，无需重传）*。

```
ACK 帧内容：
- 确认包：100, 102, 103
- 丢失包：101（流 A 的 Offset 0~511）
```