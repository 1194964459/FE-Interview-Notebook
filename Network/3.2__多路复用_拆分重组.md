# HTTP2 帧拆分后 重组：流内有序（收到的数据），流间乱序（传输时）

1. 发送端：
    * 应用层发送数据：应用层数据 → 拆分成带流ID的帧 → 转成字节流 → 交给TCP传输
    * 传输层：传输字节流...

2. 接收端：
    * TCP：保证按照发送的顺序 按序到达，不丢包、不重复，提供可靠传输服务...
    * 应用层：TCP 接收字节流 → 解析字节流还原帧 → 按流 ID 分类帧 → 重组为 HTTP 消息

**解析帧的前提**：
    * 先传“头部帧"，再传”数据帧“，
    * 且每个帧是有固定格式的：由枕头、帧体两部分组成，且帧头、帧体都是有结束标志的，帧头有固定长度 9个字节。

**解析过程**：首先”从字节序列中切割出枕头“，读枕头，从中解析出枕头中的重要参数”流ID“、“帧总长度”； 然后”从字节序列中切割出枕体“，解析帧体中的数据。


## 一、HTTP2应用层、TCP层数据形态 衔接
HTTP/2 的核心创新是二进制分帧层：它会先把 HTTP 消息（比如一个请求的 “头部+数据”）拆分成一个个结构化的二进制帧，再将这些帧的 “二进制字节” 交给 TCP 传输。

TCP 是面向字节流的协议，它只负责将应用层传递的 “字节序列” 按序传输到对端，完全不关心字节的 “业务含义”（比如哪部分是请求头、哪部分是图片数据）。

简单说：
* 发送方流程：HTTP 消息 → 拆分为带流 ID 的帧 → 帧转字节流 → 交给 TCP 传输
* 接收方流程：TCP 接收字节流 → 解析字节流还原帧 → 按流 ID 分类帧 → 重组为 HTTP 消息

## 二、HTTP/2 帧的结构化格式 —— 字节流的 “切割依据”
**接收方要从 TCP 无结构的字节流中拆分出独立的帧，靠的是 HTTP/2 帧的固定格式**。每个 HTTP/2 帧都由 “帧头” 和 “帧体” 两部分组成，帧头的结构是完全固定的（共 9 字节），这成为接收方 “切割字节流” 的关键标识。
HTTP/2 帧头结构（9 字节，核心是 “长度” 和 “流 ID”）

| 字段	| 字节数| 	作用| 
| ---- |  ---- |  ---- | 
| **长度**	| 3	| 表示 “帧体” 的字节数（最大 16384 字节），告诉接收方 “这一帧要读多少字节”| 
| 类型	| 1| 	表示帧的用途（如 0x01 是头部帧、0x00 是数据帧）| 
| 标志位| 	1| 	辅助控制（如 END_HEADERS 表示这是最后一个头部帧）| 
| **流 ID** | 	4| 	唯一标识该帧属于哪个 “流”（0 号流是控制流，不承载业务数据）| 


**接收方如何 “从字节流中拆出帧”？**
接收方会按以下逻辑 “逐字节解析” TCP 传来的字节流，**本质是通过帧头的 “长度” 字段确定帧的边界**：

* **读帧头（前 9 字节）**：从字节流中先读取前 9 字节，解析出 “长度 L”（帧体字节数）和 “流 ID”（该帧所属的流）；
* **读帧体（接下来 L 字节）**：根据解析出的 “长度 L”，从字节流中读取接下来的 L 字节，作为该帧的 “帧体”（承载实际数据，如请求头字段、图片字节）；
* **循环重复**：读完当前帧的 “帧头 + 帧体” 后，继续从剩余字节流中读下一个帧的 9 字节帧头，重复步骤 1-2，直到字节流被完全解析。

举个例子：假设 TCP 传来的字节流是 [帧1头(9B) + 帧1体(100B) + 帧2头(9B) + 帧2体(200B)]，接收方会：

* 先读 9B 得帧 1 的 “长度 = 100” 和 “流 ID=1”，再读 100B 得帧 1 体；
* 再读 9B 得帧 2 的 “长度 = 200” 和 “流 ID=2”，再读 200B 得帧 2 体。


## 三、核心：按流 ID 拆分与重组 —— 多流的 “分类与排序”
当接收方通过上述步骤拆出一个个独立的帧后，下一步就是按 “流 ID” 对帧进行分类，并在每个流内部完成 “有序重组”，最终还原成完整的 HTTP 消息。这一步分为两个关键动作：


1. 按流 ID 拆分：给帧 “分组”   
接收方会为**每个活跃的流**（即正在传输数据的流，比如 “请求 HTML 的流”“请求图片的流”）**维护一个独立的 “流缓冲区”**（或叫 “重组队列”）。   

    * 每当解析出一个帧，就根据帧头的 “流 ID”，将该帧放入对应流的缓冲区中；   
    * 不同流的帧会被严格分开：比如流 ID=1 的帧全放进 “流 1 缓冲区”，流 ID=3 的帧全放进 “流 3 缓冲区”，绝不会混淆。  

举个实际场景：浏览器同时请求 ```“首页 HTML”（流 1）```和 ```“首页图标”（流 2）```，发送方交错传输的帧序列是：
```帧1-1（流1，头部帧）→ 帧2-1（流2，头部帧）→ 帧1-2（流1，数据帧1）→ 帧2-2（流2，数据帧1）→ 帧1-3（流1，数据帧2）``` （这就是“**流间乱序**”传输）

接收方解析后，会将这些帧分组到两个缓冲区：

* 流 1 缓冲区：帧1-1 → 帧1-2 → 帧1-3
* 流 2 缓冲区：帧2-1 → 帧2-2

2. 流内有序重组：按 “帧的逻辑顺序” 还原 HTTP 消息   
HTTP/2 要求 **“流内有序”：同一流的帧必须按发送方的顺序重组，否则会导致数据错乱**（比如先传数据帧、再传头部帧，接收方就无法识别数据含义）。


    这种 “流内有序” 之所以能实现，依赖两个层面的保障：  
    * **底层 TCP 的字节流有序性**：TCP 会保证发送方传递的字节流 “按序到达”（比如发送时帧 1-1 在帧 1-2 之前，TCP 绝不会让帧 1-2 的字节先于帧 1-1 到达）。因此，接收方解析出的同一流的帧，顺序与发送方完全一致；
    * **HTTP/2 帧的 “完整性标识”**：帧头的 “标志位” 会告诉接收方 “是否是当前流的最后一帧”。比如：
        * 头部帧的 END_HEADERS 标志：表示这是该流的*最后一个头部帧，后续不会再有头部帧*；
        * 数据帧的 END_STREAM 标志：表示这是该流的*最后一个数据帧，该流的传输已结束*。

    接收方的重组逻辑：  
    * 对每个流的缓冲区，**按 “帧的接收顺序”（即发送顺序）排列**；
    * **等待该流的 “所有关键帧” 到齐**（比如头部帧 + 所有数据帧，且收到 END_STREAM 标志）；
    * 将该流的所有帧**按顺序拼接**：先拼接头部帧的内容（还原 HTTP 头），再拼接数据帧的内容（还原 HTTP 体）；
    * 最终将拼接后的 “完整 HTTP 消息” 交给应用层（比如浏览器渲染 HTML、显示图片）。


接收到的每个流：流内都是有序的；上面的整个过程实现了“**流内有序、流间乱序**”。


## HTTP3 基于udp的，是怎么实现 接收到的数据 “流内有序”的？

每个流在创建时会分配唯一的流 ID（Stream ID），而流内的每个数据包则通过**偏移量（Offset） 标识其在数据流中的位置**。

QUIC 的每个流 都有完全独立的序列号（Offset），类似与TCP的全局序列号，通过 offset和流ID 来实现流内有序。

