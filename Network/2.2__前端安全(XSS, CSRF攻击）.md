# 前端安全

参考：

CSRF攻击：
* https://blog.csdn.net/stpeace/article/details/53512283

XSS攻击：
* https://zhuanlan.zhihu.com/p/26177815
* https://www.cnblogs.com/tugenhua0707/p/10909284.html
* https://www.freebuf.com/articles/web/185654.html

## 一、XSS 攻击
**XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击**。XSS的重点不在于跨站点，而在于脚本的执行。

**XSS的原理是：** 恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。

**XSS 可以做的事：**
* 窃取网页浏览中的cookie值
* 劫持流量实现恶意跳转

### 实施 XSS 攻击的各种手段（利用与绕过）：
* 大小写 绕过：只过滤了<script></script>标签，而没有考虑标签中的大小 (如：<sCript></scRipt>) 写并不影响浏览器的解释所致。
```js
http://192.168.1.102/xss/example2.php?name=<sCript>alert("hey!")</scRipt>
```

* 利用过滤后返回语句 再次构成攻击语句 来绕过
```JS
// 过滤掉<script标签后，该标签前后字符串刚好又组成一个script标签>
http://192.168.1.102/xss/example3.php?name=<sCri<script>pt>alert("hey!")</scRi</script>pt>
```

* 并不是只有script标签才可以插入代码
```JS
// 我们指定的图片地址根本不存在，这时候onerror里面的代码自然就得到了执行。
http://192.168.1.102/xss/example4.php?name=<img src='w.123' onerror='alert("hey!")'>
```

```html
<!-- 类似的还有onclick、onmouseover 方法 -->
<a onmousemove='do something here'> 
```

* 编码脚本绕过关键字过滤
有时候，服务器往往会对代码中的关键字（如alert）进行过滤，这个时候我们可以尝试将关键字进行编码后再插入，不过直接显示编码是不能被浏览器执行的，我们可以用另一个语句eval（）来实现。eval()会将编码过的语句解码后再执行，简直太贴心了。
```JS
// alert(1) 编码后的内容为：\u0061\u006c\u0065\u0072\u0074(1)

http://192.168.1.102/xss/example5.php?name=<script>eval(\u0061\u006c\u0065\u0072\u0074(1))</script>
```

* 主动闭合标签实现注入代码
手动闭合掉两个双引号来实现攻击。
```JS
http://192.168.1.102/xss/example6.php?name=";alert("I am coming again~");" 
```

* 组合各种方式
实际运用中漏洞的利用可能不会这么直观，需要我们不断的尝试，甚至组合各种绕过方式来达到目的。

### XSS攻击分类：
一类是反射型XSS，又称 非持久型XSS，
一类是储存型XSS，也就是持久型XSS。

**反射型XSS：** 
* 上面讲XSS的利用手段时所举的例子都是非持久型XSS（相对于访问者而言是一次性的）。
* 具体表现在我们把恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。也就是说想要触发漏洞，需要访问特定的链接才能够实现。

**储存型XSS：**
* 它与反射型XSS最大的不同 就是**服务器再接收到我们的恶意脚本时会将其做一些处理。**
* 如：服务器会把恶意脚本储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着**只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。**
* 存储型 XSS 样例： 留言板。当有人在留言内容中插入恶意脚本时，由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪。
* 存储型XSS 一般只要用户访问这个界面就行了，不像反射型XSS，需要访问特定的URL。

### 防御 XSS攻击
* 过滤：对诸如<script>、<img>、<a>等标签进行过滤。
* 编码：像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
* 限制：xss攻击要能达成 往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。


## 二、CSRF 攻击

CSRF（Cross-site request forgery）即 跨站请求伪造。

攻击者盗用了你的身份，以你的名义发送恶意请求，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。

Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。CSRF攻击攻击原理及过程如下：

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 

### CSRF 漏洞检测：
检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。

### 防御 CSRF 攻击：
目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

**1. 验证 HTTP Referer 字段**
根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。

假如黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站；而用户正常转帐请求的 Referer 值就会是转账按钮所在的页面的 URL。因此，可以利用这一点，如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

**优点：**
* 简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。

**缺点：**
* 不安全。使用验证 Referer 值的方法，就是**把安全性都依赖于第三方（即浏览器）来保障**，从理论上来讲，这样并不安全。
* **Referer 值可篡改**。对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。
* 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。**用户担心侵犯到他们的隐私权，将浏览器设置为在发送请求时不再提供 Referer。**
<br/>

**2.在请求地址中添加 token 并验证**
**CSRF 攻击之所以能够成功，是因为黑客可以完全 伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie中**，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。**要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token**，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

**优点：**
* 安全性比 Referer检查 高。

**缺点：**
* 该方法的难点在于如何把 token 以参数的形式加入请求。
```JS
// 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成http://url?csrftoken=tokenvalue。 

// 对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了。
```
     
每一个请求都加上 token 是很麻烦的，并且很容易漏掉（解决：一般是在每次页面加载时，使用 js 遍历整个 dom 树， 对所有的 a 和 form 标签后加入 token）；另外，对于页面加载之后动态生成的 html 代码，这种方法就没有作用（解决：需要程序员在编码时手动添加 token。）。

<br/>

**3. 在 HTTP 头中自定义属性并验证**
这种方法也是使用 token 并进行验证，但它并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。

**优点：**
* 解决了上种方法在请求中加入 token 的不便。
* 通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，不用担心 token 会透过 Referer 泄露到其他网站中去。

**缺点：**
* 通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。
* 基于这种方法进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，代价很大。