# HTTP 3.0

UDP（User Datagram Protocol）：用户数据报协议！   
QUIC（Quick UDP Internet Connections）：快速 UDP 互联网连接

HTTP/3 是 HTTP 协议的最新版本，它建立在 QUIC 协议之上，旨在解决 HTTP/2 中 TCP 相关的性能问题，进一步提升网络传输效率和用户体验。

[http3.0是基于UDP的，那它是怎样保证可靠传输的？](./3.1__http3可靠性保证.md)

## 一、核心特点：
> 头部压缩升级、更简单的帧结构(仅类型、长度)、支持连接迁移、  
> 基于UDP的 QUIC协议，集成了TLS 1.3（加密、身份认证、完整性），连接建立速度更快(0~1个 RTT)  
> 支持多路复用、丢包的话仅重传被丢的包即可（选择性确认），彻底解决了TCP层的对头阻塞  


* **基于 UDP 的 QUIC 协议，连接建立速度更快**：  
传统的 HTTP 协议基于传输层 TCP，而 HTTP/3 基于 UDP。**UDP 本身没有连接的概念，基于 UDP 的 QUIC 协议在连接建立时只需要一次交互**，相比 TCP 三次握手 & TLS 握手，大大减少了握手时间。
    * TCP的3次握手(1个RTT)、TLS 1.2握手（2个RTT）、TLS 1.3版本（1个RTT）   
    * **HTTP/2** 需要 TCP 三次握手 & TLS 握手（HTTPS 场景），通常需要 **2-3 个 RTT**（往返时间）。  
    * **HTTP/3** 将 **TLS 握手与连接建立合并**，**首次连接仅需 1 个 RTT**，若复用历史会话 仅**0个RTT**

* **多路复用与丢包处理**：
    * HTTP/1.1：**一次请求一次连接**，虽可通过 *keep-alive 实现持久连接*，但本质上还是*基于单个连接顺序处理请求*。   
    * HTTP/2：虽然是多路复用，但由于基于 TCP，当某一帧数据丢失时，会导致整个 TCP连接上后续数据的传输阻塞。
    * HTTP/3：**仅重传丢包的流，其他流不受影响，彻底解决了 TCP 中的队头阻塞问题**，在高丢包率网络环境下优势明显。http3是基于“选择性确认”的。

* **更简单的帧结构**：  
HTTP/3 的帧结构更为简单，只标注类型和长度等关键信息，处理起来更加迅速，协议也更轻量。

* **强化加密与安全**： 
    * 基于 QUIC 协议，内置加密功能并与 TLS1.3 结合，提供了更安全的传输环境。
    * http2中，TLS并非强制，存在明文传输的可能性。TLS 1.2、TLS 1.3 可任选。

* **头部压缩升级**：   
    * HTTP/1.1：头部信息*无压缩*，每次请求都需重复发送大量相同的头部数据，浪费带宽。   
    * HTTP/2：使用 **HPACK 算法对头部进行压缩**，减少了头部数据量，提高了传输效率。   
    * HTTP/3：使用 **QPACK 算法**，在*多路并发场景下头部压缩效果更好*，进一步降低了头部开销。

* **更精细的流量控制与流管理**：  
    * QUIC是原生支持流的，每个流拥有独立的序列号空间（即：流内的Offset）、流量控制、确认和重传逻辑，流与流之间相互隔离。这意味着某个流中的数据包丢失，只会阻塞该流，其他流不会受到影响，从而消除了队头阻塞问题

    * 双层流量控制：
        * 流级别：限制单个流的最大发送字节，避免单个大文件传输阻塞其他流。
        * 连接级别：限制整个QUIC连接的总字节数

    * 智能拥塞控制：用户态可定制，灵活性高（TCP的拥塞控制是依赖TCP内核实现的，灵活性低）

* **支持连接迁移**：
    * HTTP/2 基于TCP连接，TCP连接是通过四元组（源IP、源端口、目的IP、目的端口）来确定的，若**客户端 IP 或端口变化**，如从 Wi-Fi 切换到 4G，需要重新建立 TCP连接，这期间会导致数据传输中断，导致丢包。
    * HTTP/3 使用**连接 ID 标识连接**，即使网络切换导致 IP 地址变化，*只要连接 ID 不变，就可以继续使用原连接，无需重新建立连接，从而保证了数据传输的连续性*，更好地应对了丢包场，适合移动场景！

## 二、Http3的 QUIC 协议
HTTP/3 基于 UDP 的 QUIC 协议，确实结合了 UDP 的低延迟和 TCP 的可靠性优势：

* **基于 UDP 实现低延迟**：
    * UDP 是无连接协议，无需像 TCP 那样通过三次握手建立连接，QUIC 将 TLS 握手与连接建立合并，*首次连接仅需 1 个 RTT，重复连接可复用密钥实现0个RTT*。
    * UDP 没有复杂的确认、重传等机制，数据传输延迟较低。QUIC 运行在 UDP 之上，继承了 UDP 的这一特性。

* **借鉴 TCP 实现可靠性**：
    * UDP 本身不保证数据的可靠性，而 TCP 通过序号、确认、重传、流量控制和拥塞控制等机制，确保数据能无差错、有序地传输。
    * QUIC 在 UDP 的基础上，实质上**重新实现了几乎所有使 TCP 成为可靠协议的特性**。例如，QUIC 会对数据包进行编号，接收方可以根据编号排序，对于丢失的数据包，发送方会进行重传，以此来保证数据的可靠性。

    > 流量控制（流级别和连接级别）：  
    > 面向字节（流内偏移或总字节数），目的是防止接收方缓冲区溢出（告诉发送方 “接收方能处理多少字节”）。
    > 
    > **拥塞控制（连接级的，全局共享一套拥塞参数）**：   
    > 主要基于数据包进行操作。QUIC 根据数据包的发送、确认以及丢失情况，动态调整拥塞窗口大小，控制数据包的发送速率。

    > 疑问❓：既然拥塞控制是全局的，那某个流丢包后，岂不是所有流的速率都会受影响？这是否和 HTTP/3 “流独立” 的优势矛盾？
    > 
    > 其实不矛盾！QUIC 在 “全局共享拥塞控制” 的基础上，通过 **“流调度优先级” 和 “重传隔离”** 实现了 “丢包不阻塞其他流”。当某个流（如流 A）丢包时：   
    > * QUIC 会判定 “链路可能拥堵”，触发全局拥塞控制调整（如减小 cwnd）—— 此时所有流的 “总发送额度” 会减少，但QUIC 会优先调度 “未丢包流”（如流 B、C）的正常数据，而将 “流 A 的重传数据” 放到次要优先级。
    > * 结果是：流B、C仍能在 “缩小后的cwnd 内” 正常发送数据（只是总速率可能略有下降），不会像 HTTP/2那样，因TCP重传 阻塞整个连接的所有数据。

* **其他优势**：
    * QUIC 还实现了类似 TCP 的**流量控制功能**，避免发送方发送数据过快导致接收方缓冲区溢出。
    * QUIC 给**每一个数据流都分配了一个独立的滑动窗口**，使得一个连接上的多个数据流之间没有依赖关系，解决了 TCP 层的队头阻塞问题，进一步提升了传输效率和可靠性。


TCP 存在**队头阻塞、连接建立延迟较高**等问题，HTTP/3 选择基于 UDP 的 QUIC 协议，以解决 TCP 存在的问题。

## 三、QUIC 协议中的 “流（Stream）” 
流是 QUIC 协议中*应用程序与对端*进行**可靠数据交换**的主要机制，它提供了一个*轻量级的、有序的字节流抽象*。

在同一个连接内，流 ID 是唯一的。
通过 “流 ID + 偏移量” 即可准确定位字节所属的流和位置

流内偏移量：精确控制数据顺序。用于表示数据在流中的 字节位置(类似 TCP 的序列号)，但仅作用于单个流。  
> 作用：方便乱序重组，即使数据包乱序到达，接收方也能根据偏移量将数据按顺序组装。例如：  
```
流 A 发送数据块：偏移 0-1023 → 偏移 2048-3071（中间块丢失）
接收方缓存偏移 2048-3071，待丢失块重传后按序交付
```

> 流为什么是轻量级的？(注意：轻量级并不是数据量小)  
> * 资源共享：多流复用一个 QUIC 连接，共享底层**重量级资源**（拥塞控制、TLS 上下文），避免重复开销；  
> * 创建/销毁高效：无需额外握手，仅通过流 ID 和帧标志位即可完成，延迟低；  
> * 状态管理精简：仅维护流 ID、序号、窗口等核心字段，无复杂逻辑；  
> * 场景适配灵活：对数据量无限制，一套逻辑适配所有传输需求，协议复杂度低。  
 
### 流的类型：
根据**发起方**和**数据方向**的不同，QUIC 支持四种基本流类型，分别是
* “客户端发起”的“单向流”
* 服务器发起的单向流
* 客户端发起的双向流
* 服务器发起的双向流

### 流的特性
* **有序性**：**在同一个流内，数据是有序传输的**。**QUIC 协议层会保障数据的有序性**，应用层不需要考虑数据的乱序问题，*接收端会缓存乱序的数据，直到按序号重组后再交给上层应用*。
* **独立性**：**每个流拥有独立的序列号空间（即：流内的Offset）、确认和重传逻辑，流与流之间相互隔离**。这意味着*某个流中的数据包丢失，只会阻塞该流，其他流不会受到影响*，从而消除了队头阻塞问题。
    > QUIC 为每个流提供独立的流量控制、确认机制：
* **可扩展性**：指流在数量、规模（单个流的数据量）、功能适配等方面的灵活扩展能力，能够适应不同场景下的多样化需求（如高并发请求、大小数据混合传输、优先级区分等）
    > **数量**上支持大规模并发，适配高并发场景；   
    > **规模**上：单个流的数据量是动态可调的，与网络状况、接收方接受能力有关，支持从 “极小数据” 到 “超大文件” 的全场景传输。  
    > **功能**可扩展：如单向/双向流、给流设置优先级、每个流的滑动窗口/重传策略可独立控制  

### 流的优缺点：
优点：
* **提升传输效率**：流的独立性和多路复用特性，使得QUIC 能够在一个连接上同时传输多个数据流，避免了队头阻塞，提高了数据传输的并行度和整体吞吐量，尤其在弱网环境下表现更为突出。
* **灵活的应用适配**：支持多种流类型、灵活的流管理机制，能够适应不同应用场景的需求。

缺点
* **资源消耗增加**：每个流都有独立的状态和资源（如序列号空间、流量控制等），当并发流的数量较多时，可能会导致连接的资源消耗显著增加，对设备的内存和处理能力提出更高要求。
* 优先级管理挑战：但如果流的优先级配置不当，可能会导致*低优先级流长时间得不到传输*机会，出现饥饿现象。同时，*如何在不同流之间进行高效的资源调度和优先级管理*，也是开发者需要解决的问题。


## 四、QUIC 与 TCP 的数据包 是怎么编号的？
QUIC连接、TCP连接上传输的都是一个个的数据包，这些包是怎么编号的呢？（TCP称为“段”比“包”更准确！）

1. QUIC 的数据包序号：独立于数据内容的 “包标识”  
QUIC 为每个发送的数据包分配一个**全局唯一的 64 位序号**，这个序号的作用是**直接标识 “数据包本身”**，而非数据包内的字节内容。  与TCP全局字节序列号有点类似，都是全局唯一的。
    * 例如：发送方发送的第 1 个包序号为 100，第 2 个为 101，第 3 个为 102…… **无论每个包里包含多少字节数据（10 字节或 1000 字节），序号都按 “包” 递增，与数据内容的多少无关**。
    * 即使某个包丢失，后续的包仍会按顺序递增序号（如 100 丢失，101、102 仍正常发送），*接收方可通过序号差即可快速发现丢失的包*（100）。

2. TCP 的字节序号：依赖字节流的 “内容标识”  
TCP 的序号是**基于字节流**的，它**标识的是 “数据包中第一个字节在整个字节流中的位置”，而非数据包本身**。   
    * 例如：发送方发送的第一个包包含字节 1-100，其序号为 1；第二个包包含字节 101-200，序号为 101；第三个包包含字节 201-300，序号为 201…… 序号的递增幅度等于包内的字节数。
    * 这种序号与 “字节内容” 强绑定：如果第一个包（1-100）丢失，即使第二个包（101-200）到达，接收方也无法确认它，因为 TCP 要求按字节顺序确认（必须先确认 1-100，才能确认 101-200）。

**关键区别：“包标识” vs “内容标识”**
| 维度 | QUIC 的64位包序号 | TCP 的字节序号| 
| ---- | ---- | ---- | 
| 标识对象| 	数据包本身（独立的 “包身份 ID”）| 数据包内第一个字节在整个字节流中的位置| 
| 递增规则| 	每发一个包，序号 + 1（固定步长）| 	序号递增幅度 = 包内字节数（可变步长）| 
| 与数据量的关系| 	无关（1 字节的包和 1000 字节的包序号差 1）| 	强相关（1000 字节的包比 1 字节的包序号大 999）| 
| 乱序/丢包处理| 	直接**通过序号差定位丢失的包**（如 100、102 存在，缺 101）|  需通过字节范围推断（按字节确认的），依赖 SACK 扩展才能处理乱序| 

## 五、HTTP/3(QUIC)的确认机制

* **HTTP/3（QUIC）的确认机制**：   
是对 TCP 的彻底革新，**以原生选择性确认为核心，支持大量 ACK 块**，实现了**更精准的丢包定位、独立的流确认和高效的重传策略**，从根本上解决了 TCP 确认机制在多路复用场景下的 “队头阻塞” 问题。
    > HTTP3 基于“选择性确认”会分别对数据报、流内的数据进行确认:  
    > * 若某个包丢了，只重传丢的包即可；
    > * 流内基于offset来定位缺失的字节范围。每个流都有完全独立的序列号（Offset）
* **HTTP/2 的确认**：   
依赖 TCP 的累计确认（默认行为），虽通过 SACK 扩展增强了灵活性，但受限于底层协议设计，难以突破固有的局限性。TCP中的确认机制如下：   
    * **累积确认**：接收方*仅确认* “**已收到的最后一个连续字节序号**”，*适用于有序传输场景，无法处理乱序或部分丢失的情况*（可能导致不必要的重传）。
    * **SACK 选择性确认（Selective Acknowledgment）**：允许接收方在 TCP 选项中标记 “**已收到的非连续字节块**”，帮助发送方**定位丢失的“中间数据”**。但 **SACK 受限于TCP头部选项的长度（最多携带3-4个块）**，且需要双方在三次握手时协商启用，*并非所有设备都支持（存在中间设备兼容性问题）*。
        > ```SACK = [200 - 300, 500 - 600]```，就表示字节序号 200 到 300 以及 500 到 600 的数据已经被接收。  再配合 ACK 一起回复。


> HTTP/2 的确认机制的缺点：(无法精准判断...，无法处理...)
> * 发送方**无法精准判断**丢失数据：
> 若**确认号停留在 N**，发送方只知道 “N 及以后的数据未被确认”，但*无法确定是 N 之后的所有数据丢失，还是部分丢失*（如 N+100 丢失，但 N+200 已到达）。*此时发送方可能重传 N 之后的所有数据，造成冗余传输*。
> * **无法处理**乱序和部分丢失：  
> 只有累计确认过的连续字节数据，才会被上层应用处理。累计确认只反馈“最大连续序号”。   

### HTTP/3 与 HTTP/2 两种确认机制对比：

|维度 | HTTP/3（QUIC）|	HTTP/2（TCP） |
| ---- | ---- | ---- | 
| 底层协议|	基于 UDP，确认机制由 QUIC 协议原生实现 <br/>（PS：UDP是没确认啥的，QUIC在UDP协议之上）	| 基于 TCP，依赖 TCP 的确认机制 | 
| 确认方式|	选择性确认（Selective ACK）为主，**支持批量确认多个不连续的数据包** | 以累积确认（Cumulative ACK）为主，选择性确认（SACK）为扩展选项 |
| ACK 块数量|	支持大量 ACK 块（如 256 个），可*高效确认***乱序或缺失的数据包**	| **累积确认仅能确认连续数据**；SACK扩展最多支持3-4个ACK块（受TCP字段长度限制）|
| 重传触发	|*基于选择性 ACK 快速定位丢失的数据包*，**仅重传缺失部分**  | **累积确认可能导致 “队头阻塞”**，SACK 虽能定位丢失包但受限于块数量 | 
| 连接与流隔离	| **每个流（Stream）有自己单独的确认机制、滑动窗口**，某一流的丢包不影响其他流的 ACK机制 | 	**整个 TCP 连接共享一个确认机制**，单一流丢包可能阻塞所有流的确认  | 

HTTP3 的选择性确认对乱序传输的适应性极强，尤其适合多流并发的场景（如 HTTP/3 的多路复用）。

HTTP3 能精准地知道需要重传的数据包，仅仅重传丢失的数据包即可！避免了不必要的等待和大量冗余数据的重传，降低整体的网络延迟。


```
ACK 帧细粒度反馈：支持 256 个确认块，例如：

plaintext
ACK 帧内容：
- 确认包：100, 102, 103
- 丢失包：101（流 A 的 Offset 0~511）
```
发送方仅重传包 101，无需干扰其他包。

```plaintext
QUIC 的 ACK 帧不仅包含已接收的包编号，还能按流报告丢失情况。例如：
ACK 帧可能包含：

ACK Range: [1-99, 101-200]  // 确认包1-99和101-200已接收
Missing Streams: {
  Stream 1: [Offset 100-150]  // 流A的100-150字节未收到
}
```

## 六、HTTP/3的滑动窗口和TCP的滑动窗口有何区别？
| 对比维度 | TCP 滑动窗口| 	HTTP/3（QUIC）滑动窗口| 
| ---- | ---- | ---- | 
| 控制粒度| 全局窗口：整个 TCP 连接共享一个滑动窗口，所有数据（无论属于哪个应用请求）都受此窗口限制		| 双层窗口：<br/>1. 流级别窗口（控制单个流的最大发送字节）<br/>2. 连接级别窗口，是整个QUIC连接的全局窗口（控制全连接总字节）| 
| 滑动依赖| 必须接收“连续且无缺失的字节”	 | 流级别：单流内最大偏移的更新（无论字节是否连续）；<br/> 连接级别：依赖 “全连接已确认的总字节数”（不要求单流连续）| 
| 是否会阻塞窗口滑动？	| 单个字节缺失会阻塞整个窗口滑动（队头阻塞），必须等 “中间缺失的字节” 到达并确认后，窗口才会滑动 | 	单流字节缺失仅阻塞该流的窗口，不影响其他流和连接级窗口（即，流是独立的）| 
| 与多路复用的适配| **不支持多路复用**（单连接内串行），窗口设计时未考虑； <br/><br/> **应用层**通过流、帧等实现了逻辑上的多路复用  | 专为多路复用设计，**两层窗口协调多流并发传输**| 
| 窗口单位  | 全局字节序号（整个连接的字节连续编号）| 	“流”级别：**通过“流内字节偏移”控制单流的有序传输**！ 流内偏移是每个流独立编号的；<br/> ”连接“级别：**通过“全连接总字节数“（所有流字节总和）控制多流的并发总量**！| 

TCP 的单一窗口需做到：
* 限制可发送的总字节数！
* 保证字节的顺序
* 一个 TCP 连接只有一个滑动窗口(发送/接受窗口)，所有数据（无论属于哪个应用请求）都共享这个窗口。
* 窗口滑动的前提是：接收方收到连续且无缺失的字节。即使后面的字节...，也不会滑动
* 乱序或丢包会导致整个连接的窗口阻塞
* TCP 窗口的 “全局顺序依赖” 导致某一流的丢包会阻塞所有流（导致“TCP 层队头阻塞”，HTTP2的应用层没有对头阻塞！）

HTTP3中是两个窗口相互配合使用：
* 流级别窗口：
    * 为每个流单独设置窗口，控制该流的最大发送字节
    * **窗口滑动的前提是：单流内最大偏移的更新（不要求连续）**
        > 不过最终交付给应用层的数据是需要字节连续的。
* 连接级别的窗口：
    * 限制总的字节数，避免超过接收方的缓冲区大小
    * 不要求单流连续，只需 “全连接已确认的总字节数” 增加即可滑动。
* 乱序或丢包仅影响单个流的窗口，不阻塞其他流和全局窗口：
* **QUIC 中每个流都有独立的滑动窗口**，一个连接上的多个流之间相互独立。即使某个流的数据包丢失，只会影响该流的窗口滑动，其他流不受影响，从而避免了队头阻塞，提高了数据传输的并行性和效率。

### 滑动窗口 示例1：
假设场景：同一连接传输 3 个流（A、B、C），每个流需传输 0~299 字节，中间均出现丢包：
| 阶段	 | TCP 滑动窗口表现	 | HTTP/3 滑动窗口表现| 
| ---- | ---- | ---- | 
| 初始状态	 | 窗口允许 1~900 字节（总 300×3=900）| 	流 A/B/C 窗口各允许 0~299，连接窗口允许 0~900| 
| 传输后丢包 | 	A 的 100~199 丢失，B 和 C 完整接收| 	A 的 100~199 丢失，B 和 C 完整接收| 
| 窗口滑动情况	 | 因 A 的 100~199 缺失，全局字节不连续，窗口不滑动 |流 A 窗口不滑动（因缺失）；流 B、C 窗口滑动（允许 300~599）；<br/>连接窗口因 B、C 总确认 600 字节，滑动至 600~1500| 
| 应用层交付情况 | 	A、B、C 的数据均无法交付（需等 A 重传）| 	B、C 的数据正常交付，仅 A 等待重传| 

### 滑动窗口 示例2：
1. QUIC 的流级滑动窗口：（窗口左边界初始为 0，窗口大小足够）：
> * (1) 接收端先收到流内偏移 0~199 的数据包，「最大偏移」更新为 199，窗口左边界滑动到 200；
> * (2) 接着收到流内偏移 400~599 的数据包：   
>   * 虽然中间 200~399 缺失，但*此包的偏移（400）＞当前最大偏移*（199），因此「最大偏移」直接更新为 599；
>   * *窗口左边界随之滑动到 600*（无需等 200~399 确认）；
>   * 400~599 *数据包会被暂存到乱序缓存*，后续等待 200~399 补传即可。
> * (3) 最后收到 200~399 数据包，填补中间缺失，「最大偏移」无变化（仍为 599），窗口不滑动。

→ QUIC 窗口滑动的关键是 “最大偏移是否推进”，中间缺失的乱序包不阻塞窗口，仅需暂存等待补传

2. TCP 滑动窗口示例（窗口左边界初始为 0，窗口大小足够）：  
> * (1) 接收端先收到 0~199 字节，回复 ACK=200（确认已收到 0~199），窗口左边界滑动到 200（窗口变为 200~xxx）；   
> * (2) 接着收到 400~599 字节：由于中间 200~399 缺失，TCP 认为 “字节不连续”，会丢弃或暂存此乱序包，不更新窗口左边界（仍为 200）；  
> * (3) 直到收到 200~399 字节，此时 0~599 字节连续，回复 ACK=600，窗口左边界才滑动到 600。 

→ TCP 窗口滑动的关键是 “中间无缺失的连续字节确认”，乱序包会阻塞窗口滑动。

## 七、TCP 层共享同一个序列号空间、QUIC 的每个流（Stream）都有完全独立的序列号（Stream Offset）
QUIC 的每个流（Stream）都有完全独立的序列号（Stream Offset）， TCP 层共享同一个序列号空间！ 

序列号的核心作用是**确保数据有序性、检测丢包、实现重传**，但 “空间范围” 的设计直接决定了协议处理多流数据的能力。

两种序列号对比：
| 对比维度	| TCP（全局序列号空间）| 	QUIC（流内 Offset 空间）|
| ---- |  ---- |  ---- | 
| 序列号管理范围| 	整个 TCP 连接（所有数据共用一套编号）	| 单个流（每个流单独一套编号，从 0 开始）|
| 序列号唯一性| 	连接内全局唯一	| 流内唯一，流间可重复|
| 数据标识方式	| 仅靠全局序列号（无 “流” 的概念）| 	流 ID + 流内 Offset（双重标识，精准定位）|
| ACK 反馈粒度| 	仅反馈 “全局最大连续序列号”，无法区分流	| 按流 ID 反馈 “各流的已收/丢失 Offset 范围”|
| 丢包影响范围	| 全局阻塞：一个字节丢失，后续所有数据无法交付	| 流内阻塞：仅丢失 Offset 所在的流受影响，其他流正常|
| 重传单位	| 丢失的 TCP 段（可能包含多个流的混合数据）| 	丢失的流内 Offset 范围（仅该流的对应数据）|
| 与多流的兼容性	| 不原生支持多流，导致 HTTP/2 流被捆绑阻塞	| 原生支持多流，流间完全独立|


## 八、http2 与 http3 最小传输单位：
**HTTP2 单位统计**：  
* 应用层的最小数据单位：帧
* 传输层的最小数据单位：TCP段（多个帧可能被封装在一个 TCP 段中，也可能一个帧被拆分成多个 TCP 段）
* 丢失重传的最小单位：TCP段  (“段”是封装字节的载体)。
    * 没有 SACK 机制时，TCP 重传丢失字节及之后的数据；
    * 有 SACK 机制时，TCP 精准重传丢失的字节。
* HTTP2是基于TCP的，TCP是面向字节流的协议！

**HTTP3 单位统计：**  
* 应用层的最小数据单位：帧
* 传输层的最小数据单位：数据包（QUIC 协议将一个或多个帧封装在 UDP 数据包，一个包中可能包含了不同流的不同帧！另外，QUIC中是不可能把帧拆分到不同的包中的）
* 丢失重传的最小单位：帧，仅重传丢失的帧
* QUIC 协议通过包编号（Packet Number）来标识每个包，同时通过流 ID、流内偏移量 Offset 来标识帧在流中的位置。


## 九、http2 与 http3 的握手分别需要几个 RTT ?
* **HTTP/2** 需要 TCP 三次握手加上 TLS 握手（HTTPS 场景），通常需要 **2-3 个 RTT**（往返时间）。
* **HTTP/3** 将 TLS 握手与连接建立合并，**首次连接**仅需 1 个 RTT，**重复连接**可复用密钥实现 0个RTT

> RTT指的发送端发送一个数据包到收到该包对应的 ACK 确认所经历的时间。如果只发送请求 但并没收到该请求的 ACK 并不能算一次 RTT。  
> 
> TCP 的 3 次握手：1 个 RTT。（客户端发送 SYN，服务器 SYN+ACK，客户端 ACK）因为前两次是往返，第三次是客户端发送，服务器收到后连接建立  
> TLS 1.2 的握手：通常需要两次往返，2 个 RTT。  
> TLS 1.3 的握手：1 次往返，1 个 RTT。  

HTTP/2基于TCP协议，RTT次数主要取决于是否通过 TLS 加密传输 以及 TLS 的版本！所以共有三种可能性:
* 非加密场景（极少用，可忽略）：仅需 TCP 三次握手（1 RTT）
* 加密场景（主流）：
    * 3 RTT：TCP 三次握手 + TLS 1.2 握手
    * 2 RTT：TCP 三次握手 + TLS 1.3 握手

HTTP/3 基于 QUIC 协议，而 QUIC 本身是 “传输层 + 加密层” 的融合协议（强制加密），直接将 TCP 握手、TLS 握手和应用层协议协商整合为一个过程，大幅减少往返次数。http 3中使用的TLS版是1.3。
1. 首次连接（1-RTT 握手）：1 RTT
首次连接时，客户端和服务器需协商 QUIC 版本、加密密钥和 HTTP/3 协议，仅需 1 个 RTT：
2. 复用历史会话（0-RTT 握手）：0 RTT
若客户端曾与服务器建立过连接，会缓存会话信息（如加密密钥、QUIC 版本），再次连接时可实现 “0 往返”：
    * 过程：
        * 客户端直接发送 0-RTT 包（携带预共享密钥、加密的 HTTP/3 请求数据）；
        * 服务器验证预共享密钥后，立即处理请求并响应，无需等待额外往返。
此时，**握手 + 首包传输仅需 0 RTT**（客户端发送请求后，无需等待服务器的握手响应即可开始接收数据）。
