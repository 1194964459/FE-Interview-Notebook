# Nginx 基本介绍

Nginx反向代理配置如下：

```js
server {
    listen 80;
    server_name example.com;  # Nginx定义的虚拟主机：反向代理时 该值需与客户端页面的域名（与客户端同源）一致

    # 代理客户端对后端接口的请求
    location /api/ {  # 客户端请求路径：http://example.com/api/xxx
        proxy_pass http://api.backend.com:3000/;  # 转发到后端接口：http://api.backend.com:3000/xxx
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # 静态资源服务（客户端页面）
    location / {
        root /path/to/frontend;  # 客户端页面的静态文件目录
        index index.html;
    }
}
```
## 一、server 块：定义虚拟主机
server 块是 Nginx 中用于配置虚拟主机的基本单元，**每个 server 块对应一个或多个域名**（通过 server_name 定义），负责处理、匹配这些域名的请求。
```js
server {
    listen 80;                 # 监听端口
    server_name example.com;   # 绑定的域名
    # ... 其他配置 ...
}
```
作用：告诉 Nginx“当收到针对 example.com:80 的请求时，用这个 server 块的规则处理”。


### server_name字段的含义
在 Nginx 配置中，server_name 用于**定义当前虚拟主机（server块）对应的域名 / 主机名**。当客户端发送 HTTP 请求到 Nginx 时，*Nginx 会根据请求头中的 Host 字段与配置中的 server_name 进行匹配，从而决定由哪个 server 块处理该请求。*

简单来说，server_name 是 Nginx 识别 “这个请求该由我处理” 的 “身份标识”。

### server_name值有两种可能值：
1. **与前端域名一致：** 用于解决**跨域**问题，又**隐藏了后端服务器的细节**（前端无需知道后端具体地址）。
    >（如前端域名为 frontend.com，Nginx 配置 server_name frontend.com）

2. **与后端域名一致时：**  Nginx ***作为后端的 统一入口**，接收外部对后端的请求，并**通过 upstream 实现负载均衡**。
    > 如后端域名为 api.backend.com，Nginx 配置 server_name api.backend.com）

这两种情况，都是客户端发起请求，然后 Nginx 通过server、host字段判断该请求该由某个server_name处理，然后 Nginx 再将请求转发到后端服务器集群，都是**反向代理**。

```
# 示例：Nginx 配置负载均衡，转发请求到后端服务器集群
upstream backend_servers {
    server 192.168.1.10:8080;  # 后端服务器1
    server 192.168.1.11:8080;  # 后端服务器2
}

server {
    listen 80;
    server_name example.com;

    location /api/ {
        proxy_pass http://backend_servers;  # 转发到后端集群
    }
}
```

## 二、location /：匹配所有路径的请求
location 块用于**定义特定路径的请求处理规则**，而 location / 中的 / 表示 “匹配所有路径”（因为 / 是 URL 的根路径，所有请求路径都以 / 开头）。  
例如：
```js
location / {
    root /var/www/html;        # 静态文件目录
    index index.html;          # 默认首页
}
```
作用：告诉 Nginx“当请求的路径是 /、/about、/api/data 等任意路径时，用这个 location 块的规则处理”。

**location / 优先级低于更具体的 location 规则**，如 location /api。当两个同时命中时，会优先匹配 /api 路径的请求。

### location / 的常用配置场景
**1. 静态网站托管（最常见）** 

用于直接返回静态文件（HTML、CSS、JS、图片等），是搭建静态网站的核心配置。
```js
server {
    listen 80;
    server_name example.com;

    // 1. 前端路由无公共基础路径：
    location / {
        root /var/www/example.com;  # 静态文件存放目录
        index index.html;           # 默认首页文件

        // 尝试访问请求的路径/文件：具体看下面
        try_files $uri $uri/ /index.html;  # 单页应用路由支持（如Vue/React）
    }

    // 2. 若前端路由有基础路径（比如 Vue 配置了 base: '/admin'）
    location /admin/ {  # 注意末尾的斜杠
        try_files $uri $uri/ /admin/index.html;  # 指向 /admin 目录下的 index.html
    }
}
```
访问 example.com 时返回 /var/www/example.com/index.html。

```
try_files $uri $uri/ /index.html;
```
* $uri：指浏览器请求的路径（比如访问 /home，$uri就是`/home`；访问 `/static/js/app.js`，$uri 就是/static/js/app.js）；
* 逻辑：先尝试访问 $uri 对应的文件（如果是静态资源如 JS/CSS，直接返回）；如果找不到，尝试访问 $uri/ 对应的文件夹；如果还找不到，直接返回 /index.html；
* 这样不管访问 /home、/about 还是 /user/123，服务器都会返回 index.html，前端 JS 再根据路径渲染页面，刷新就不会 404 了。


**2. 性能优化**

location / 作为通用规则，若处理大量请求（如静态文件），可添加缓存、压缩等优化：

```js
location / {
    root /var/www/html;
    expires 1d;  # 缓存1天
    gzip on;     # 启用Gzip压缩
}
```

## 三、正向代理、反向代理
正向代理：
* 是客户端的 “代理人”，帮助客户端突破访问限制、提高访问效率等，如：VPN。
* 客户端明确知道自己使用了代理服务器，并且需要进行代理配置才能使用

反向代理：
* 是服务器的 “门面”，隐藏后端服务器的细节，为后端服务器提供**负载均衡、安全防护、解决跨域**等功能。
* 客户端并不知道自己访问的是代理服务器，以为直接访问的是目标服务器。

Nginx在做正向代理、反向代理时，都有转发操作，但二者转发的决策依据不同：
* 正向代理：会根据配置的 DNS 解析规则（resolver指令）获取目标服务器的 IP，然后转发请求。
* 反向代理：依据客户端请求的域名、和请求路径(location指令)等信息，将请求转发到对应的后端服务器。

### add_header（修改响应头） 与 proxy_set_header（修改请求头）
* `add_header：修改响应头的`。当 Nginx 代理后端服务器，把响应返回给客户端时，会用 add_header 在 “响应头” 中添加字段。
```
add_header Access-Control-Allow-Origin http://frontend.com;  # 允许指定源跨域
add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;  # 允许的请求方法
```
* `proxy_set_header：修改请求头的`。把客户端请求转发到后端服务器时，会用 proxy_set_header 指令 添加请求头


### 如何识别正向代理？反向代理？
* 如果 Nginx 配置中有resolver指令指定 DNS 服务器，用于解析目标服务器域名，且proxy_pass使用`$host$request_uri`这种通用转发形式，大概率是正向代理；
* 而如果配置中有**upstream定义后端服务器组**，以及**server_name用于域名匹配**，并且侧重于对**请求路径**进行处理和解决跨域等问题，则基本可以判断是反向代理。

正向代理：（PS：这里没有server_name字段哦）
```
server {
    listen 8888; 
    resolver 8.8.8.8; 
    location / {
        proxy_pass http://$host$request_uri; 

        # 配置请求头信息，让后端服务器能获取客户端的相关信息
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

反向代理：
```
http {
    upstream backend_servers {
        # 定义后端服务器组，这里包含了两个服务器，Nginx会根据负载均衡算法进行请求转发
        server 192.168.1.100:8080; 
        server 192.168.1.101:8080; 
    }
    server {
        listen 80;
        server_name example.com;

        location / {
            # 将请求转发到定义的后端服务器组
            proxy_pass http://backend_servers; 
            # 设置请求头，让后端服务器获取客户端的真实IP等信息
            proxy_set_header Host $host; 
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## 四、特殊字段及其含义
### Nginx 内置变量、自定义变量（$ 开头）
在 Nginx 配置中，以 $ 开头的标识符通常是 **Nginx 的内置变量**，如 `$remote_addr`、`$host`，**内置变量的值是由 Nginx 自动获取**，无法手动赋值。
用户也可以自定义变量，也是以 $ 开头，可手动赋值。如：
```
set $my_var "hello";  # 自定义变量，可赋值
```
常见的内置变量：
* $host：表示请求头中的 Host 字段值  
* $remote_addr：表示**直接与 Nginx 建立连接的客户端 IP 地址**（可能是用户真实 IP，也可能是前一级代理的 IP）。
    * 如果客户端直接访问 Nginx（没有经过其他代理），$remote_addr 就是客户端的真实 IP（如用户电脑的 IP）。
    * 如果客户端通过代理服务器访问 Nginx（比如客户端 → 代理 A → Nginx），$remote_addr 会变成 “代理 A 的 IP”（因为是代理 A 直接与 Nginx 建立连接）。

* $proxy_add_x_forwarded_for：其值为 “**原始 X-Forwarded-For 头 + 客户端 IP（$remote_addr）**”。
    * 如果请求到达 Nginx 时，X-Forwarded-For 头已存在（比如前面有其他代理），则在其后面追加 $remote_addr。
    * 如果请求到达 Nginx 时，X-Forwarded-For 头不存在，则直接将其设置为 $remote_addr。
* $request_uri：完整的请求 URL（包含路径、查询参数、锚点等），如 /api?id=1#top。
* $scheme：请求使用的协议（http 或 https）。
* $server_addr：Nginx 服务器自身的 IP 地址。
* $status：响应状态码（如 200、404）。

### HTTP 协议中的自定义请求头字段，可通过变量动态设置
这些都是添加在http请求头中的，如： 
* X-Real-IP：自定义请求头，用于传递原始客户端 IP
    ```
    proxy_set_header X-Real-IP $remote_addr;
    ```
    将 Nginx 感知到的 $remote_addr 写入 X-Real-IP 头，再转发给后端服务器。

* X-Forwarded-For：用于追踪 HTTP 请求经过的代理服务器链路。
    ```
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    ```
    当 Nginx 作为代理服务器转发请求时，用 $proxy_add_x_forwarded_for 变量的值，更新 X-Forwarded-For 头，再转发给后端服务器。

### 示例：多层代理场景
假设请求链路为：`用户（真实 IP：1.2.3.4）→ 代理 A（IP：10.0.0.1）→ Nginx（代理 B）→ 后端服务器`
1. 用户向代理 A 发送请求，代理 A 会设置 X-Forwarded-For: 1.2.3.4（记录客户端 IP），然后转发给 Nginx。
2. Nginx 接收到请求时：
    * 连接到 Nginx 的客户端是代理 A，所以 $remote_addr = 10.0.0.1。
    * 原始 X-Forwarded-For 头的值是 1.2.3.4（来自代理 A）。
    * $proxy_add_x_forwarded_for 会计算为 1.2.3.4, 10.0.0.1（原始值 + $remote_addr）。
3. Nginx 通过 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 配置，将新的 X-Forwarded-For 头（1.2.3.4, 10.0.0.1）转发给后端服务器。
4. 后端服务器通过读取 X-Forwarded-For，就能知道请求完整的链路：用户真实 IP 是 1.2.3.4，经过了代理 A（10.0.0.1）和 Nginx（当前代理）。

## 五、单层代理、多层代理
在反向代理或负载均衡环境中，客户端请求会先到达代理服务器，再由代理服务器转发给后端服务器。此时，后端服务器的日志中记录的 IP 地址是**代理服务器的 IP**，而非客户端的真实 IP。为了让后端服务器知道客户端的真实 IP，需要通过请求头传递这些信息。

**X-Real-IP：** 
* 记录客户端的真实 IP 地址
    > 注意：多层代理时，该值有可能并不是客户端的IP，而是代理的IP，具体参考下面的“多层代理场景”
* 通常只包含一个 IP 地址。

**X-Forwarded-For (XFF)：** 
* 记录客户端 IP 及请求经过的每个代理服务器的 IP。
* 多个 IP 地址，用逗号分隔，客户端 IP 在最左侧。

### 1. 单层代理场景
```js
客户端(192.0.2.1) → Nginx代理(10.0.0.1) → 后端服务器
```
Nginx配置如下：
```js
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
```

后端服务器收到的请求头：
```js
X-Real-IP: 192.0.2.1
X-Forwarded-For: 192.0.2.1
```

### 2. 多层代理场景
```js
客户端(192.0.2.1) → CDN(203.0.113.1) → Nginx(10.0.0.1) → 后端服务器
```

* CDN添加的请求头：
```js
X-Forwarded-For: 192.0.2.1
```

* Nginx 添加的请求头：
```js
proxy_set_header X-Real-IP $remote_addr;  # CDN的IP: 203.0.113.1
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # 追加当前代理IP
```

* 后端服务器收到的请求头：
```js
X-Real-IP: 203.0.113.1
X-Forwarded-For: 192.0.2.1, 203.0.113.1
```
为什么？
> $remote_addr → 203.0.113.1（CDN 的 IP）<br/>
> $proxy_add_x_forwarded_for 的含义：
“当前收到的 X-Forwarded-For 值” + “, + $remote_addr”。
收到的值是 192.0.2.1，于是：
X-Forwarded-For: 192.0.2.1, 203.0.113.1


**后端服务器获取真实 IP 的方式：**
* 从 X-Forwarded-For 中取第一个 IP（最左侧）
* 或从 X-Real-IP 中获取（但此时得到的是 CDN 的 IP，而非客户端真实 IP）

## 六、高级配置示例
### 1. 负载均衡配置
```js
http {
    # 定义上游服务器组
    upstream backend_servers {
        server backend1.example.com weight=5;  # 权重为5
        server backend2.example.com weight=3;  # 权重为3
        server backend3.example.com backup;    # 备份服务器
    }
    
    server {
        listen 80;
        server_name example.com;
        
        location / {
            proxy_pass http://backend_servers;  # 使用上游服务器组
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

### 2. 缓存配置
```js
http {
    # 定义缓存区域
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=10g;
    
    server {
        listen 80;
        server_name example.com;
        
        location /static/ {
            proxy_pass http://backend;
            proxy_cache my_cache;  # 使用缓存区域
            proxy_cache_valid 200 302 10m;  # 200和302状态码缓存10分钟
            proxy_cache_valid 404 1m;       # 404状态码缓存1分钟
        }
    }
}
```

### 3.HTTPS 代理配置
```js
server {
    listen 443 ssl;
    server_name example.com;
    
    # SSL证书配置
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-Proto https;  # 传递协议信息
    }
}
```