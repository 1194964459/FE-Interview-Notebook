参考：
https://www.jianshu.com/p/c8b86b09daf0

https://github.com/mqyqingfeng/Blog/issues/22

* 防抖：在一段连续的事件触发后，函数只执行一次；若在n秒内又触发了事件，则会重新计算函数执行时间。防抖是从 “最后一次触发” 算等待时间的。	

### 频繁触发
```javascript
let num = 1;
let content = document.getElementById('content');

function count() {
    content.innerHTML = num++;
};
content.onmousemove = count
```

防抖实现关键点：
* 返回的是一个函数，构成个闭包（定时器的timer是闭包的自由变量）
* this指向，需指向被触发的DOM元素
* 参数：event对象


防抖函数分为‘非立即执行版’和‘立即执行版’。func写在setTimeout内？还是外？

### 非立即执行版
触发事件后函数不会立即执行，而是在 n 秒后执行。如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
```javascript
function debounce(func, wait){
    let timer
    return function(){
        let context = this
        let args = arguments

        if(timer) clearTimeout(timer) // 定时器清除后，定时器中的回调函数就不会执行了

        timer = setTimeout(()=>{
            func.apply(context, args)
        }, wait)
    }
}

content.onmousemove = debounce(count,1000);
```

### 立即执行版
触发事件后函数会立即执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
```javascript
function debounce(func, wait){
    let timer 
 
    return function(){
        let context = this
        let args = arguments

        if (timer) {
            clearTimeout(timer);  
        }

        var callNow = !timer;  // 如果已经执行过，不再执行
        timer = setTimeout(function(){
            timer = null;
        }, wait)

        if (callNow) func.apply(context, args)
    }
}
```
需注意：clearTimeout 只是取消定时器的执行，并不会修改 timer值。timer 的值是 setTimeout 返回的定时器 ID（数字）。除setTimeout更改timer值外，剩下的只有一处会更高：time = null

会有三种情况：初始、wait时间内、wait时间后

### 双剑合并版
```javascript
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func, wait, immediate) {
  let timeout;
  return function () {
    let context = this;
    let args = arguments;

    if (timeout) clearTimeout(timeout);
    if (immediate) {
      // 判断是否可以立即执行（当前没有待执行的定时器）
      const callNow = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, wait);
      // 如果可以立即执行，就执行函数
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
}
```

