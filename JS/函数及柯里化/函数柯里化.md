# 函数柯里化

参考：
* https://github.com/mqyqingfeng/Blog/issues/42
* https://juejin.cn/post/6844903882208837645


柯里化、函数组合copmose 两个是函数式编程的基础，被广泛应用在 Redux、Lodash 等库中。
* 柯里化：将接受多个参数的一个函数 转成 一系列接受部分参数的函数链，参数收集够厚执行原函数。
* 组合函数compose：接收多个函数作为参数，并返回一个新的函数，新的函数在执行时从右到左依次调用这些函数。主要是为了将“函数嵌套”的写法转成 线性扁平化，提高可读性。



### 1. 什么是柯里化（ curry）？
定义：将**接受 多个参数的一个函数 转换成 一系列 可分步接收部分参数 的函数链，当参数收集完整后，执行原函数**。函数链中的函数每次接收一个或多个参数。

如：
* ```add (a, b, c)``` →  ```curriedAdd(1)(2)(3)```
* ```add (a, b, c)``` →  ```curriedAdd(1, 2)(3)```

### 2. 柯里化用途
* 参数复用（固定部分参数）
* 延迟执行（分步接收参数）
* 函数组合的基础

### 3. 如何实现 curry 函数？
核心逻辑拆解：“收集参数 → 判断是否执行 → 递归收集”

那么我们**如何确定何时达到足够的参数呢**？有两种思路：
* 通过函数的 length 属性，获取函数的形参个数，形参的个数就是**函数所需的参数个数**
* 在调用柯里化工具函数时，手动指定所需的参数个数
```js
function curry(func) {
    return function curried(...args) {
        // 关键知识点：function.length 用来获取函数的形参个数
        // 补充：arguments.length 获取的是实参个数
        
        if (args.length >= func.length) {
            // 参数够了，直接执行原函数
            return func.apply(this, args)
        }
        // 参数不够，返回新函数继续“收集后续参数”
        return function (...args2) {
            // 递归调用 curried，合并已有参数和新参数
            return curried.apply(this, args.concat(args2))
        }
    }
}
  
// 测试
function add (a, b, c) {
    return a + b + c
}
const curriedAdd = curry(add)
console.log(curriedAdd(1, 2, 3))
console.log(curriedAdd(1)(2,3))
console.log(curriedAdd(1)(2)(3))
```

## 结合例子分析柯里化分步传参的过程
以 `curriedAdd = curry(add)`（add(a,b,c) 需 3 个参数）为例，看 `curriedAdd(1)(2)(3)` 的执行流程：

1. 第一次调用 `curriedAdd(1)`：
    * args = [1]，func.length = 3 → 1 >= 3 不成立。
    * 返回新函数 `f1`（用于收集下一批参数）。

2. 第二次调用 `f1(2)`：
    * 实际是调用 `curried.apply(this, [1].concat([2]))` → 即 `curried(1, 2)`。
    * `args = [1, 2]`，`func.length = 3` → `2 >= 3` 不成立。
    * 返回新函数 f2（继续收集参数）。

3. 第三次调用 `f2(3)`：
    * 实际是调用 `curried.apply(this, [1,2].concat([3]))` → 即 `curried(1,2,3)`。
    * args = [1,2,3]，`func.length = 3` → `3 >= 3` 成立。
    * 执行 `add.apply(this, [1,2,3])` → 返回 6。
