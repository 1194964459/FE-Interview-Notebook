深拷贝的坑：
https://juejin.cn/post/6844903621021138957

https://juejin.cn/post/6844904197595332622

https://juejin.cn/post/6844903929705136141


在Javascript中一共只有以下7种数据类型：
* Number
* String
* Boolean
* Null
* Undefined
* Symbol
* Object

前面6种类型是原始数据类型，而Object是引用数据类型。通常也把前面6种称之为简单数据类型，而把Object称之为复杂数据类型。复杂数据类型还有子类型，比如Array,Function,RegExp,Date等对象。

先看这一篇内容：[赋值与拷贝区别](./赋值与拷贝区别.md) 

## 一、浅拷贝
浅拷贝： 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以修改新拷贝的对象会影响原对象。

样例：[浅拷贝 Demo](./code/浅拷贝.js)

```js
// 赋值
var arr = ['a', 'b', 'c'];
var arr2 = arr 

// 扩展运算符
{...obj} 

/**
 * slice、concat（创建新数组，不会改变原数组） 
 * 
 * 1. 若数组元素是字符串、数字、布尔值时，修改 数组A 不会影响到 数组B；
 * 2. 若数组元素是个对象引用（不是实际的对象），slice 会拷贝这个对象引用到新的数组里。修改其中一方，另一方也会改变
 */ 
var arrCopy = arr.slice(0);  // ["a", "b", "c"]
arrCopy[0] = 'test'

var arrCopy = arr.concat();  // ["a", "b", "c"]
```

## 二、深拷贝方法
### 1. jquery.extend()方法
不过需要引入jQuery库
```js
$.extend(deepCopy, target, object1, [objectN])//第一个参数为true,就是深拷贝
```
### 2. lodash的_.cloneDeep()
```js
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
```
这是最最最最完美的深拷贝的方式，它已经将会出现问题的各种情况都考虑在内了

### 3. 序列化与反序列化
JSON.parse(JSON.stringify)实现了一个深拷贝。

JSON只支持object,array,string,number,boolean,null这几种数据或者值（即：5种基本类型中除了undefined都支持，复杂类型中支持object、array两种），

其他的比如函数、undefined、Date、RegExp等数据类型都不支持。对于它不支持的数据都会直接忽略该属性。

 * 值为undefined、symbol、函数，会被直接忽略；
 * 值为NaN、Infinity，会转为null；
 * 值为正则、Map、Set，转为一个空对象；
 * 值为Date对象，转为字符串；
 * 循环引用（属性值指向自身），报错
 * 丢失不可枚举属性：无法复制enumerable为false的属性。

```js
// 全部符合预期
const obj = {
    nan:NaN,
    infinityMax:1.7976931348623157E+10308,
    infinityMin:-1.7976931348623157E+10308,
    undef: undefined,
    fun: () => { console.log('叽里呱啦，阿巴阿巴') },
    date:new Date,
}
```    
### 4. 浏览器原生深拷贝API：structuredClone
```js
const obj = { a: 1, b: new Date() };
const cloneObj = structuredClone(obj);
```
* 优点：原生支持，性能较好，能处理包括 Date、RegExp 等多种数据类型，也能处理循环引用。
* 缺点：兼容性较差，一些老旧浏览器、IE不支持该 API。

## 三、如何实现一个深拷贝方法？
先处理基本数据类型、然后是函数、正则、日期、Set、Map，最后才是通用的数组及对象的深拷贝！

### 1. 基本数据类型 深拷贝
直接返回数据值即可！

String、Number、Boolean、Null、Undefined、Symbol六种基本数据类型。
```js
function deepClone(target) {
  if (target instanceof Object) {
    // 数组、对象、日期、函数等复杂类型..
  }
  else{
    return target    // 简单数据类型
  }
}
```

### 2. 对象深拷贝
```js
function deepClone(target) {
  if (target instanceof Object) {
    // 法1：
    // let dist = target instanceof Array ? [] : {};  // 原型链会丢失
  
    // 法2：使用原对象的构造函数创建新对象，保留原型链
    const dist = new target.constructor();

    // 属性遍历 法1（更推荐）：实例自有属性（可枚举 & 不可枚举、字符串键 & Symbol键）
    const ownKeys = Reflect.ownKeys(target);
    ownKeys.forEach(key => {
        dist[key] = deepClone(target[key], weakMap);
    });

    // 属性遍历 法2：自有属性，可枚举，字符串键&Symbol键
    // 遍历实例自身可枚举的属性（对象的键是：字符串）
    for (let key in target) {
      // 仅拷贝自身属性
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        dist[key] = deepClone(target[key], weakMap);
      }
    }
    // 遍历实例自身可枚举的属性 (对象的键是：Symbol类型)
    Object.getOwnPropertySymbols(target).forEach(symKey => {
      dist[symKey] = deepClone(target[symKey], weakMap);
    });

    return dist;
  } else {
    return target;
  }
}
```
dist = {} 或者 dist = [] 等方式创建的新对象，为什么会丢失原型链？   
答：如果有一个类 class Person { ... }，const p = new Person()，使用这个深拷贝函数复制 p，得到的新对象原型不是 Person.prototype，而是普通对象的原型（Object.prototype），原对象的类相关特性（如方法、原型上的属性等）会丢失。

属性遍历：使用 for...in 结合 `Object.prototype.hasOwnProperty.call()` 方法，确保只拷贝**对象自身的可枚举属性**，而不包括从原型链继承的属性。如果需要处理不可枚举或Symbol属性，可以使用 Object.getOwnPropertyNames() 或 Reflect.ownKeys() 方法。

```js
console.log(null instanceof Object)  // false
console.log(typeof null == 'object')  // true
```

### 循环引用如何避免？  
如果一个对象有属性指向自身，那么就会形成一个环。这样的话，在进行递归调用的过程中会无限循环，最终爆栈。

使用 WeakMap 记录已经处理过的对象，当再次遇到已记录的对象时，直接返回之前拷贝好的对象。WeakMap是弱引用，不会阻止键对象回收。
```js
function deepClone(target, weakMap = new WeakMap()) {
    if (weakMap.has(target)) {
        return weakMap.get(target);
    }
    // 记录当前对象和对应的拷贝对象；如Map、Set、对象等..
    weakMap.set(target, result);
    // 其他拷贝逻辑...
}
```

循环引用的几种格式：
1. 自身引用：
```js
let a = {name:"小明"};
a.self = a;   // a的self属性指向a
```

2. 相互引用
```js
const objA = {};
const objB = { a: objA };
objA.b = objB; // 形成循环：objA.b.b.b... 无限嵌套

console.log(objA); // 不会报错，但在控制台可能显示为 "[Circular]"
```

### 3. 数组 深拷贝
数组是种特殊的对象，也可以借用上面对象的深拷贝来实现。不过它主要有2点问题（不过在多数场景下不影响）：
* for...in 遍历对象属性的**顺序不保证**（数组通常会按索引顺序遍历，但规范不强制），另外**会遍历原型链**。
* 如果数组有**非索引的自身属性**（如 arr.customProp = 'test'），也会被遍历和拷贝。

数组的循环引用：
```js
const arr = [1, 2];
arr.push(arr); // 数组最后一个元素引用自身
// arr 的结构：[1, 2, arr]，形成循环引用
```

数组更精准的深拷贝：
```js
if (Array.isArray(target)) {
  const clonedArr = [];
  weakMap.set(target, clonedArr);

  // 用 for 循环或 forEach 遍历，保证顺序 并且 只处理索引元素
  target.forEach(item => {
    clonedArr.push(deepClone(item, weakMap));
  });
  return clonedArr;
}
```

### 4. 函数 深拷贝
如果不是特别需要拷贝函数的逻辑，建议直接返回原函数，即：

```js
if (target instanceof Function) {
  return target;
}
```
因为函数的深拷贝很难完美实现，且在大多数场景下，直接使用原函数引用即可。

### 5. 正则表达式 深拷贝
```js
const a = /hi\d/ig;
```
一个正则，其实由两部分组成，正则的模式（斜杠之间的内容）hi\d,以及参数ig。因此，只要能够拿到这两部分就可以得到一个正则表达式。

通过正则的 source、flags属性可拿到：

```js
const a = /hi\d/ig;
console.log(a.source);   //   hi\d
console.log(a.flags)    // ig
```

```js
if (target instanceof RegExp) {
  return new RegExp(target.source, target.flags);
}
```

### 6. 日期 深拷贝
通过我们上面的方法拷贝后，返回的是一个字符串。这个字符串不是Date类型的， 它无法调用Date的任何方法。

事实上，通过上面的Array,Function,RexExp复杂对象类型的拷贝，我们可以发现，实际上这些拷贝都是通过new XXX()，相当于创建一个新的对象返回回去。因此，日期的拷贝也是一样：

```js
if (target instanceof Date) {
    return new Date(target);   // 老旧浏览器中有兼容性问题
    return new Date(target.getTime());  // 兼容性更好
}
```

### 7. Set与Map 深拷贝
创建新实例：分别使用 new Map() 和 new Set() 创建新的 Map 和 Set 实例。

元素拷贝：对于 Map，需要对键和值分别进行深拷贝；对于 Set，对每个元素进行深拷贝，以保证内部元素的独立性。

```js
if (target instanceof Map) {
    const result = new Map();
    weakMap.set(target, result);  // 处理循环引用

    target.forEach((value, key) => {
        result.set(deepClone(key), deepClone(value));
    });
    return result;
}
if (target instanceof Set) {
    const result = new Set();
    weakMap.set(target, result);   // 处理循环引用
 
    target.forEach(value => {
        result.add(deepClone(value));
    });
    return result;
}
```

## 深拷贝最终版：
因此，最终的完整版为：
[deepClone完整代码](./deepClone完整代码.js)