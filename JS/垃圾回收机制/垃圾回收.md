# V8引擎的垃圾回收
参考：https://juejin.cn/post/6844904016325902344#heading-6


## V8引擎的内存限制
V8引擎在64位系统下最多只能使用约1.4GB的内存，在32位系统下最多只能使用约0.7GB的内存

那么为什么会有这种限制呢？
JS单线程机制：由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。
> web Worker 
垃圾回收机制：若内存比较大，每一次垃圾回收过程就会比较耗时，导致长时间卡顿...浏览器也就越长时间得不到响应。


## V8的垃圾回收策略

V8的垃圾回收策略，根据对象的存活时间将内存的垃圾回收进行不同的分代。
* 新生代：区域相对较小，但是回收过程比较频繁，存放存活时间较短的对象！From（激活状态的区域）、TO（未激活..） 
* 老生代：回收频率低，新生代中的对象在存活一段时间后就会被转移到老生代内存区，老生代又分为老生代指针区和老生代数据区（原始数据对象）
* 代码区
* 对象区
* map区

### 3.1 新生代
**在新生代的垃圾回收过程中主要采用了Scavenge算法**。
在Scavenge算法的具体实现中，主要采用了Cheney算法，它将新生代内存一分为二，每一个部分的空间称为semispace，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为From空间，未激活(inactive new space)的区域我们称为To空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到From空间，当进行垃圾回收时，如果From空间中尚有存活对象，则会被复制到To空间进行保存，非存活的对象会被自动回收。当复制完成后，From空间和To空间完成一次角色互换，To空间会变为新的From空间，原来的From空间则变为To空间。

**对象提升**
当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为晋升。
对象晋升的条件主要有以下两个：

* 对象是否经历过一次Scavenge算法
* To空间的内存占比是否已经超过25%

### 3.2 老生代
采用新的算法Mark-Sweep(标记清除)和Mark-Compact(标记整理)来进行管理。

引用计数：无法被回收，导致内存泄漏。

Mark-Sweep(标记清除)分为标记和清除两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。Mark-Sweep算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收。


Mark-Sweep算法存在一个问题：内存空间可能会出现不连续的状态，即存在内存碎片！后续如果分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收。


为了解决这种内存碎片的问题，Mark-Compact(标记整理)算法被提了出来。
* 标记：标记活动对象..
* 整理：活动的对象往堆内存的一端移动！
* 清除：将活动对象左侧的内存全部回收

注意：标记阶段同样会阻碍主线程的执行，V8引擎又引入了Incremental Marking(增量标记)的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像React框架中的Fiber架构







//////////////////////////////////////////////////////
* 在C++，C等语言中，开发者需要跟踪内存使用，对于开发人员来说，这是个很大的负担，也是很多问题的来源。

* JS中，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：**确定哪个变量不会再使用，然后释放它占用的内存。**这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动运行。

**因此，我们需要知道如何标记未使用的变量，主要有两种方式：标记清理、引用计数**
