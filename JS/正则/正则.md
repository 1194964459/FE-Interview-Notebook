# 正则

参考：
[正则: URL解析](https://juejin.cn/post/6844903697198088199?searchId=2025081319393340AFCD9E78A747044FF3) 

[25个常见的正则](https://juejin.cn/post/6999768570570178596?searchId=20250813191800084D66BE08F1EF176B35#heading-46)

[正则 标准文档](https://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

[零宽断言](https://juejin.cn/post/6844903855243657230?searchId=20250813194704743EADCDE446AA2F911E)

## 正则中的()、[]、{}分别做啥的？
* ()：分组（捕获组 / 非捕获组）   
注意：分组中特殊符号需用\转义，不过貌似仅仅[]中不需要转义
基本用途如下：      
**整体匹配**：将一组字符作为一个单元，配合量词（如 *、+、?）使用。  
**捕获分组**：后面可替换(用$1、$2..表示)、反向引用（\1、\2）  
    > 模式 <code>/(foo) (bar) \1 \2/</code>中：\1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar   
    > 正则的 replace 替换环节中，用$1、$2来表示被匹配的字符串

* []：字符集！定义一组「可选字符」，匹配其中**任意一个字符**。
[]使用时一些字符的含义：
    * -：表示字符范围
    * ^：不在“可选字符范围内的”
    * [] 内的大多数特殊字符（如 .、*、+）会失去特殊含义，仅表示自身。
    * [^xyz]：一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。
* {}：量词！指定前面的字符或分组必须匹配的次数。



## 零宽断言（预查）
零宽断言（也叫预查）是一种特殊的匹配机制，用于匹配 “位置” 而非具体字符，不消耗字符串，主要作用是限定某个位置前后的内容必须符合特定条件。

零宽断言（如 (?=x)、(?!x)、(?<=x)、(?<!x)）

**零宽断言的核心特点**：
* **零宽**：*不匹配具体字符，只匹配 “位置”*（如字符之间的间隙、字符串开头 / 结尾）。
* **断言**：*判断该位置*的*前后内容是否符合特定条件*。
* **不消耗字符**：只标记位置，不移动指针(匹配后) ，后续匹配仍从当前位置开始。

零宽断言有一下几种：
* x(?=y)：正向肯定查找。匹配'x'仅仅当'x'**后面**跟着'y'.
* x(?!y)：正向否定查找。仅仅当'x'**后面**不跟着'y'时匹配'x'
* (?<=y)x：反向肯定查找。匹配'x'仅当'x'**前面**是'y'.
* (?<!y)x：反向否定查找。仅仅当'x'**前面**不是'y'时匹配'x'


## x(?=y) 与 (?=y) 区别：
两者都是正向预查！
x(?=y)是匹配字符+正向预查的，匹配 “后面紧跟 y 的 x”。经常用来**筛选特定后缀的字符**。
(?=y)仅仅只有正向预查，不匹配字符，仅仅匹配 “后面紧跟 y 的位置”	。经常用来**定位特定前缀的位置**。


## (?:x)：分组 但不捕获
与(x)不同，它是分组 并且捕获，()是捕获括号，\1、\2, ..., \n 是被捕获括号匹配的子字符串！在正则表达式的替换环节，用$1、$2、...、$n 来表示被捕获的子字符串

与(x)、零宽断言的区别：
* (x)：分组字符的“捕获结构”
* (?:x)：分组字符的“非捕获结构”，会匹配并消耗字符（匹配后指针会移到 x 后面）！
    > /foo{1,2}/，{1,2} 将只应用于 'foo' 的最后一个字符 'o'。   
    > /(?:foo){1,2}/会应用于整个 'foo' 单词; foo 出现1~2次   
* 零宽断言：用于**定位位置**的判断条件，不匹配任何字符！

## \b：匹配一个词的边界
是**固定规则的位置判断**，仅根据 “位置两侧是否为单词字符” 来匹配位置。    
**单词字符**指 [a-zA-Z0-9_]（字母、数字、下划线），**非单词字符***指其他字符*（如空格、标点、字符串开头 / 结尾）。   

满足以下条件之一即匹配 \b：
* 一侧是单词字符，另一侧是非单词字符（如 a 和 ! 之间）
* 一侧是单词字符，另一侧是字符串开头 / 结尾（如 a 前面是开头）

**例如**：正则 <code>/\bcat\b/g</code>， 要求：“cat 前面是一个单词边界，右边也是个单词边界”！由于 cat 是单词字符，所以要想单词边界匹配，则 cat 前后必须是 “非单词字符” 才可以（如开头、结尾、空格、标点等）。所以**可以成功匹配 cat，但是不匹配 category 或 scat**


## \B：匹配 非单词边界，刚好与 \b 相反
\B 出现在 “同类字符相邻” 的位置，即：

* 两个单词字符之间（如字母与字母、字母与数字等）；
* 两个非单词字符之间（如符号与符号、空格与标点等）。

**例如**：正则 <code>/\Bing\B/g</code>，由于 “ing” 是单词字符，所以其前面、后面也必须是单词字符才可以！所以 sing、ing123、singing 匹配不上，springboard 可以成功匹配


### 零宽断言和 \b 比较
零宽断言和 \b（单词边界）都属于正则中的 **“零宽” 元素（只匹配位置，不匹配具体字符）**，但它们的判断逻辑和应用场景有本质区别：
* 零宽断言（如 (?=x)、(?!x)、(?<=x)、(?<!x)）
是**自定义条件的位置判断**，根据 “位置前后的**具体内容**” 来匹配位置。灵活度高
* \b 是固定规则的位置判断，仅根据 “位置两侧是否为单词字符” 来匹配位置。

**示例对比**：
对字符串 "a-b_c123" 分析两者的匹配位置：
* (?=-) 匹配 “后面是 -” 的位置，即 a 和 - 之间的位置（仅此一处）。
* \b 会匹配以下位置（共 4 处）：
    > 字符串开头和 a 之间（开头是非单词字符，a 是单词字符）  
    > a 和 - 之间（a 是单词字符，- 是非单词字符）  
    > "-" 和 b 之间（- 是非单词字符，b 是单词字符）  
    > 3 和字符串结尾之间（3 是单词字符，结尾是非单词字符）  

更多案例：[\b的更多案例](./code/反斜杠b.js)


## 结尾符 $ 
正则 ```js/(?=(\d{3})+$)/g``` 中，若把 $ 取消会怎样？

* 保留 $：匹配一个位置，该位置后面必须是 “**连续的 3 位数字组**”，且这些数字组**一直延续到字符串结尾**。
* 去掉 $：匹配一个位置，该位置后面只要有 “**至少一组 3 位数字**” 即可，**不要求这些数字组延续到字符串结尾**。

