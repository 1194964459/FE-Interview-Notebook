# 扩展运算符 与 rest 参数

扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。


## 一、对象的扩展运算符

**1. 合并对象：**

Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中 **可枚举属性** 和 **自有属性** 复制到目标对象

```JS
// 查看 属性是否可枚举。若是的话，返回true
Object.propertyIsEnumerable()  

// 查看 对象自身属性中 是否具有指定的属性，若有，返回true
Object.hasOwnProperty()
```

**2. 对象的扩展运算符**

对象的扩展运算符等同于使用Object.assign()方法。

```js
let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
```
不过这只拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法：
```js
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

扩展运算符可以用于合并两个对象。
```js
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

**3. 目前，有四个操作会忽略enumerable为false的属性**:
参考：[创建对象中相关方法总结](../对象_类_面向对象/1.1_创建对象.md)

* for...in循环：实例属性和原型属性 中可枚举的属性。
* Object.keys()：返回对象**自身的**所有可枚举的属性的键名。
* JSON.stringify()：只串行化对象**自身的**可枚举的属性。
* Object.assign()： 忽略enumerable为false的属性，只拷贝对象**自身的**可枚举的属性。

## 二、数组中的扩展运算符
数组中追加元素、拷贝、合并、类数组转为数组、函数调用时将数组转为一个个逗号分割的参数

1. 函数调用时，将数组转为逗号分割的参数系列
```js
var args = [0, 1, 2];

func.apply(null, args);    // ES5

func(...args);    // ES6中
```

2. 求数组中最大的值 
```js
Math.max.apply(null, [14, 3, 77])     // ES5中：等同于Math.max(14, 3, 77)

Math.max(...[14, 3, 77])  // ES6中
```

3. 将一个数组追加到另一个数组尾部
```js
Array.prototype.push.apply(arr1, arr2);  // ES5

arr1.push(...arr2);  // ES6中
```

4. 合并数组，创建一个新数组
```js
arr1.concat(arr2, arr3);  // 浅拷贝，ES5中

[...arr1, ...arr2, ...arr3]   // ES6中
```

5. 拷贝数组，都是浅拷贝（参考：[数组如何实现深拷贝](../浅拷贝与深拷贝/深拷贝实现.md)）
```js
const a2 = a1;   // 仅仅拷贝引用，在内存中指向同一个数组对象

// ES5中：
const a2 = a1.concat();    // 创建新数组，a2 与 a1占用不同的内存空间；不过若数组中的元素是引用类型时，会共享同一个内存空间（浅拷贝）
const a2 = a1.slice();   // 等同于a1.concat();

// ES6中
const a2 = [...a1];  
const a2 = Array.from(a1)）
```

6. 将类数组转化为数组
```js
// ES5中:
Array.prototype.slice.call(arguments)  
Array.prototype.concat.call(arguments) 

// ES6中：
[...arguments];
Array.from(arguments) 
```

**Array.from()、扩展运算符 都可以将某些结构转化为数组，区别是**：
* 扩展运算符背后调用的是迭代器 接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。
* Array.from 除了支持迭代器 接口，还支持类数组对象（必须有length属性）。
* Array()、Array.of()：都可以创建数组
    1. 当参数为空、多个参数时表现是一样的：
    ```JS
    new Array(1, 2, 3);   // [1, 2, 3]
    new Array()  // []

    Array.of(1,2,3);  
    Array.of();
    ```
    2. 当参数只有一个正整数时 两者是有区别的：
    * Array() 参数指的实际上是指定数组的长度，返回有指定数目的空数组；
    * Array.of() 指定单个数组元素的值。
    ```js
    Array(3)    // [, , ,]      

    Array.of(1) // [1]
    ```

## 三、函数的rest参数

ES6 引入 rest 参数(剩余参数)，形式为```...变量名```，用于**函数定义时** 聚合**多个参数为数组**（如**多个独立参数 转为 一个数组**）。

* 在函数定义时使用，是函数的“形参“，而不是“实参”。
* 它会收集所有未被前面参数捕获的剩余参数，组成一个数组。
* rest参数 与 arguments相比：rest是数组，仅仅捕获剩余参数；arguments是类数组，包含所有参数


下面是一个 rest 参数代替arguments变量的例子。

```js
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}
// slice方法的内部逻辑是：不管this是什么，只要它有 length 和索引，就会按照这些索引和长度生成一个新数组。所以，当 slice 作用于 arguments 时，就会把这个类数组对象转换成一个真正的数组。

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```
arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。

注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
```JS
// 报错
function f(a, ...b, c) {
  // ...
}
```

函数的length属性，不包括 rest 参数。

```JS
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

## 四、扩展运算符 和 rest参数的区别：
* 扩展运算符（...）用于**拆分可迭代对象**（如**一个数组/字符串/Set/Map 转为 多个独立元素**）。
```js
// 扩展运算符：拆分数组
const arr = [1, 2, 3];
console.log(...arr); // 1 2 3
```
* rest 参数（...）用于**函数定义时** 聚合**多个参数为数组**（如**多个独立参数 转为 一个数组**）。
```js
// rest 参数：聚合参数为数组
function fn(...args) {
  console.log(args); // [1, 2, 3]
}
fn(1, 2, 3);
```


## 五、for..in 与 for..of

参考：[for..in 与 for..of](./迭代器/for..in%20与%20for..of.md)
