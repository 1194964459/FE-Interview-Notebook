# Vuex
参考：  
[vuex中常见你面试题](https://blog.csdn.net/m0_64346035/article/details/124619717)

[store有哪些方法？](https://www.doubao.com/thread/w6eedf23c65178431)

本文的核心知识点：
* Vuex是？
* Vuex中的数据流向是怎样的？
* 五大核心概念
* Mutation
* Action
* Module
* Vue组件中如何使用Vuex？
* 辅助函数：mapState
* Vuex3 与 Vuex4 有啥区别？
* Vuex 与 Redux 比较

Vuex：是全局状态管理，将应用中所有组件共享的状态集中存储在一个 “全局仓库 Store” 中，任意组件 都能直接访问或修改这些状态。状态变化可追踪，代码可维护性强。

**五大核心概念**：State、Getter、Mutation、Action、Module

### Vuex中的数据流向是怎样的？
* **组件**通过 dispatch 触发 Action（可包含异步操作）。
* Action 通过 commit 触发 Mutation。
* Mutation 直接修改 State。
* **组件**通过 State 或 Getter 获取最新状态。
* 整个流程可通过 Vue DevTools 追踪，状态变化清晰可预测。


store 中状态的读取与修改：
* store.state
* store.getters
* store.commit('mutationName', payload)：同步操作    
* store.dispatch('ActionName', payload)：异步操作

```js
// Vuex 示例
const store = new Vuex.Store({
  state: { count: 0 },
  mutations: {
    increment(state) { state.count++ } // 同步修改
  },
  actions: {
    incrementAsync({ commit }) {
      setTimeout(() => commit('increment'), 1000) // 异步需通过 mutation
    }
  }
})
```

## 模块：Module
Vuex 中引入模块（Module） 是为了解决大型应用中状态管理复杂度激增的问题。
* 模块机制能将这些状态按功能拆分，实现状态的模块化管理。每个模块独立维护自己的 state、mutations、actions、getters。
* 隔离命名空间，避免冲突：
不同模块可能存在同名的 mutation 或 action。通过开启 `namespaced: true`，模块会形成独立的命名空间，避免冲突。

注册模块：
* 动态注册：store.registerModule
* 静态注册（推荐，常用），如下：
```js
import Vue from 'vue'
import Vuex from 'vuex'
import userModule from './modules/user'
import cartModule from './modules/cart'

const store = new Vuex.Store({
  modules: {
    // 这里的键名 `user` 就是模块的命名空间标识
    user: userModule,  
    // 这里的键名 `cart` 就是模块的命名空间标识
    cart: cartModule   
  }
})
```

```js
const userModule = {
  namespaced: true, // 开启命名空间
  mutations: { update() {} }
}

const cartModule = {
  namespaced: true,
  mutations: { update() {} } // 与 user 模块的 update 不冲突
}

// 调用时需指定模块名
store.commit('user/update')   // 调用 user 模块的 update，
store.commit('cart/update')   // 调用 cart 模块的 update
```


## mutation
mutation 是用于**同步修改状态**的函数，它接收两个参数：
* state：只能通过 state 参数修改状态（这是 Vuex 规定的唯一修改途径）。
* payload：可选参数，可以是任意类型（基本类型、对象、数组等）。
```js
mutationFunc(state, payload)  // payload：可选参数
```
例如：
```js
mutations: {
  // 无 payload 的情况
  increment(state) {
    state.count++; // 直接修改当前模块的 state
  }
}
```

## Action
action 是用于处理异步逻辑或复杂同步逻辑的函数，参数是个“上下文对象”：
```js
ActionFunc(context, payload)
```
其中context中包含了与当前 store 相关的方法和属性，常用的有：
* context.state：访问当前模块的状态（同 mutation 的 state）。
* context.getters：访问当前模块的 getters。
* context.commit：调用 mutation 的方法（action 必须通过它修改状态）。
* context.dispatch：调用其他 action 的方法（支持链式调用）。
* context.rootState：若为子模块，可通过它访问根模块的 state。
* context.rootGetters：若为子模块，可通过它访问根模块的 getters。

如：
```js
actions: {
  // 简化写法：对象解构（推荐）
  fetchUser({ commit, dispatch }, userId) {
    axios.get(`/api/user/${userId}`)
      .then(res => {
        commit('setUser', res.data); // 直接使用解构后的 commit
        dispatch('logUserFetch', userId); // 直接使用解构后的 dispatch
      });
  }
}

// 调用方式
store.dispatch('fetchUser', 123); // 传递参数
```

## 辅助函数
简化组件中使用 Vuex 的代码：  
* mapState：映射 state 到组件计算属性
* mapGetters：映射 getters 到组件计算属性
* mapMutations：映射 mutations 到组件方法
* mapActions：映射 actions 到组件方法

### mapState
Vuex 提供的辅助函数，用于将 store 中的状态映射到**组件的计算属性**中。

它的参数根据使用场景（是否模块化、是否自定义映射关系）有不同的形式，主要分为以下几种情况：   
一、非模块化场景（根状态）：mapState 接收一个对象或数组作为参数  
1. 参数为数组（最简单形式）   
数组中的元素是 state 中的字段名，映射后计算属性名与 state 字段名一致。
```js
import { mapState } from 'vuex'

export default {
  computed: {
    // 映射 this.count = this.$store.state.count
    // 映射 this.todos = this.$store.state.todos
    ...mapState(['count', 'todos'])
  }
}
```
2. 参数为对象（自定义映射关系）：   
**对象的键**是**组件中计算属性的名称**，**值**是对应的 state 字段或映射函数，箭头函数、普通函数都可以。不过若想访问组件自身的 this（如组件的 data 或 props），必须用普通函数（箭头函数没有 this 绑定）。
```js
...mapState({
  // 写法1：值为字符串（对应 state 中的字段名）
  myCount: 'count', // this.myCount = this.$store.state.count

  // 写法2：值为函数（接收 state 作为参数，可加工状态）
  doubleCount: state => state.count * 2, // 计算后映射

  // 写法3：值为函数（需访问组件自身的 this 时，用普通函数）
  userInfo(state) {
    // 这里的 this 指向组件实例
    return `${state.user.name} (${this.prefix})`
  }
})
```

二、模块化场景（带命名空间）   
当映射开启了命名空间（namespaced: true）的模块状态时，mapState 接收两个参数：（模块名， 对象/数组）    
```js
import { mapState } from 'vuex'

export default {
  computed: {
    // 方式1：数组形式（模块名 + 字段数组）
    ...mapState('user', ['name', 'age']), // this.name = store.state.user.name

    // 方式2：对象形式（模块名 + 自定义映射）
    ...mapState('user', {
      userName: 'name', // 自定义计算属性名
      userAge: state => state.age + '岁' // 加工状态
    })
  }
}
```

## Vuex 3 与 Vuex4有什么区别？
* Vuex 3：仅支持 Vue 2，依赖 Vue 2 的响应式系统（Object.defineProperty）和选项式 API。
* Vuex 4：专为 Vue 3 设计，适配 Vue 3 的响应式系统（Proxy）和组合式 API（setup 函数等），同时兼容选项式 API。


| 维度| 	Vuex 3	| Vuex 4|
| ---- |  ---- |  ---- |  
| 适配框架| 	Vue 2| 	Vue 3| 
| 创建方式	| `new Vuex.Store()`| 	`createStore()`| 
| 安装方式|  Vue 根实例 store 选项 | `app.use(store)`| 
| state 推荐形式| 	对象| 	返回对象的函数| 
| 组合式 API 支持| 	不支持| 	支持（useStore 函数）| 
| 响应式实现| 	`Object.defineProperty`| 	Proxy| 
| TypeScript 支持	| 弱| 	强| 


### 一、使用vuex3

创建 Store：
```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex) // 必须先安装插件

const store = new Vuex.Store({
  state: { count: 0 }, // state 是对象
  // ...其他配置
})
```

安装Store到应用：
```js
new Vue({
  el: '#app',
  store, // 注入到根实例
  render: h => h(App)
})
```

### 二、使用vuex4
创建 Store：
```js
import { createStore } from 'vuex'

const store = createStore({
  state: () => ({ count: 0 }), // state 推荐是返回对象的函数（避免状态污染）
  // ...其他配置
})
```
安装Store到应用：
```js
import { createApp } from 'vue'
import App from './App.vue'
import store from './store'

createApp(App)
  .use(store) // 安装到应用
  .mount('#app')
```

## 在 Vue 组件中使用 Vuex
```js
// 在组件中获取状态
this.$store.state.count

// 在组件中使用 getter
this.$store.getters.doneTodos

// 在组件中提交 mutation
this.$store.commit('increment')

// 在组件中分发 action
this.$store.dispatch('incrementAsync')
```

## 在 Vue 3 组件中使用 Vuex

1. 选项式API中使用：基于**mapState**，与 Vue 2 基本一致

```
<template>
  <div>
    <p>count: {{ count }}</p>
    <p>用户名: {{ userName }}</p>
    <button @click="increment">增加 count</button>
  </div>
</template>

<script>
import { mapState, mapMutations } from 'vuex'
export default {
  computed: {
    ...mapState(['count']),
    ...mapState({
      userName: state => state.user.name
    })
  },
  methods: {
    ...mapMutations(['increment'])
  }
}
</script>
```
2. 组合式API中使用：使用 **useStore** 函数来获取 store 实例：
```
<template>
  <div>
    <p>count: {{ count }}</p>
    <p>用户名: {{ userName }}</p>
    <button @click="increment">增加 count</button>
  </div>
</template>

<script setup>
import { useStore } from 'vuex'
import { computed } from 'vue'

const store = useStore()
// 直接从 store 中获取状态
const count = computed(() => store.state.count)
const userName = computed(() => store.state.user.name)

// 调用 mutation
const increment = () => {
  store.commit('increment')
}
</script>
```

##  Vuex 与 Redux 比较
Store：两者都是全局唯一的状态容器，提供了访问和修改状态的接口。   
state：状态存储   

派生状态：  
* Vuex：getters：从 state 中派生出的计算属性，类似 Vue 组件的 computed。
* Redux 本身没有内置计算属性，reselect（第三方库）

状态修改（同步操作）：  
* Vuex：mutations，vuex中 唯一能修改 state 的方式，必须是同步函数。Vuex 的 mutation 可直接修改state的（因为Vue是响应式的！）
* Redux：reducer，Redux 中修改状态的唯一方式。不过不能直接修改旧状态，必须得返回新状态（不可变性）
    ```js
    （preState， action）=> newState
    ```

异步操作处理：
* Vuex：actions，`store.dispatch('actionName')`触发，然后内部通过 commit 触发 mutation 间接修改状态
    > Vuex 中 action是方法，但调用时传递的参数（payload）是 “数据载体”。

* Redux：action creators + middleware（如 redux-thunk）
    > Redux 中 action是纯 JavaScript 对象，必须包含 type 字段，payload 可选

状态过于庞大时，模块化处理：
* Vuex：modules，允许将 store 拆分为多个模块，每个模块包含自己的 state、mutations、actions 等，支持嵌套。
* Redux：每个 reducer 负责管理一部分状态，最后通过 combineReducers 合并




