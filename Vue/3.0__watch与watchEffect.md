# watch 与 watchEffect

参考：
[watchEffect](https://cn.vuejs.org/api/reactivity-core.html#watcheffect) 


## 一、watchEffect
用于**创建**一个**副作用函数**，它会**自动追踪**其内部使用的响应式数据，并在这些数据发生变化后*重新执行*。watchEffect在**创建时也会立即执行的**。

与 watch 的主要区别：  
* watch 需要**明确指定监听源**，watchEffect 自动追踪
* watch 可以**获取新旧值**，watchEffect 不能
* watch 默认是懒执行的(首次不执行回调)，watchEffect 会立即执行

语法：
```js
const stop = watchEffect((onCleanup) => {
  // 副作用函数
}, {
  flush: 'pre', // 在 DOM 更新后执行
  onTrack: (e) => { console.log('追踪到依赖:', e) },
  onTrigger: (e) => { console.log('依赖变化:', e) }
})
```
1. 调用返回值stop()：停止监听副作用函数中的响应式变量，避免内存泄漏
2. watchEffect 默认在响应式数据变化后、DOM 更新前执行。因此，可能会导致读取到的 DOM 状态是更新前的旧值、覆盖之前的响应式数据变化。通过 flush 选项调整执行时机：
    * flush: 'pre'（默认）：响应式数据变化后立即执行（**DOM 更新前**）。
    * flush: 'post'：DOM 更新后执行，适合读取**更新后**的 DOM 状态。
    * flush: 'sync'：同步执行，性能差、不推荐。
    > 额..  这里的pre、post貌似是相对DOM更新的时机来的

3. onCleanup参数：可选参数。当副作用包含异步操作（如定时器、事件监听、API 请求）时，若在**异步操作完成前依赖发生变化**，可能导致无效操作累积。
```js
watchEffect((onCleanup) => {
  const timer = setInterval(() => {
    console.log('Running...')
  }, 1000)
  
  // 清理函数：在副作用重新执行或停止时调用
  onCleanup(() => clearInterval(timer))
})
```
常见清理场景：
* 清除定时器/计时器
* 移除事件监听器（如 window.scroll）
* 取消未完成的 API 请求（如 Axios 取消令牌）


使用时注意事项：
1. 避免在副作用中修改自身依赖，会导致循环触发（不停的get、set...）
```js
// 错误示例：会导致无限循环
const count = ref(0)
watchEffect(() => {
  console.log(count.value)
  count.value++ // 这里修改了依赖，导致再次触发
})
```

2. 使用 watchEffect 的清理机制
```js
const count = ref(0)
watchEffect((onCleanup) => {
  const timer = setInterval(() => {
    count.value++
  }, 1000)
  
  // 清理函数：在重新执行前清除定时器
  onCleanup(() => clearInterval(timer))
})
```

## 二、 watch
与 watchEffect 相比，更适合**显式指定监听源**和**获取变化前后的值**。

* 可监听的有：ref、reactive 对象的属性、计算属性等；
* 监听 reactive 对象的属性时，需要用函数形式指定源 `() => user.age`
* `immediate: true`：初始时也执行回调。因为watch默认是懒执行的，只有当监听的源发生变化时，才会执行回调
* `deep: true`：深度监听嵌套对象的变化。不过很影响性能，需尽量精确监听需要的属性（如直接监听 `() => obj.a.b`）。
* 可监听多个源：用数组表示
```js
import { ref, watch } from 'vue'

const a = ref(1)
const b = ref(2)

watch([a, () => b.value], ([newA, newB], [oldA, oldB]) => {
  console.log(`a 变化: ${oldA} → ${newA}`)
  console.log(`b 变化: ${oldB} → ${newB}`)
})

a.value = 10 // 触发监听
b.value = 20 // 触发监听
```

## watch 与 computed 的区别
计算属性主要是「纯计算」，获得一个新值；如果依赖没变化，多次访问会直接取缓存，性能更优。

不过计算属性是同步的，若想执行某些异步操作 需在watch 属性或在 onMounted 等生命周期钩子中手动处理
```js
// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
```

watch通常是在值变了之后做某件事”（如发请求、改 DOM、存缓存、复杂校验）