# 响应式原理（v2、v3）
参考：[ref 与 Reactive比较](https://www.doubao.com/thread/w07d1ca27b840d9f5)

Vue原理及源码解析：/Users/yanglixia/Documents/ri-chang/vue-source-learn

## Ref 与 Reactive
Ref：

Proxy只能代理对象，所以会先将它包装为一个带有 .value 属性的 对象。

Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。所以我们访问、设置时都要基于.value属性。
```js
// 创建一个包装对象，用 `value` 属性存储原始值
  const wrapper = {
    _isRef: true, // 标识为 ref 类型
    get value() {
      track(wrapper, 'value'); // 追踪依赖（依赖的是 wrapper 的 value 属性）
      return value;
    },
    set value(newValue) {
      if (newValue !== value) {
        value = newValue;
        trigger(wrapper, 'value'); // 触发更新
      }
    }
  };
```

ref 和 reactive 默认都能实现深层响应性，reactive 针对对象和数组，通过**懒代理的方式递归处理嵌套结构**；
何为懒代理？对嵌套对象的响应式转换是延迟进行的，只有**当嵌套对象被访问时，才会将其转换为响应式对象**


### 疑问❓：响应式对象为什么不能解构？
解构的本质是**读取对象属性的值 并 赋值给新变量**。这些**新变量是普通变量（非响应式）**，由于响应式的核心是对对象属性访问的拦截，
因此普通变量不再被 Vue 的响应式系统追踪（失去了与原响应式对象的关联）。 TODO:

**如何在解构时保持响应式？**  
答：**基于toRefs函数**，将响应式对象的每个属性转换为ref对象（保留响应式关联）。解构ref对象后，通过.value访问/修改仍能触发响应式更新：
```js
import { reactive, toRefs } from 'vue';
const user = reactive({ name: '张三', age: 20 });

// 使用toRefs转换后再解构，属性变为ref对象
const { name, age } = toRefs(user);

name.value = '李四'; // 修改ref的值，会触发视图更新
```

