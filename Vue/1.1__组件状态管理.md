# 组件状态管理

参考：[Vue状态管理](https://cn.vuejs.org/guide/scaling-up/state-management.html)

总结：
* 父传子：props   
* 子传父：基于事件（子组件emit、父组件v-on监听）
* 隔代、祖孙：provide、inject
* 平级组件 或 跨越多层嵌套：**事件总线**（如：可考虑使用mitt库）、**全局状态管理**（如：pinia）
* 其他通信方式
  * $parent/$children：适用于选型时API，直接访问组件实例（不推荐，耦合度高）
  * 通过模板引用获取父/子实例，在父组件中访问子组件的方法、数据。不过，该方法主要用于操作 DOM。

## 子传父：基于事件（子组件emit、父组件v-on监听）
实现方式：

1. 子组件：
```js
// 法1：组合式API
const emit = defineEmits(['submit', 'change'])
const handleSubmit = () => {
    // 触发事件：emit(事件名, 传递的参数)
    emit('submit', '表单数据')
}

// 法2：选项式API：
this.$emit('child-message','数据')  // this.$emit无需引入
```

2. 父组件：
```js
  <ChildComponent @submit="handleChildSubmit" />
```

组合式API中有两种情况：
* defineEmits()：必须直接放置在 `<script setup>` 的顶级作用域下。
* 若使用了setup 函数，事件需要通过 **emits 选项**来定义，**emit 函数**也被暴露在 setup() 的上下文对象上：
  ```js
  export default {
    emits: ['inFocus', 'submit'],
    setup(props, ctx) {
      ctx.emit('submit')
    }
  }
  ```

## Provide、Inject
解决Prop 逐级透传问题。 注意：Provide与Inject需要在setup中使用；

provide的值可以是任意类型，包括响应式的状态，比如一个 ref。不过**如果提供的是响应式数据的话**，建议尽可能将**任何对响应式状态的变更都保持在供给方组件中**。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。如：
```js
const location = ref('North Pole')

function updateLocation() {
  location.value = 'South Pole'
}

provide('location', {
  location,
  updateLocation
})
```

除了组件中提供(provide)依赖外，也有应用层Provide
```js
import { createApp } from 'vue'

const app = createApp({})

app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
```

## 通过模板引用获取父/子实例，在父组件中访问子组件的方法、数据
不过该方法主要用于操作 DOM，通信的话 不是很适合
```js
// 父组件 模版
<ChildComponent ref="childComp"/>

// 父组件 方法：
// 1. 选项式API：通过 $refs 获取子组件实例
const childInstance = this.$refs.childComp
if (childInstance) {
  // 调用子组件的方法
  childInstance.childMethod() 
  // 访问子组件的数据
  console.log(childInstance.childData) 
}

// 2. 组合式API：使用 ref 定义一个与 ref 属性同名的变量，通过该变量访问子组件实例。
const childComp = ref(null)
if (childComp.value) {
  childComp.value.childMethod()  
}
```

## Pinia
参考：[Pinia](https://pinia.vuejs.org/zh/introduction.html)