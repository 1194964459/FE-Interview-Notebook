# 常见面试题

参考：[常见面试题](https://www.doubao.com/thread/w51c0bfc97a4f1447)

主要内容有：
* Keep-alive 与 动态组件 对比：
* Teleport组件
* nextTick()：刷新 DOM
* Vue中父组件 想访问 子组件 的属性和方法有哪些途径？
* Vue项目中的错误是如何处理的？
* Vue中如何定义全局方法？


## Keep-alive 与 动态组件 对比：
* `<component :is="...">` 在多个组件间作切换时，被切换掉的组件会被**卸载**。 
* `<KeepAlive>` 在多个组件间动态切换时**缓存被移除的组件实例、包括它的状态**，被移除的组件依旧是“**存活**”的状态。

## Teleport组件
Teleport 可以将一个组件内的**部分模板内容**“传送”到**该组件的 DOM 结构外层**，与React的 **Portals组件**类似。常用于处理**模态框、提示框等需要脱离常规 DOM 层级进行渲染的 UI 元素**。用to属性指定 要传送到的目标位置！

这类组件：**逻辑上**从属于父组件，但**从整个应用视图的角度**来看，被渲染在了 DOM 结构外层。

逻辑上的从属关系指的是：传入的 props 和触发的事件也会照常工作。


```js
<button @click="open = true">Open Modal</button>

<Teleport to="body">
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</Teleport>
```

## nextTick()：刷新 DOM
Vue 中**更改响应式状态**时，Vue 不会立即执行 DOM 更新。而是将这些更新操作缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，在一个tick周期内 仅执行一次更新。
> “tick”通常指的是 JavaScript 事件循环中的一个宏任务
```js
function nextTick(callback?: () => void): Promise<void>
```
参数callback是可选的，表示DOM更新完成后执行的回调。
```js
const count = ref(0)

async function increment() {
  count.value++

  // DOM 还未更新
  console.log(document.getElementById('counter').textContent) // 0

  await nextTick()
  // DOM 此时已经更新
  console.log(document.getElementById('counter').textContent) // 1
}
```

## Vue中父组件 想访问 子组件 的属性和方法有哪些途径？
父组件基于模版引用子组件时，组件定义的方式不同，子组件暴露的属性、方法也不同：
1. 子组件用选项式API定义，父组件可以访问到子组件的大部分属性和方法。如：props、data、methods、computed等..
2. 子组件用组合式API定义：
    * 基于setup函数：仅仅只能访问到setup返回的内容
    * 基于`<script setup>`：默认所有成员都是私有的，必须通过 defineExpose 显式暴露才可以！

## mixin是啥？
mixin主要作用是：抽离共性逻辑，实现代码复用。不过存在命名冲突、来源模糊等问题，mixin 的所有功能都能被 Composition API 替代，基本上该 API 已经废弃了。

## 插件
插件可以是一个**包含 install() 方法的对象**，也可以**直接是一个函数**（这个函数就相当于 install 方法）
1. 作为对象（包含 install 方法）：
```js
const myPlugin = {
  install(app, options) {  
    // 插件逻辑，options是use插件时传入的参数
    app.config.globalProperties.$hello = () => console.log('Hello from plugin!')
  }
}

// 使用插件
app.use(myPlugin, {
  options
})
```
2. 作为安装函数本身：
```js
function myPlugin(app, options) {
  // 插件逻辑（与上面的 install 方法内容相同）
  app.config.globalProperties.$hello = () => console.log('Hello from plugin!')
}

// 使用插件（调用方式完全一样）
app.use(myPlugin)
```
3. app.provide(key，options)：可以将插件内的options 参数提供给整个应用


## v-if、v-show、v-for
* v-if：需要从 DOM树 中创建、移除元素，开销大
* v-show：通过设置元素的 CSS display 属性来控制显隐，适合需要频繁切换的场景！

疑问❓：V-if 与 v-for为什么不能一起用？   
答：即使我们主管意愿是先过滤 过滤完之后再用v-for批量渲染。 但实际并非如此，因为 **Vue 模板编译时，v-for 的优先级高于 v-if**。因此，每次列表更新时，都会先执行循环再进行条件判断，然后导致不必要的 DOM 操作。

如何解决：
1. 在计算属性中先过滤数据，再用 v-for 渲染（推荐）
2. v-if与v-for分别操作不同的元素，将v-for用 `<template>` 包裹，如下：
  > `<template>`主要用于包裹多个元素，是不生成真实DOM的。
```js
<template v-if="shouldShowList">
  <li v-for="item in list" :key="item.id">
    {{ item.name }}
  </li>
</template>
```

## Vue项目中的错误是如何处理的？
除以下两类外，错误基本都可以用try/catch来捕获。

**1. 组件内错误处理**  
errorCaptured生命周期钩子 捕获子孙组件错误。注意：无法捕获自身组件的错误哦！

返回值：
* 返回 false：阻止错误继续向上传播；
* 返回 true 或不返回：允许错误继续向上传播

```js
export default {
  errorCaptured(err, vm, info) {
    // 处理错误，vm指的是错误来源组件
    console.error('组件错误:', err, info)
    
    // 返回false阻止错误继续向上传播
    return false
  }
}
```

**2. 全局错误处理**  
通过app.config.errorHandler捕获整个应用的错误：
```js
const app = createApp(App)

app.config.errorHandler = (err, vm, info) => {
  // 处理错误，如发送到错误监控服务
  console.error('全局错误:', err, info)
}
```

## Vue中如何定义全局方法？
如：app.config.globalProperties、封装为插件、Mixin

需注意：**全局方法建议添加前缀**（如 $）以避免与组件内部方法冲突；组合式 API 中，**getCurrentInstance 仅在 setup 或生命周期钩子中可用**。对于大型项目，更推荐使用组合式函数（Composables）来复用逻辑，而非过度依赖全局方法

**1. app.config.globalProperties（最常用）**

```js
// 定义全局方法
app.config.globalProperties.$showMessage = function(text) {
    alert(`全局提示：${text}`)
}
```

选项式API中使用：
```js
this.$showMessage('欢迎使用全局方法')
```

组合式 API 中需通过 getCurrentInstance 获取：

```js
import { getCurrentInstance } from 'vue'

export default {
    setup() {
        const instance = getCurrentInstance()
        // 通过 proxy 访问全局方法（推荐）
        instance.proxy.$showMessage('组合式 API 中调用')
    }
}
```

2. 封装为插件（适合复杂功能）
```js
export default {
  install(app) {
    // 定义多个全局方法
    app.config.globalProperties.$log = function(message) {
      console.log('[全局日志]', message)
    }
  }
```

使用：
```js
import { createApp } from 'vue'

const app = createApp(App)
app.use(globalMethods) // 安装插件
```

3. 全局混入 Mixin，可能导致命名冲突，建议谨慎使用
```js
const app = createApp(App)

app.mixin({
  methods: {}
})
```
4. Vue 2 中，可以给 Vue.prototype 添加属性的方式定义全局方法


