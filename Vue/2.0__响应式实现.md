# 响应式实现

* 响应式数据的基本实现：读取属性时 副作用函数收集到桶里；设置属性时，将副作用函数从桶里取出并执行。
* 改善版：
  * 注入副作用函数，避免副作用硬编码：effect(fn)，然后将 fn 挂载到 activeEffect，执行fn()  触发属性的读取操作。
  * 针对特定属性，与副作用函数间建立联系，而不是所有属性中任何一个修改了  都要重新执行一次副作用函数。```WeakMap、Map 和 Set```
  * 分支切换与cleanup： 假设obj.ok初始值为true，```document.body.innerText = obj.ok ? obj.text : 'not'```，若将ok设为false呢？副作用函数 不应该被 obj.text的依赖集合 收集； 解决：**在每次副作用函数执行前，将它从与之关联的依赖集合中删除，等副作用函数重新执行后，再建立新的连接**
  * cleanup导致的循环执行：副作用函数执行时，将它从依赖集合中删除；但是它又会将自己重新被收集到依赖集合中； 解决：**遍历与新增、删除操作分别用不同的对象操作**
  * 嵌套的effect：原先的activeEffect只能有一个effect在执行；如果嵌套的话  内层的会覆盖掉 之前的值。解决：**副作用函数栈（Stack）,副作用函数执行时，入栈；执行完毕后出栈，activeEffect永远指向栈顶的副作用函数即可！**
  * get、set无限递归：```obj.foo = obj.foo + 1```,**trigger触发的副作用函数与当前正在执行的副作用如果相同的话，则不执行**。


## 一、基本知识
**1. 副作用：** effect 函数的执行会*直接或间接影响其他函数的执行，这时我们说 函数产生了副作用* 

**2. 副作用函数：** 会产生副作用的函数
```js
// 全局变量
let val = 1
function effect() {
  val = 2 // 修改全局变量，产生副作用
}
```

**3. 响应式数据**
```js
const obj = { text: 'hello world' }
// 副作用函数
function effect() {
  // effect 函数的执行会读取 obj.text
  document.body.innerText = obj.text
}
```

```js
obj.text = 'hello vue3' // 修改 obj.text 的值，同时希望副作用函数会重新执行
```

**当值变化后，副作用函数会自动重新执行，那么对象 obj 就是响应式数据**

## 二、响应式数据的基本实现
*拦截一个对象的读取和设置操作：*
* 当**读取字段 obj.text** 时，我们可以**把副作用函数effect 存储到一个“桶”里**
* 当**设置 obj.text** 时，再把**副作用函数 effect 从“桶”里取出并执行**即可

```js
// 存储副作用函数的桶
const bucket = new Set()
// 原始数据
const data = { text: 'hello world' }

// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 effect 添加到存储副作用函数的桶中
    bucket.add(effect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表设置操作成功
    return true
  }
})
```
简单测试一下：
```js
// 副作用函数
function effect() {
  document.body.innerText = obj.text
}
// 执行副作用函数，触发读取
effect()
// 1 秒后修改响应式数据
setTimeout(() => {
  obj.text = 'hello vue3'
}, 1000)
```

## 三、完善的响应式系统
在“响应式数据基本实现”中有几点可以优化的：
### 1. 副作用函数(effect)是硬编码，一旦名字写错，上述代码就工作不了了 
  > 解决：采用“注册副作用函数”机制！这样，不管副作用是匿名函数，还是别的，都能正常工作？？？

```js
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}
```

```js
effect(
  // 一个匿名的副作用函数
  () => {
    document.body.innerText = obj.text
  }
)
```
我们使用一个*匿名的副作用函数作为 effect 函数的参数*。当 effect 函数执行时，首先会把匿名的副作用函数 fn 赋值给全局变量 activeEffect。接着执行被注册的匿名副作用函数 fn，这将会触发响应式数据 obj.text的读取操作，进而触发代理对象 Proxy 的 get 拦截函数

```js
const obj = new Proxy(data, {
  get(target, key) {
    // 将 activeEffect 中存储的副作用函数收集到“桶”中
    if (activeEffect) {  // 新增
      bucket.add(activeEffect)  // 新增
    }  // 新增
    return target[key]
  },
  set(target, key, newVal) {
    target[key] = newVal
    bucket.forEach(fn => fn())
    return true
  }
})
```

### 2.针对特定属性，与副作用函数间建立联系，而不是所有属性中任何一个修改了  都要重新执行一次副作用函数。

如果一个副作用函数中读取了同一个对象的两个不同属性：
```js
effect(function effectFn() {
  obj.text1
  obj.text2
})
```
用 target 来表示一个代理对象所代理的原始对象，用 key 来表示被操作的字段名，用 effectFn 来表示被注册的副作用函数，那么可以为这三个角色建立如下关系：
```js
target
    └── text1
        └── effectFn
    └── text2
        └── effectFn
```
实现上述逻辑代码如下，首先，需要*使用 WeakMap 代替 Set 作为桶的数据结构*：
```js
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    track(target, key)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    trigger(target, key)
  }
})
// 在 get 拦截函数内调用 track 函数追踪变化
function track(target, key) {
  // 没有 activeEffect，直接 return
  if (!activeEffect) return
  let depsMap = bucket.get(target)
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  let deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  deps.add(activeEffect)
}
// 在 set 拦截函数内调用 trigger 函数触发变化
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  effects && effects.forEach(fn => fn())
}
```
从这段代码可以看出构建数据结构的方式，我们分别使用了 WeakMap、Map 和 Set：
* WeakMap 由 target --> Map 构成；
* Map 由 key --> Set 构成。

**为什么此处用WeakMap来存储target集合呢？**

```js
const map = new Map();
const weakmap = new WeakMap();

(function(){
    const foo = {foo: 1};
    const bar = {bar: 2};
    map.set(foo, 1);
    weakmap.set(bar, 2);
})()
```
 疑问❓：当该函数表达式执行完毕后，对于对象 foo 来说，它仍然作为 map 的 key 被引用着，因此垃圾回收器（grabage collector）不会把它从内存中移除，我们仍然可以通过 map.keys 打印出对象 foo。然而对于对象 bar来说，由于 WeakMap 的 key 是弱引用，它不影响垃圾回收器的工作，所以一旦表达式执行完毕，垃圾回收器就会把对象 bar 从内存中移除

## 四、分支切换与cleanup
```js
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, { /* ... */ })

effect(function effectFn() {
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```
在 effectFn 函数内部存在一个三元表达式，根据字段obj.ok 值的不同会执行不同的代码分支。当字段 obj.ok的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换。

### 1. 如三元表达式等  数据未读取时，不收集相关的依赖
**当字段 obj.ok 的值修改为 false**，并触发副作用函数重新执行后，*由于此时字段 obj.text 不会被读取，只会触发字段 obj.ok 的读取操作，所以理想情况下副作用函数 effectFn 不应该被字段 obj.text 所对应的依赖集合收集*

> 解决这个问题的思路很简单：
> * 每次副作用函数执行时，我们可以**先把它从所有与之关联的依赖集合中删除**。当副作用函数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数

在 effect 内部我们定义了新的 effectFn 函数，**并为其添加了effectFn.deps 属性，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合**：
```js
// 用一个全局变量存储被注册的副作用函数
let activeEffect
function effect(fn) {
  const effectFn = () => {
    // 调用 cleanup 函数完成清除工作
    cleanup(effectFn)  // TODO:新增
    // 当 effectFn 执行时，将其设置为当前激活的副作用函数
    activeEffect = effectFn
    fn()
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  effectFn()
}
```
 effectFn.deps 数组中的依赖集合是如何收集的呢？track()中：
 ```js
 function track(target, key) {
    /** ...  */
    // 将当前激活的副作用函数添加到依赖集合deps中
    deps.add(activeEffect)
    
    // deps就是一个与当前副作用函数存在联系的依赖集合 
    // 将其添加到activeEffect.deps数组中
    activeEffect.deps.push(deps)
}
```

cleanup()函数的实现：

```js
function cleanup(effectFn) {
  // 遍历 effectFn.deps 数组
  for (let i = 0; i < effectFn.deps.length; i++) {
    // deps 是依赖集合
    const deps = effectFn.deps[i]
    // 将 effectFn 从依赖集合中移除
    deps.delete(effectFn)
  }
  // 最后需要重置 effectFn.deps 数组
  effectFn.deps.length = 0
}
```
### 2. 解决循环执行问题
trigger函数中
```js
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  effects && effects.forEach(fn => fn()) // 问题出在这句代码
}
```
当副作用函数执行时，会调用 cleanup 进行清除，实际上就是从 effects 集合中将当前执行的副作用函数剔除，但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 effects 集合的遍历仍在进行。这个行为可以用如下简短的代码来表达：

具体案例及解决办法 参看：[set数据_删除又添加后循环执行](./code/set数据_删除又添加后循环执行.js)
```js
const set = new Set([1])

set.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log('遍历中')
})
```
解决如下：
```js
// 将遍历操作与新增、删除操作分别用不同的对象操作，即可避免无限循环
const set = new Set([1])
const newSet = new Set(set)

newSet.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log('遍历中')
})
```

## 五、嵌套的effect与effect栈
effect嵌套：
```js
effect(function effectFn1() {
  effect(function effectFn2() { /* ... */ })
  /* ... */
})
```
实际上Vue.js 的渲染函数就是在一个 effect 中执行的：

```js
// Foo 组件
const Foo = {
  render() {
    return /* ... */
  }
}
```

在一个 effect 中执行 Foo 组件的渲染函数：
```js
effect(() => {
  Foo.render()
})
```

组价嵌套：
```js
<FOO>
  <Bar></Bar>
</FOO>

// 相当于：
effect(() => {
  Foo.render()
  // 嵌套
  effect(() => {
    Bar.render()
  })
})
```
### 1. effect嵌套当前的问题：
> 用全局变量 activeEffect 来存储通过 effect 函数注册的副作用函数，这意味着同一时刻 activeEffect 所存储的副作用函数只能有一个。*当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 activeEffect 的值，并且永远不会恢复到原来的值*

### 2. 解决：  
> 解决这个问题，我们需要一个**副作用函数栈effectStack**，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。
```js
// 用一个全局变量存储当前激活的 effect 函数
let activeEffect
// effect 栈
const effectStack = []  // 新增

function effect(fn) {
  const effectFn = () => {
    cleanup(effectFn)
    // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect
    activeEffect = effectFn
    // 1. 在“调用副作用函数之前”将当前副作用函数压入栈中
    effectStack.push(effectFn)  // 新增
    fn()
    // 2. 在“当前副作用函数执行完毕后”，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值
    effectStack.pop()  // 新增
    // 3. 
    activeEffect = effectStack[effectStack.length - 1]  // 新增
  }
  // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}
```

## 六、避免无限递归循环
```js
const data = { foo: 1 }
const obj = new Proxy(data, { /*...*/ })

effect(() => obj.foo++)
```
在 effect 注册的副作用函数内有一个自增操作obj.foo++，该操作会引起栈溢出：
```js
Uncaught RangeError: Maximum call stack size exceeded
```
实际上，我们可以把 obj.foo++ 这个自增操作分开来看，它相当于：
```js
effect(() => {
  // 语句
  obj.foo = obj.foo + 1
})
```
在这个语句中，**既会读取 obj.foo 的值，又会设置obj.foo 的值**，而这就是导致问题的根本原因。

首先读取 obj.foo 的值，这会触发 track 操作，将当前副作用函数收集到“桶”中，接着将其加 1 后再赋值给 obj.foo，此时会触发 trigger操作，即把“桶”中的副作用函数取出并执行。但问题是该副作用函数正在执行中，还没有执行完毕，就要开始下一次的执行。这样会导致无限递归地调用自己，于是就产生了栈溢出。

### 解决：如果 *trigger 触发执行的副作用函数*与*当前正在执行的副作用函数*相同，则不触发执行
```js
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)

  // TODO:注意，此处代码与之前不同
  const effectsToRun = new Set()
  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行
    if (effectFn !== activeEffect) {  // 新增
      effectsToRun.add(effectFn)
    }
  })

  effectsToRun.forEach(effectFn => effectFn())
  // effects && effects.forEach(effectFn => effectFn())
}
```

## 七、调度执行
所谓**可调度**，指的是当 trigger 动作触发副作用函数重新执行时，有能力决定**副作用函数执行的时机、次数以及方式**。