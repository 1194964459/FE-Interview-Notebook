# Webpack中的核心对象

Webpack 是一个模块打包工具，它通过一系列核心对象来实现模块的加载、解析和打包等功能。以下是 Webpack 中一些重要的核心对象：

## 一、核心对象（5个）

### 1. Compiler（编译器对象）
Webpack 构建的**全局管理器**，是 Webpack 实例的核心，**整个构建流程仅存在一个 Compiler 实例**。

主要功能：
* 初始化配置（如 webpack.config.js 中的 entry、output、module 等）。
* 管理插件的注册与触发（通过 hooks 提供全生命周期钩子，如 run、compile、done）。
* 启动构建流程（**调用 run() 方法开始编译**），并维护构建的全局状态。


### 2. Compilation
Compilation 是 Compiler 的一个子对象，它**代表了一次具体的构建过程**。每次构建（如文件修改触发的重新构建）会生成一个新的 Compilation 实例。
主要作用：
* 管理模块（Module）的解析、转换（通过 Loader）和依赖分析。
* 管理代码块（Chunk）的创建、合并与拆分（如根据 splitChunks 配置生成 Chunk）。
* 提供构建过程中的钩子（如 moduleAsset、chunkAsset），供插件干预模块 / 代码块的处理。
* 最终生成待输出的资源（Assets，如 main.js、style.css）。

> 疑问❓：**何时会创建多个 Compilation 实例？**   
> 答：**只有当触发 “额外编译” 时，才会创建新的 Compilation 实例**，常见场景包括：
> * **文件变化触发的重新构建**（如 ```webpack --watch``` 或 ```开发服务器热更新```）：每次文件修改后，Webpack 会创建新的 Compilation 实例执行增量编译。
> * 插件主动创建**子编译**：某些插件（如 html-webpack-plugin）会为了处理特定资源（如 HTML 文件）而创建 “子 Compilation 实例”，与主 Compilation 实例独立。


### 3. Module（模块对象）
Webpack 处理的**最小代码单元**，对应项目中单个物理文件（如 .js、.css、.png 等）。

主要作用：
* 记录文件的路径、类型 和原始内容（如 javascript/auto、css）。
* *解析文件的依赖*，形成依赖树。
* 通过 Loader 对文件内容进行转换（如将 .ts 转为 .js、将 .scss 转为 .css）。

### 4. Chunk（代码块对象）
**多个 Module 的集合**，是 Webpack **从 “模块” 到 “最终输出文件” 的中间载体**。

主要作用：
* **按规则组合模块**（如入口文件及其依赖合并为一个 Chunk，或按 splitChunks 拆分公共模块为独立 Chunk）。
* 维护模块间的依赖关系，确保代码执行时依赖顺序正确。
* **最终会被转换为一个或多个输出资源（Assets）**，如 main.js、vendors~main.js。

### 5. Plugin（插件对象）
扩展 Webpack 功能的**核心机制**，**本身是具有 apply 方法的类或对象**。

主要作用：
* 通过注册 Compiler/Compilation 的钩子，干预构建流程（如优化代码、生成额外文件、修改资源内容）。
* 无固定功能边界，可实现多种需求（如 HtmlWebpackPlugin 生成 HTML、MiniCssExtractPlugin 提取 CSS 为文件）。

**工作原理**：插件通过 ```apply(compiler)``` 方法**注入到 Compiler 实例**，再通过 ```compiler.hooks``` 或 ```compilation.hooks``` 绑定钩子函数，在特定构建阶段执行逻辑。


## 二、核心对象的关联流程
初始化、启动构建、**模块**处理、**代码块**组合、**资源**生成、完成构建..

* **初始化**：执行 ```webpack()``` 时**创建 Compiler**，并加载配置、插件。
* **启动构建**：调用 ```compiler.run()```，触发 ```compile 钩子```，**创建 Compilation**。
* **模块处理**：Compilation 解析入口文件，**生成 Module**，并通过 Loader 转换模块内容、解析依赖。
* **代码块组合**：Compilation 根据依赖关系和配置，**将 Module 组合为 Chunk**。
* **资源生成**：Compilation **将 Chunk 转换为最终的输出资源（Assets）**。
* **完成构建**：触发```done 钩子```，输出资源到指定目录，构建结束。

## 三、Module 与 Chunk 的关系
两者关系如下：
* **模块（Module）** 是 Webpack 处理的最小单元，**对应项目中的单个文件**（如 index.js、style.css、image.png 等）。Webpack 会对每个模块进行加载、解析 (处理 import/require 依赖)、转换（基于 Loader）。
* **代码块（Chunk）** 是模块的集合，用于生成最终的输出文件。
* **一个“模块”可以属于多个“代码块”，一个“代码块”可以包含多个“模块”**。

**Wbpack 根据以下规则将模块合并为 chunk**：
* **默认规则**：*入口文件及其所有依赖的模块*会被合并为一个 chunk（通常名为 main）。
* **代码分割**：通过 splitChunks 配置、import() 动态导入等方式，将部分模块拆分到新的 chunk（如公共库 vendors、异步加载模块 async-chunk）。
* **输出文件**：**每个 chunk 最终会被转换为一个或多个输出文件**（如 main.js、vendors.8f2d.js）。

假设项目结构如下：

```
src/
├── index.js       # 入口文件，导入 a.js 和 b.js
├── a.js           # 导入 c.js
├── b.js
└── c.js
```
1. 模块（module）：Webpack 会解析出 4 个模块：index.js、a.js、b.js、c.js。   
2. 依赖关系：index.js → a.js → c.js；index.js → b.js。  
3. 代码块（chunk）：  
    * 若未配置代码分割，所有模块会被合并为一个 chunk（main），最终输出 main.js。
    * 若通过 splitChunks 将 node_modules 中的模块拆分，则可能生成两个 chunk：
        * main：包含 index.js、a.js、b.js、c.js（业务代码）。
        * vendors：包含从 node_modules 中引入的第三方库（如 react、lodash）。

