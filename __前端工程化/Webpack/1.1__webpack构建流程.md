# webpack 构建流程

[豆包：webpack详细的构建流程](https://www.doubao.com/thread/wb07df5c60ec3b669)

[webpack 4 源码主流程分析](https://juejin.cn/post/6844904047221145613)

[构建过程实现时，循环依赖怎么解决的？](./循环依赖解决.md)

编译（Compilation）与打包（Bundling）：
* 编译：将一种代码转换为另一种代码，核心是「代码转换」，通常是为了解决兼容性、语法特性的问题。如：Babel。
* 打包：将多个分散的模块（文件）合并为一个或多个「bundle」文件，核心是「资源整合」。如：Webpack、Rollup、Vite
    * 处理「模块依赖」：如：import/require，按依赖关系串联模块。
    * 优化资源：
        * 减少文件数量（降低 HTTP 请求次数）。
        * 压缩代码（去除空格、简化变量名）。
        * Tree-shaking（删除未使用的代码）。
        * 提取公共代码（避免重复打包）。


Webpack 本身不直接负责编译工作，它的核心功能是打包。不过它会通过Loader 整合编译能力，在打包过程中完成代码转换（编译）。

## 二、核心对象的关联流程
[webpack中的核心对象](./1.1__webpack中的核心对象.md)

[豆包：webpack更详细的构建流程， 与源码相结合](https://www.doubao.com/thread/wb07df5c60ec3b669)

[简易打包器制作，通俗易懂！！](https://juejin.cn/post/6893809205183479822#heading-14)

[基于Babel提取文件中的依赖](./code/基于Babel提取文件中的依赖.js)


> 初始化、启动构建、**模块**处理、**代码块**组合、**资源**生成、完成构建..

* **初始化**：执行 ```webpack()``` 时**创建 Compiler**，并加载配置、插件。
* **启动构建**：调用 ```compiler.run()```，触发 ```compile 钩子```，**创建 Compilation**。
* **模块处理**：触发```make钩子```, Compilation 解析入口文件，**生成 Module**，并通过 Loader 转换模块内容、解析依赖。
* **代码块组合**：Compilation 根据依赖关系和配置，**将 Module 组合为 Chunk**。
* **资源生成**：Compilation **将 Chunk 转换为最终的输出资源（Assets）**。
* **完成构建**：触发```done 钩子```，输出资源到指定目录，构建结束。
<br/><br/>

> 关于整个编译生命周期钩子，有如下：​
> * entry-option ：初始化 option​
> * run​
> * compile： 真正开始的编译，在创建 compilation 对象之前​
> * compilation ：生成好了 compilation 对象​
> * make：从 entry 开始递归分析依赖，准备对每个模块进行 build​
> * after-compile： 编译 build 过程结束​
> * emit ：在将内存中 assets 内容写到磁盘文件夹之前​
> * after-emit ：在将内存中 assets 内容写到磁盘文件夹之后​
> * done： 完成所有的编译过程​
> * failed： 编译失败的时候​
​
## Webpack 的构建流程
* **初始化**：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数​
* **编译构建**：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理​
* **输出**：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统

### 1. 初始化流程：
从配置文件和 Shell 语句中读取与合并参数，初始化需要使用的插件、配置*插件等执行环境*所需要的参数​

webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置的 plugins​

完成上述步骤之后，则开始初始化Compiler编译对象，该对象掌控者webpack生命周期，不执行具体的任务，只是进行一些调度工作​
​
```js
class Compiler extends Tapable {​
    constructor(context) {​
        super();​
        this.hooks = {​
            beforeCompile: new AsyncSeriesHook(["params"]),​
            compile: new SyncHook(["params"]),​
            afterCompile: new AsyncSeriesHook(["compilation"]),​
            make: new AsyncParallelHook(["compilation"]),​
            entryOption: new SyncBailHook(["context", "entry"])​
            // 定义了很多不同类型的钩子​
        };​
        // ...​
    }​
}​
​
function webpack(options) {​
  var compiler = new Compiler();​
  ...// 检查options,若watch字段为true,则开启watch线程​
  return compiler;​
}​
```
Compiler 对象继承自 Tapable，初始化时定义了很多钩子函数

### 2. 编译构建流程：
从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理​


### 3. 输出流程：
对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统

