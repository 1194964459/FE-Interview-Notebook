# Plugin
* 常见 Plugin 及使用方法

Webpack 的 Plugin 是**扩展 Webpack 功能的核心机制**，**通过钩子介入构建过程的各个阶段**（如打包优化、资源管理、环境配置等），**解决 loader 无法处理的复杂任务**（如资源管理、环境配置、优化等）

**核心原理**：基于发布 - 订阅模式，通过 compiler 和 compilation 对象提供的钩子实现自定义功能。


## 一、Plugin 是什么？
本质：Plugin 是一个**具有 apply 方法的 JavaScript 对象（或类）**，通过**在 Webpack 构建流程的特定阶段（钩子）注册回调函数**，介入构建过程并执行自定义逻辑，从而扩展或修改 Webpack 的默认行为。

作用：处理更复杂的构建任务，例如：
* 自动生成 HTML 文件（如 HtmlWebpackPlugin）
* 压缩打包后的资源（如 TerserPlugin）
* 清除输出目录（如 CleanWebpackPlugin）
* 注入环境变量（如 DefinePlugin）

> Webpack中的事件和钩子：
> * 事件和钩子在 Webpack 中本质相同，都是 “发布 - 订阅模式” 的实现，用于插件介入构建流程；  
> * 术语上更常用 “钩子”，因为它更贴合 Webpack 基于 tapable 的实现，也更准确描述 “在特定节点挂载逻辑” 的行为。   

## 二、工作流程
```注册插件 → 插件通过 apply 方法订阅钩子 → Webpack 触发钩子执行插件逻辑。```

参考：[Tapable及相关钩子](./3.1__Tapable及相关钩子.md)

1. 注册插件
在 Webpack 配置的 plugins 数组中注册，Webpack 会在**初始化时 读取并加载这些插件**。
```js
// webpack.config.js
const MyPlugin = require('./my-plugin');

module.exports = {
  plugins: [new MyPlugin(options)] // 实例化插件并传入配置
};
```

2. 插件通过 apply 方法**订阅钩子，注册回调** 
  > 注意：plugin 类的 apply 方法必须用普通函数，确保 this 指向插件实例。
```js
// my-plugin.js
class MyPlugin {
  constructor(options) {
    this.options = options; // 接收插件配置
  }

  // Webpack 会调用插件的 apply 方法，并传入 compiler 对象
  apply(compiler) {
    // 注册一个 "compile" 阶段的钩子（在编译开始时触发）
    compiler.hooks.compile.tap('MyPlugin', (params) => {
      console.log('编译开始了！');
    });
  }
}

module.exports = MyPlugin;
```

3. 触发钩子，执行插件自定义逻辑（如修改输出内容、打印日志）。


## 三、自定义插件 及 使用
**示例 1：使用 done 钩子输出构建信息**

done 钩子在构建完成后触发，可用于输出构建结果统计。

```js
// 自定义插件：BuildStatsPlugin.js
class BuildStatsPlugin {
  apply(compiler) {
    // 注册 done 钩子（同步钩子，使用 tap）
    compiler.hooks.done.tap('BuildStatsPlugin', (stats) => {
      console.log('构建完成！');
      console.log(`耗时：${stats.endTime - stats.startTime}ms`);
      console.log(`输出文件：${Object.keys(stats.compilation.assets).join(', ')}`);
    });
  }
}

module.exports = BuildStatsPlugin;
```

在 Webpack 配置中使用：
```js
// webpack.config.js
const BuildStatsPlugin = require('./BuildStatsPlugin');

module.exports = {
  // ...其他配置
  plugins: [
    new BuildStatsPlugin() // 实例化插件
  ]
};
```

**示例2：使用 emit 钩子添加额外文件**

**emit 钩子在资源输出到目录前触发，可用于动态添加文件**。

```js
// 自定义插件：AddExtraFilePlugin.js
class AddExtraFilePlugin {
  constructor(options) {
    this.filename = options.filename || 'extra.txt';
  }

  apply(compiler) {
    // 注册 emit 钩子（异步串行钩子，使用 tapAsync）
    compiler.hooks.emit.tapAsync(
      'AddExtraFilePlugin',
      (compilation, callback) => {
        // 向输出资源中添加一个文件
        compilation.assets[this.filename] = {
          source: () => '这是通过插件添加的额外内容', // 文件内容
          size: () => 24 // 内容长度（字节）
        };
        callback(); // 通知异步操作完成
      }
    );
  }
}

module.exports = AddExtraFilePlugin;
```
在 Webpack 配置中使用：

```js
// webpack.config.js
const AddExtraFilePlugin = require('./AddExtraFilePlugin');

module.exports = {
  // ...其他配置
  plugins: [
    new AddExtraFilePlugin({ filename: 'info.txt' }) // 自定义文件名
  ]
};
```

## 常见的 Plugin
define-plugin：定义环境变量​，是一个webpack内置的插件，不需要安装

html-webpack-plugin：在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的 js 模块引⼊到该 html 中
```js
// webpack.config.js​
const HtmlWebpackPlugin = require("html-webpack-plugin");​
module.exports = {​
 ...​
  plugins: [​
     new HtmlWebpackPlugin({​
       title: "My App",​
       filename: "app.html",​   // 指定生成的 HTML 文件的名称。
       template: "./src/html/index.html"​  // 指定 用于生成 HTML 文件的模板文件路径。
     }) ​ 
  ]​
};
```

## 常见插件
**内置插件**：
* IgnorePlugin：忽略指定模块的导入，不将其打包到输出文件中。
* **DefinePlugin**：在编译时定义全局常量，代码中可直接使用这些常量，无需显式导入。   

  在浏览器环境中，如果没有经过构建工具（如 Webpack、Vite 等）处理，直接运行这段代码会报错，因为浏览器原生环境中没有 process 对象。
  ```js
  if (process.env.NODE_ENV === 'development') {
    console.log('开发环境');
  } else {
    console.log('生产环境');
  }
  ```
  经过构建工具（如 **Webpack 配合 DefinePlugin、Vite** 等）处理过的代码，在编译阶段将代码中的 process.env.NODE_ENV 替换为实际的环境值（如 "development" 或 "production"）。这样就不会报错了。

* **HotModuleReplacementPlugin**：用于开发环境的热模块替换（HMR），修改代码后无需刷新页面即可更新效果，提升开发效率。
* **TerserWebpackPlugin**（Webpack 5 已内置）：压缩JS代码，支持删除注释、简化代码、tree-shaking 等优化。
* **ProvidePlugin**：自动导入模块依赖，解决 “重复手动导入” 问题。
  ```js
  const { ProvidePlugin } = require('webpack');

  module.exports = {
    plugins: [
      new ProvidePlugin({
        $: 'jquery',
        _: 'lodash'
      })
    ]
  };
  ```
  这样，代码中如果需要引用 jquery、lodash的函数啥的，就不用重新导入了；Webpack 在打包时会自动导入
  ```js
  // webpack打包时自动导入的
  import _ from 'lodash';

  // app.js 原有的代码逻辑
  const filteredArray = _.filter([1, 2, 3], num => num > 1);
  ```
其他插件：
* webpack-bundle-analyzer: 可视化分析打包后的代码体积，帮助识别大文件或重复依赖
* mini-css-extract-plugin: 将 CSS 代码从 JS 中提取出来，生成独立的 CSS 文件（代替 style-loader 内嵌样式）
* clean-webpack-plugin​：在每次打包前自动清理输出目录（如 dist 文件夹），避免旧文件残留。
* copy-webpack-plugin​：复制文件或目录到执行区域，适用于不需要编译处理的文件。
  > 如vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中
* HtmlWebpackPlugin：自动生成 HTML 文件，并将打包后的 JS/CSS 自动引入到 HTML 中，
  > 这2个有兼容性问题，且停止维护了，是webpack4中常用的，目前已被 TerserWebpackPlugin取代：  
  > uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码​  
  > webpack-parallel-uglify-plugin: 多核压缩,提高压缩速度​  
