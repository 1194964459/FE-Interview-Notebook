# 如何提高 Webpack 构建速度？

> webpack版本升级、每个新版本基本都有一些性能优化  
> loader限制范围（include、exclude）、  
> 打包范围缩小(resolve, 后缀及模块查找路径modules)、  
> 缓存（Babel缓存、webpack缓存）  
> DllPlugin：第三方库预先打包，没变化时不需要...  
> 多进程/多实例构建：thread-loader  
> 开发环境优化：sourceMap、禁用生产环境相关特性（tree shaking、压缩）  
> 生产环境优化：代码分离、esbuild-loader(基于Go) 代替 babel-loader(基于JS)  


以下是一些常用的方法：
* **升级Webpack版本**： 确保使用的是最新版本的Webpack，因为每个新版本都可能包含一些性能优化。​
* **使用DllPlugin**： 使用 ```DllPlugin``` 和 ```DllReferencePlugin``` 来**将第三方库的代码预先打包，以减少构建时间**。这样就可以将这些库的代码从主要的构建中分离出来，并在它们*没有发生变化时不需要重新构建*。​
  > 为什么需要DLL?
  > * 第三方库通常很少变动、每次全量构建时需要重复处理这些库 会浪费大量时间
  > * DLL 技术会将 React、Vue等第三方库 提前打包成独立的动态链接库，后续构建只需直接引用即可。

  通过 webpack.DllPlugin 和 webpack.DllReferencePlugin 两个插件配合实现，注意：第三方库更新时，需重新生成 DLL。     
    * DllPlugin：预打包第三方库生成 DLL 文件和映射关系
    * DllReferencePlugin：在主构建中引用已生成的 DLL

* **使用缓存**： 
```webpack.cache、babel-loader.cacheDirectory``` 都可以利用缓存提高rebuild效率  
  （1）启用Webpack的缓存，以便在后续构建中重复使用之前的结果。cache：true
  ```js
  module.exports = {​
    // webpack.config.js文件
    cache: true,​  // 内存缓存：等价于 { type: 'memory' }, 单次构建内的模块复用 构建结束后消失

    cache: {   // 文件系统缓存，也称”持久化缓存“，持久化到磁盘
      type: 'filesystem' 
    }	
  };​
  ```
  （2）Babel中启用缓存
  ```js
  {
      loader: 'babel-loader',
          options: {
            cacheDirectory: true,​
          },
  }
  ```

* **多进程/多实例构建**：使用```thread-loader```为耗时 loader 开启多进程，充分利用**多核处理器**的优势。比较适合CPU 密集型的 Loader 任务（如 Babel 转译、TypeScript 编译）。
  > HappyPack：weppack v4 中与thread-loader类似功能的一个插件
* **减小打包范围**： 在Webpack配置中指定 resolve 的 modules 和 extensions，以减小Webpack在文件系统中搜索文件的范围，适用于 monorepo 项目。
  * 配置resolve.modules，减少模块查找层级（默认会向上级目录递归查找 node_modules）。
  * 使用resolve.extensions，限制文件后缀尝试范围（配置后导入模块时可省略后缀，webpack会按配置的顺序依次查找））。
  * 使用noParse排除不需要解析的库

  ```js
  // resolve：用于设置模块解析规则
  resolve: {
      modules: ['node_modules'],   // 模块查找目录，
      extensions: ['.js', '.jsx', '.json'],​   // 自动解析的文件后缀，
  },
  module: {
    noParse: /lodash|react\.production\.min\.js/ // 不解析指定库
  }
  ```

  > 疑问❓：resolve.modules 为什么会配置为”node_modules“？
  > 1. 第三方依赖的默认存放目录： npm install 或 yarn add 安装依赖时，都会放到该目录下...   
  > 2. webpack 与 Node.js 模块查找规范保持一致，当查找一个模块时，会从当前目录的 node_modules 开始，逐级向上级目录递归查找，直到找到模块或到达系统根目录。配置 ```modules: ['node_modules'] 会让 Webpack 优先在项目根目录的 node_modules 中查找，避免不必要的上级目录递归```，提升查找效率。

<br/>

* **限制loader处理范围**：使用```include 和 exclude```限制 loader 处理范围

* **开发环境优化**
  * 使用```eval-cheap-module-source-map```作为 **devtool**
    > eval：使用 eval 来包裹模块，构建速度快（直接是字符串，不需要文件读取、解析啥的），但运行时性能差（eval的代码通常不会被浏览器的JIT（Just-In-Time）编译器优化）  
    > cheap：生成的 Source Map 只包含行信息，不包含列信息（生成快、但调试精度略低）    
    > module：确保 Source Map 映射到**原始模块的代码**，**而不是经过 Loader 处理后的代码**    
  * **禁用生产环境特性**：如 ```tree-shaking、代码压缩```
  * 使用```webpack-dev-server```或```webpack-dev-middleware```实现**热更新**
    > 可以间接提升构建速度：在代码发生改变时，*只重新编译发生变化的模块*，而不是对整个项目进行全量重新构建。

* **生产环境构建优化**
  * 合理使用 **splitChunks 代码分离技术** 拆分代码
    > **合理拆分代码**可以将公共代码（如第三方库）提取出来单独打包。后续如果这些代码没变化的话 就不需要重新编译啥的；另外拆分后的代码在浏览器端可以缓存下来，用户再次访问页面时 不需要传输这块相关代码。
  * 考虑使用 ```esbuild-loader``` 替代 ```babel-loader``` **提升转译速度**
    > esbuild 是用 Go 语言编写的打包工具，转译速度更快。

* **Webpack性能分析**： 使用Webpack-Bundle-Analyzer等工具来分析你的构建输出，找出体积较大的模块，以便进一步优化。


## 代码分离 与 DLL 比较下

代码分离（Code Splitting）和 DLL（Dynamic Link Library）确实有相似之处 —— 它们**都通过拆分代码来优化构建或运行效率**

| 维度	| 代码分离（Code Splitting）	| DLL（Dynamic Link Library）| 
| ---- | ---- | ---- |
| 核心目标| 	优化**运行时性能**（**减小初始加载体积**，实现按需加载）	| **优化构建速度**（避免第三方库重复编译）| 
| 拆分对象| 	主要**拆分业务代码（按路由、组件、功能拆分）**| 	只**拆分稳定的第三方库（如 react、lodash）**| 
| 构建时机| 	**每次构建都会执行拆分逻辑**	| 预打包（**首次手动执行，后续复用**，依赖更新时才重新打包）| 
| 使用场景| 	**生产环境为主**（提升用户体验）	| **开发环境为主**（提升开发者体验）| 
| 依赖变化敏感性	| 随业务代码变化自动重新拆分 | 	依赖版本不变则不重新打包 | 