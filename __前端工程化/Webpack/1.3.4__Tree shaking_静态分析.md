# 静态分析 为什么可以找到”未被引用的代码“？

静态分析能找到未被引用的代码，本质是因为：

* 它能**解析代码结构（通过 AST）**，*明确识别变量、函数的声明与引用关系*；
* 配合**静态模块系统（如 ES6 模块）的确定性**，构建**完整的***依赖图谱*；
* 通过**追踪导入导出关系**，**精准标记** “*从未被引用” 的代码片段*。


### 1. 静态分析能解析代码的 “语法结构” 和 “依赖关系”
静态分析工具（如 Webpack、Rollup 的分析器）会先将源代码解析为抽象语法树（AST）。AST 能清晰展示代码的语法结构：变量声明、函数定义、导入导出语句、调用关系等。
```js
// 模块A：export.js
export const a = 1;
export const b = 2;

// 模块B：import.js
import { a } from './export';
console.log(a);
```
静态分析工具通过 AST 可以明确识别：

* 模块 A 导出了a和b两个变量；
* 模块 B 只导入了a，并在console.log中使用了a；
* b被导出后，从未被任何模块导入或使用。

### 2. 依赖于 “静态模块系统” 的确定性

静态分析能准确追踪 “未被引用的代码”，**关键前提是代码使用了静态模块系统（如 ES6 的import/export）**。这类模块系统的依赖关系是 “**编译时确定的**”，而非 “运行时动态生成的”，具体表现为：

* 导入导出语句只能出现在模块顶层（不能嵌套在条件语句、函数中）；
* 导入的模块路径和变量名是*固定的字符串*（不能是动态计算的结果）。

动态模块系统（如 CommonJS 的require）则无法被静态分析准确追踪，因为它的依赖关系可能在运行时才确定：
```js
const module = require(`./${getModuleName()}`); 
```

### 3. 基于 “引用追踪” 标记未使用代码
静态分析工具会通过以下步骤标记未被引用的代码：

* **收集所有 “导出成员”**：遍历所有模块，记录每个模块导出的变量、函数、类等（如export const a = ...中的a）。
* **追踪 “导入引用”**：遍历所有导入语句（如import { a } from ...），记录每个导出成员被哪些模块引用。
* **标记 “无引用的导出”**：在依赖图谱中，若某个导出成员*从未出现在任何导入语句中*，或*导入后从未被使用*（如import { a } from ...但后续代码中没有a的调用），则被标记为 “未被引用的代码”。


### 4. 排除 “有副作用的代码”
静态分析还会结合 “副作用检测”，避免误删有意义的代码。（如修改全局变量、注册事件）：
```js
// 有副作用的代码（即使未被引用，也不能删除）
window.globalConfig = { debug: true };
```
