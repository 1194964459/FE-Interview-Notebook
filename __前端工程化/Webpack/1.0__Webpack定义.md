# Webpack 
Webpack 是一个静态模块打包工具，用于将前端项目中的各种资源（JavaScript、CSS、图片、HTML 等）视为 “模块”，并通过依赖分析将这些模块打包成浏览器可直接运行的静态资源。

其核心功能包括：
* 模块解析：处理不同类型的文件（通过 Loader）
* 依赖管理：分析模块间的依赖关系，形成依赖树
* 打包优化：代码分割、压缩、Tree-shaking 等
* 扩展机制：通过 Plugin 扩展功能，覆盖整个构建生命周期

Webpack 的**工作流程**是*基于事件流的，从初始化配置到最终输出文件，会经历一系列有序的阶段*（如编译、优化、输出等），**这些阶段通过钩子（Hook）暴露给外部，供 Plugin 介入**。

参考：[webpack的核心对象及关系](./1.1__webpack中的核心对象.md)

## 一、Webpack 5
Webpack 5 于 2020 年 10 月发布，是目前的最新稳定大版本，带来了多项重要改进，包括：

* 内置持久化缓存提升构建性能
* 改进的树摇（Tree Shaking）机制
* 更好的代码分割策略
* 模块联邦（Module Federation）支持
* 优化的输出内容（更简洁的代码）
* 对 Node.js polyfill 的调整（默认不再自动包含）

## 二、持久化缓存
将**构建结果缓存到磁盘**，在后续构建中复用缓存，减少重复计算，提升构建速度。

在 Webpack 配置文件中，通过 cache 字段进行配置：
```js
const path = require('path');

module.exports = {
  // 其他配置...
  cache: {
    type: 'filesystem', // 缓存类型，使用文件系统缓存，目前还支持'memory'，但'memory'缓存仅在内存中，不会持久化
    buildDependencies: {
      config: [__filename], // 当配置文件（如webpack.config.js）变化时，缓存失效
      // 也可以添加其他会影响构建的文件，比如自定义的构建脚本等
      // 'your-custom-build-file.js': true 
    },
    cacheDirectory: path.resolve(__dirname, 'node_modules/.cache/webpack'), // 缓存目录，可自定义，建议放在node_modules/.cache下，方便管理且避免意外删除
    // 以下是一些可选配置
    // name: 'your-cache-name', // 缓存名称，方便区分不同项目或构建环境的缓存
    // store: undefined, // 自定义缓存存储方式，一般使用默认即可
    // version: '1.0', // 缓存版本号，手动指定版本，版本不同时缓存会失效
    // allowCollect: true, // 是否允许在构建结束时清理未使用的缓存数据，默认true
  },
  // 其余配置项，如entry、output、module、plugins等...
};
```
cache若为true，是内存缓存。等价于 ```{ type: 'memory' }```, 单次构建内的模块复用 构建结束后消失
```js
module.exports = {​
  cache: true,​ 
}
```

* 首次构建：将**中间结果和最终构建结果**按照一定规则存储到指定的缓存目录   
* 后续构建：会查找缓存目录中的数据，
  * 对于**没有变化的模块**，直接从缓存中读取处理结果，跳过解析、转换等耗时操作；只对**发生变化的模块**进行重新处理。   
  * Webpack 通过对比*文件的修改时间、内容哈希值*等方式来判断模块是否发生变化。
* 出现以下几种情况，**缓存将会失效**：
  * **配置文件发生变化**（```buildDependencies.config 中指定的文件```），比如修改了 webpack.config.js 中的配置项。
  * 手动修改了**缓存版本号**（version 配置项）。
  * **缓存目录被删除**或损坏。

## 三、代码分离（Code Splitting）
代码分离可以分出出更小的bundle，以及控制资源加载优先级，之后我们可以**按需加载**，或者并行加载，减少初次加载的 bundle 体积，充分利用浏览器缓存啥的。

> 背景：默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度​。

优势：
* **减小初始加载的 bundle 体积**，提升首屏加载速度
* 实现资源的**并行加载**，提高加载效率
* **利用浏览器缓存**，已加载的代码无需重复下载
* **便于维护和迭代**，不同模块可独立更新

应用场景：
* **代码拆分**：将代码按**路由**维度或者**组件**分块(chunk)，这样做到*按需加载，同时可以充分利用浏览器缓存*​。
* **库分离**：将第三方库（如 React、Lodash）与业务代码分离
* **条件加载**：根据用户交互或环境动态加载代码

### 实现方法：
* 入口起点：配置多入口手动分离代码
```js
// webpack.config.js
module.exports = {
  entry: {
    index: './src/index.js',
    another: './src/another.js'
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
}
```
* 动态导入：通过 ES6 的 import() 语法实现按需加载（返回 Promise）
* **SplitChunksPlugin**： Webpack 内置的代码分割插件（Webpack 4+ 已内置，无需额外安装），用于自动提取代码中可共享的部分（如公共模块、第三方库），生成独立的 chunk 文件，避免代码重复打包，优化加载性能。

其默认配置如下：
```js
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'async',   // 只对异步加载的chunk生效
      
      // 包的体积应该在（minSize, maxSize）之间，体积小于minSize的不会拆，大于maxSize的会被拆
      minSize: 20000,  // 最小体积
      maxSize: xx, // 最大体积，
      
      minChunks: 1, // 被引用次数

      minRemainingSize: 0,
      maxAsyncRequests: 30,  // 异步加载时最大并行请求数
      maxInitialRequests: 30,  // 初始加载时最大并行请求数
      enforceSizeThreshold: 50000,
      cacheGroups: {   // 缓存组：定义不同的拆分规则；该属性内的键值可以自定义！
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,  // 匹配node_modules中的模块
          priority: -10,  // 优先级（数值越大越优先）
          reuseExistingChunk: true,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,  // 复用已存在的chunk
        },
      },
    },
  },
};
```
chunks：指定对哪些类型的 chunk 生效
* async：仅异步 chunk（默认）
* initial：仅初始 chunk
* all：所有类型的 chunk（推荐）