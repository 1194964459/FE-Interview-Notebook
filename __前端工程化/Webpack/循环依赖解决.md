# 循环依赖解决

JavaScript 中，对象（包括模块的 exports 对象）是**引用类型**—— 当一个对象被赋值给多个变量时，这些变量指向的是**同一块内存地址**

require()返回的是module.exports的值，是一个引用类型！

webpack在解析一个模块时，会首先创建一个空对象，并给该模块标记状态为“未完成”！
解析模块时，发现依赖了之前解析过的某个模块（可能没解析完），这时候被依赖的模块不会重新再解析了，而是返回module.exports，即一个空对象！这是个引用类型，与

以 “A→B→A” 的循环依赖为例：
解析 A 时，Webpack 会先创建一个空对象 A.exports = {}，并标记 A 为 “未完成状态”；
解析 A 的过程中*发现依赖 B，于是开始解析 B*；
解析 B 时发现依赖 A，此时 Webpack *直接返回 A 已创建的空对象 A.exports*（**而非重新解析 A，避免死循环**）；



在解析模块B

```js
// A.js
import B from './B.js';
export const a = 1;
export const getB = () => B.b; // 延迟使用 B 的内容

// B.js
import A from './A.js';
export const b = 2;
export const getA = () => A.a; // 延迟使用 A 的内容
```

解析 B 模块：
创建 B.exports = {}（空对象，标记 B 为 “未完成”）；
解析到 import A from './A.js'，此时 A 未完成，返回 A.exports（空对象）；
B 继续执行：```export const b = 2``` → ```B.exports.b = 2;```
```export const getA = () => A.a```→ ```B.exports.getA 是一个函数，引用的 A 是 A.exports（当前为空，但指向内存地址 X）;```
B 解析完成，标记为 “已完成”。