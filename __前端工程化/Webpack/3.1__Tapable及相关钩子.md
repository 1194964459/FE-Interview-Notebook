# Plugin内的相关钩子
参考：  
[事件循环](../../JS/事件/event-loop.md)    
[webpack的 Tapable](https://www.webpackjs.com/api/plugins/#tapable)


Tapable **定义了一套灵活的 “钩子（Hook）” 机制**，是**Webpack 插件系统的底层实现基础**。Webpack 的 Compiler、Compilation 对象，或者自定义插件，都依赖 Tapable 提供的钩子类型和注册/触发能力。

### Tapable 的核心定位
**Tapable 的本质是一个 “事件订阅 - 发布” 系统**，但比普通事件系统更强大：

* 支持**多种执行模式**（同步/异步串行/异步并行）；
* 支持**流程中断**（如 SyncBailHook 可提前终止）；
* 支持**钩子优先级**（通过 stage 控制执行顺序）。

Webpack 通过 **Tapable 将构建流程拆分为多个 “钩子节点”，插件通过 “注册钩子” 介入流程**，实现自定义功能（如代码压缩、资源优化等）。

### 常用钩子示例场景
* **在输出前添加版权信息** → 使用 emit 钩子修改文件内容
* **统计构建时间** → 在 compile 和 done 钩子记录时间差
* **自定义模块解析** → 使用 normalModuleFactory 钩子
* **构建失败报警** → 使用 failed 钩子发送通知

## 钩子类型	
| 钩子类型 | 钩子表示方法 | 注册回调(tap) | 触发钩子（call） | 语法格式 | 
|  ----  | ----  | ---- | ---- | ---- |
| 同步钩子 | Sync*Hook | tap | call| ```hook.tap(pluginName, (params) => { ... })``` | 
| 异步串行钩子 | AsyncSeries*Hook | tapAsync、tapPromise  | callAsync、promise  |  ```hook.tapAsync(pluginName, (params, callback) => { ...; callback(); })；```<br/> ```需调用 callback() 通知完成```<br/><br/> ```hook.tapPromise(pluginName, (params) => new Promise(resolve => { ... }))；```<br/>```需 resolve() 通知完成```  <br/> <br/> ```callAsync(...args, finalCallback)：触发异步钩子，所有回调完成后执行 finalCallback；```| 
| 异步并行钩子 | AsyncParallel*Hook | tapAsync、tapPromise  | callAsync、promise  | 

疑问❓：tapAsync 注册的回调可以用promise来触发哈？   
答：是的。Tapable 内部会统一封装不同注册方式的回调，无论用 tapAsync 还是 tapPromise 注册，都可以用 promise() 触发并获得一个 Promise 对象。(tapAsync与callAsync、tapPromise与promise并不是一对一的关系)
* **tapAsync 注册的回调**：Tapable 会将其包装为一个 Promise（当 callback() 被调用时，Promise 会 resolve；当 callback(err) 传递错误时，Promise 会 reject）。
* **tapPromise 注册的回调**：直接使用其返回的 Promise，无需额外处理。

### （一）同步钩子（5种）
| 钩子类型 | 核心特点 | 适用场景| 
|  ----  | ----  | ---- | 
| **SyncHook** | 同步串行，执行所有回调，无返回值 |	基础通知（如 Webpack 的 compile 钩子）| 
| **SyncBailHook** | 同步串行，**返回非 undefined 则中断**	|**条件验证**（如 Webpack 的 entryOption 钩子）| 
| **SyncWaterfallHook**|	同步串行，**前一个回调返回值作为后一个入参** | 数据流水线处理（如参数传递、数据加工）| 
| **SyncLoopHook** | 同步串行，**回调返回 true 则重复执行当前回调** | 	循环重试（如模块构建失败重试）| 
| **SyncHookWithOptions** |	支持传递 options 参数，其他同 SyncHook	| 需要额外配置的同步场景（较少用）| 


示例：SyncBailHook（可中断）

```js
const { SyncBailHook } = require('tapable');

// 1. 创建钩子（指定回调入参名称）
const hook = new SyncBailHook(['param']);

// 2. 注册回调（按顺序执行）
hook.tap('Plugin1', (param) => {
  console.log('Plugin1 执行，param:', param);
  return undefined; // 不中断，继续执行下一个
});

hook.tap('Plugin2', (param) => {
  console.log('Plugin2 执行，param:', param);
  return 'stop'; // 返回非 undefined，中断后续回调
});

hook.tap('Plugin3', (param) => {
  console.log('Plugin3 执行'); // 不会执行
});

// 3. 触发钩子（传递参数）
hook.call('test'); 
// 输出：
// Plugin1 执行，param: test
// Plugin2 执行，param: test
```

### （二）异步钩子（5 种）
 支持异步操作（回调/Promise），按 “串行” 或 “并行” 执行。|

| 钩子类型|	核心特点	|适用场景| 
|  ----  | ----  | ---- | 
| **AsyncSeriesHook** |	异步串行，**前一个回调完成后执行下一个**	|依赖顺序的异步操作（如 Webpack 的 emit 钩子）| 
| **AsyncSeriesBailHook** |	异步串行，**回调返回非 undefined 则中断** |	异步条件验证（如异步权限检查）| 
| **AsyncSeriesWaterfallHook**	|异步串行，**前一个回调返回值作为后一个入参**	|异步数据流水线（如异步参数加工）| 
| **AsyncParallelHook**	|异步并行，**所有回调同时执行，等待全部完成** |	无依赖的异步操作（如多模块并行构建）| 
| **AsyncParallelBailHook**	|异步并行，**任意回调返回非 undefined 则中断所有** |	快速失败场景（如多源资源加载，一个失败则终止）| 

 
示例：AsyncSeriesHook（异步串行） 

```js
const { AsyncSeriesHook } = require('tapable');

// 1. 创建钩子
const hook = new AsyncSeriesHook(['param']);

// 2. 注册异步回调（tapAsync）
hook.tapAsync('Plugin1', (param, callback) => {
  setTimeout(() => {
    console.log('Plugin1 执行，param:', param);
    callback(); // 通知完成，执行下一个
  }, 1000);
});

// 注册 Promise 回调（tapPromise）
hook.tapPromise('Plugin2', (param) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log('Plugin2 执行，param:', param);
      resolve(); // 通知完成，流程结束
    }, 1000);
  });
});

// 3. 触发钩子（callAsync，最终的回调）
hook.callAsync('test', () => {
  console.log('所有异步回调执行完成');
});
// 输出（间隔 1 秒）：
// Plugin1 执行，param: test
// Plugin2 执行，param: test
// 所有异步回调执行完成
```

## webpack 4 和 webpack5 在构建过程中具体都有哪些钩子？
参考：   
[webpack 5中的 Compiler钩子](https://webpack.js.org/api/compiler-hooks/) ，(源码：查看 compiler.js 和 compilation.js 中 hooks 对象的定义)

[不同钩子的参数获取](https://webpack.js.org/api/compiler-hooks/)，（如 done 钩子接收 stats 对象，compilation 钩子接收 compilation 对象）

Webpack 5 新增钩子的核心变化
* **initialize**：**Compiler 实例初始化后**触发。插件最早介入时机，便于插件初始化基础数据结构。
* **afterCompile**：**编译完成后**触发，方便处理编译后的缓存或清理工作，配合持久化缓存使用。
* **processAssets**：替代 optimizeAssets，支持多阶段资源处理（如 PROCESS_ASSETS_STAGE_OPTIMIZE 优化阶段、PROCESS_ASSETS_STAGE_SUMMARIZE 总结阶段），更精细地控制资源操作时机。TODO:

Webpack 4 被移除的钩子：
* optimizeTree：优化模块树/Chunk 树，如移除未使用的代码，优化代码分割等； Webpack 5 中该钩子已被移除，功能合并到其他优化钩子。
    > 比如，Webpack 5 提供了更强大的optimizeModules和optimizeChunks钩子，以及新的processAssets钩子		
* optimizeAssets：优化资源时，被 Webpack 5 的 processAssets 替代。

接下来，分别列出 Webpack 5 中不同阶段的各种钩子：

### 1. 初始化阶段（Compiler 初始化）
| 钩子名称|	类型|	触发时机|用途|
|  ----  |  ---- | ---- | ---- | 
| **initialize** |	SyncHook|	Compiler 实例初始化后|	插件最早介入时机，初始化基础数据|
| **environment**|	SyncHook|	环境配置（如 Node 环境）准备完成	|配置环境变量、注册全局工具|
| afterEnvironment| SyncHook	|环境配置完全初始化后	|读取最终环境配置|
	

### 2. 配置处理阶段
| 钩子名称 | 类型| 	触发时机 |	用途| 
|  ----  |  ---- | ---- | ---- | 
| entryOption| 	SyncBailHook| 	**入口配置处理**（entry）时触发	| 动态修改入口配置，返回非 undefined 可终止默认处理| 
| **afterPlugins**	| SyncHook| 	所有**插件(Plugin)完成初始化**，并将插件注册到 Compiler 对象之后触发| 	插件间依赖处理| 
| **afterResolvers**| 	SyncHook| 	**解析器（resolver）初始化**后，解析器用于解析模块的路径	| 自定义模块解析规则，如设置别名、调整解析顺序| 

### 构建启动阶段
| 钩子名称 | 类型| 	触发时机 |	用途| 
|  ----  |  ---- | ---- | ---- | 
| **beforeRun** |AsyncSeriesHook |compiler.run() 调用后，run 钩子执行前。 |  构建开始前的最后准备（如确认资源目录存在）。 | 
| **run** | AsyncSeriesHook | 正式开始构建流程（compile 之前），<br/>当调用 compiler.run() 方法后，**Webpack 开始执行构建流程的最早期阶段**。 | 记录构建开始时间（用于统计总耗时）、<br/>构建前的准备工作（如检查环境、清理缓存目录）、<br/>动态修改全局配置（如根据环境变量调整 entry 或 output）。| 


run 钩子的参数：仅传递 compiler 实例本身，便于插件访问全局配置。与其他核心钩子的顺序关系：
```
compiler.hooks.initialize → （初始化完成）
→ compiler.hooks.run → （开始构建）
→ compiler.hooks.compile → （准备创建 Compilation）
→ compiler.hooks.thisCompilation / compilation → （Compilation 实例创建）
→ ...（模块解析、优化、输出等后续流程）
```
使用 run 钩子记录构建开始时间：
```js
class BuildTimePlugin {
  apply(compiler) {
    let startTime;
    
    // 注册 run 钩子，记录开始时间
    compiler.hooks.run.tapAsync('BuildTimePlugin', (compiler, callback) => {
      startTime = Date.now();
      console.log('构建开始...');
      callback(); // 通知异步操作完成
    });
    
    // 注册 done 钩子，计算总耗时
    compiler.hooks.done.tap('BuildTimePlugin', () => {
      const totalTime = Date.now() - startTime;
      console.log(`构建完成，总耗时：${totalTime}ms`);
    });
  }
}
```


### 3. 编译阶段（Compilation 创建）
| 钩子名称|	类型	|触发时机 |	用途|
|  ----  |  ---- | ---- | ---- | 
| **beforeCompile** <br/>(编译准备阶段)| AsyncSeriesHook|	准备创建 Compilation 实例 前（compile 钩子之前） | 修改编译参数（如调整 compilationParams）、准备编译所需资源 | 
| **compile** <br/>(编译准备阶段)|	SyncHook|	开始创建 Compilation 实例 时	| 直接干预 Compilation 的创建过程。如调整模块解析规则、禁用某些默认优化|
| **thisCompilation** <br/>(编译执行)|	SyncHook|	**当前 Compiler 直接创建的 “主编译” 实例（**Compilation**）初始化完成后**	| **仅对主编译注册钩子**（不涉及子编译）|
| **compilation** <br/>(编译执行)	|SyncHook|	**任何 Compilation 实例创建完成后（包括主编译、子编译）**	| **对所有编译实例注册钩子**（核心钩子，**最常用**，如全局资源优化）|
| **make**|	AsyncParallelHook（**Compilation**）|	**Compilation 开始解析入口模块、构建依赖树时** |	动态添加额外模块（如按需加载模块）|
| **afterCompile** |SyncHook|	Compilation 完成模块解析、优化后|	编译后**清理临时资源、编译结果缓存处理**|

<br/>

如：compilation钩子，在Compilation 实例创建完成后触发，入参是compilation（当前编译实例）。最常用的钩子之一，可访问编译过程中的模块、依赖等：
```js
compiler.hooks.compilation.tap('MyPlugin', (compilation) => {
  // 注册 Compilation 阶段的子钩子
  compilation.hooks.chunkAsset.tap('MyPlugin', (chunk, filename) => {
    console.log(`生成 chunk 文件: ${filename}`);
  });
});
```
### 4. 模块处理阶段
| 钩子名称 | 类型| 	触发时机| 	用途| 
|  ----  |  ---- | ---- | ---- | 
| normalModuleFactory| 	SyncHook	| NormalModuleFactory 创建后| 	自定义普通模块（如 JS/CSS）的解析规则| 
| contextModuleFactory	| SyncHook| 	ContextModuleFactory 创建后| 	处理动态导入（如 require.context）| 
| module| 	SyncHook（**Compilation**）| 	模块创建后| 	修改模块信息（如标记模块类型、过滤模块）| 
| buildModule	| SyncHook（**Compilation**）| 	模块开始构建前	| 调整模块构建参数| 
| succeedModule| 	SyncHook（**Compilation**）	| 模块构建成功后	| 记录模块构建结果| 

### 5. 优化阶段
| 钩子名称|	类型|	触发时机|	用途| 
|  ----  |  ---- | ---- | ---- | 
| **optimize**|	SyncHook（**Compilation**）|	优化阶段开始前|	准备优化配置| 
| **optimizeModules**|	SyncBailHook（**Compilation**）|	优化模块时	|Tree-shaking、模块合并| 
| **optimizeChunks**|	SyncBailHook（**Compilation**）|	优化 Chunk 时|	代码分割、Chunk 合并| 

### 6. 资源输出阶段
emit 钩子最常用！ 以下 5 项是按照顺序触发的。

| 钩子名称	|类型	|触发时机|	用途| 
|  ----  |  ---- | ---- | ---- | 
| **processAssets**	|AsyncSeriesHook（**Compilation**）|	资源处理阶段（多阶段，如压缩、优化） |Webpack 5 新增，精细化处理资源（如添加注释、压缩、生成清单）| 
| chunkAsset |	SyncHook（**Compilation**） |	代码块（Chunk）生成输出资源时	| 记录代码块与输出文件的映射关系 | 
| **shouldEmit**|	SyncBailHook|	**决定是否输出资源前**	|**返回 false 可阻止资源输出**| 
| **emit**|	AsyncSeriesHook|	资源输出到目录前|	Webpack 4 中**修改资源**的主要钩子；Webpack 5 中部分场景被 processAssets 替代| 
| **afterEmit**|	AsyncSeriesHook	|资源输出到目录后|	输出完成后操作（如**部署**、**通知**）| 


### 7. 构建完成/失败阶段
| 钩子名称| 	类型| 	触发时机| 	用途| 
|  ----  |  ---- | ---- | ---- | 
| **done**	| SyncHook	| 构建完全结束后| 	**输出构建统计（如耗时、错误数）、上报构建结果**| 
| failed	| SyncHook| 	构建失败时| 	错误监控、自定义错误提示| 
| invalid| 	SyncHook	| 文件变化触发重新编译时（开发模式）| 监听文件变更事件|


## Compiler 与 Compilation 
* **Compiler**：**Webpack 全局唯一的构建实例**，贯穿整个构建生命周期（从启动到结束），其钩子（如 run、done）控制全局流程。
* **Compilation**：**单次编译的实例（每次构建或重新构建都会创建一个新的 Compilation）**，负责具体的模块处理、依赖分析、优化、资源生成等工作，其钩子聚焦于编译细节。

“属于 Compilation 阶段的钩子” 本质是 Compilation 对象上的 hooks 属性，只能通过 ```compiler.hooks.compilation 等钩子间接注册```（因为 Compilation 实例在构建过程中动态创建）。而```Compiler 钩子 直接通过 compiler.hooks 注册```。	

如何使用 Compilation 阶段的钩子？如下：

```js
class HookOrderPlugin {
  apply(compiler) {
    // 1. 注册 chunkAsset（Compilation 阶段）
    compiler.hooks.compilation.tap('HookOrderPlugin', (compilation) => {
      compilation.hooks.chunkAsset.tap('HookOrderPlugin', (chunk, asset) => {
        console.log('1. 触发 chunkAsset：', `chunk=${chunk.name} → asset=${asset}`);
      });
    });

    // 2. 注册 emit（Compiler 阶段）
    compiler.hooks.emit.tap('HookOrderPlugin', (compilation) => {
      console.log('2. 触发 emit：即将写入资源到磁盘');
    });
  }
}

module.exports = HookOrderPlugin;
```