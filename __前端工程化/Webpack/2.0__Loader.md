# Loader
参考：

[基于this.async()，实现一个自定义的异步 Loader](./code/实现一个自定义loader/webpack.config.js)

[由浅及深实现一个自定义loader](https://juejin.cn/post/6903856764018982925)


Webpack 本身只能处理 JavaScript 和 JSON 文件，Loader 的作用是将其他类型的文件（如 .css、.ts、.png 等）转换为有效的模块，供 Webpack 进一步处理或打包。

**Loader 本质是一个函数**，接收源文件内容作为参数，返回转换后的内容（或处理后的结果）。

## 一、基本特性
**1. 链式调用**  
多个 Loader 可以串联使用，前一个 Loader 的输出作为后一个 Loader 的输入。按**从右到左（或从下到上） 的顺序执行**。 

```js
use: ['style-loader', 'css-loader', 'less-loader']
```
执行顺序：less-loader（将 Less 转 CSS）→ css-loader（解析 CSS 模块）→ style-loader（将 CSS 注入 DOM）。

**2. 支持异步操作**   
如读取文件、网络请求，必须通过 this.async() 实现。

this.async() 会返回一个 callback 函数，当异步操作结束后，需调用该函数通知 Webpack，并传递处理结果。如：

```js
// 异步 Loader 示例：延迟处理代码
module.exports = function(source) {
  // 1. 调用 this.async() 进入异步模式，获取回调函数
  const callback = this.async();
  
  // 2. 执行异步操作（如定时器、文件读取等）
  setTimeout(() => {
    // 3. 处理源文件（示例：在代码前添加注释）
    const result = `/* 异步处理后的代码 */\n${source}`;
    
    // 4. 调用回调函数，通知 Webpack 异步操作完成
    // 第一个参数：错误信息（null 表示无错误）
    // 后续参数：处理后的结果（如转换后的代码、sourceMap 等）
    callback(null, result);
  }, 1000);
};
```
需注意📢：
* 必须调用回调函数：调用 this.async() 后，必须在异步操作结束时执行返回的 callback，否则 Webpack 会一直等待，导致构建卡住。
* callback 的参数格式：
    * err：错误对象（无错误时传 null）
    * content：处理后的代码内容（必填）
```js
callback(err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any)
```
* 避免多次调用：一个 Loader 中 this.async() 只能调用一次，多次调用会导致错误。
* 与同步 Loader 的区别：
    * 同步 Loader 直接返回处理结果（return content）。
    * 异步 Loader 不能返回结果，必须通过 callback 传递。


[基于this.async()，实现一个自定义的异步 Loader](./code/实现一个自定义loader/webpack.config.js)

## 二、使用方式
Loader 在 Webpack 配置的 module.rules 中定义，通过 test 匹配文件类型，use 指定使用的 Loader，通过use中的options 为 Loader **传递参数**

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/, // 匹配所有 .css 文件
        include: path.resolve(__dirname, 'src'), // 只处理 src 目录下的 .ts 文件
        exclude: /node_modules/, // 排除 node_modules
        use: ['style-loader', 
             {
                loader: 'css-loader',
                options: { modules: true } // 启用 CSS Modules
             }
        ]
      }
    ]
  }
};
```

## 三、常见 Loader
### 1. 处理样式文件的Loader
* style-loader：将css添加到DOM中（通过```<style>```） 
    > 注意：生产环境建议用 ```MiniCssExtractPlugin.loader``` 替代，将 CSS 提取为独立文件。
* css-loader：解析 CSS 文件中的 @import 和 url() 语法，将 CSS 转换为模块。关键参数：
    * modules: true：启用 CSS Modules，避免样式冲突。
* less-loader: 处理less，​需安装对应预处理器 Less
* sass-loader: 处理sass​，​需安装对应预处理器 Sass
* postcss-loader: 通过 PostCSS 处理 CSS（如自动添加浏览器前缀、转换 CSS 新特性），需配合 postcss.config.js 一起来配置。

```js
rules: [
  {
    test: /\.less$/,
    use: [
      'style-loader', // 注入到 DOM
      'css-loader',   // 解析 CSS 模块
      'postcss-loader', // 自动加前缀等
      'less-loader'   // 转换 Less 为 CSS
    ]
  }
]
```
### 2. 处理图片/字体等资源的 Loader
* file-loader：将文件复制到输出目录，并返回文件的访问路径（适用于大图片、字体等）。
* url-loader：将**小文件（如图片、字体）转换为 DataURL**（Base64 编码），减少 HTTP 请求；**大文件则自动调用 file-loader 输出为单独文件**。关键参数：
    * limit: 8192：文件大小阈值（单位字节），小于该值转 Base64。
    * name: ```'assets/[name].[hash:8].[ext]'```：输出文件路径和名称。

注意：Webpack 5 已内置 ```asset/resource``` 类型替代 file-loader，```asset/inline```替代 url-loader。

### 3. 处理 JS/TS 的 Loader
* babel-loader：通过 Babel 将 ES6+ 语法转换为 ES5，兼容旧浏览器。
    * 需安装 @babel/core、@babel/preset-env 等核心包。
    * 通过 .babelrc 定义转换规则。
```JS
rules: [
  {
    test: /\.js$/,
    exclude: /node_modules/,
    use: {
      loader: 'babel-loader',
      options: {
        presets: ['@babel/preset-env'] // 转换 ES6+ 语法
      }
    }
  }
]
```
* ts-loader：将 TS 转为 JS，需配合 tsconfig.json 配置。

### 4. 其他Loader
* eslint-loader：在打包过程中执行 ESLint 检查，提前发现**代码规范问题**，**Webpack 5 推荐使用 eslint-webpack-plugin 替代**
* vue-loader：解析 Vue 单文件组件（.vue），分离模板、脚本和样式。
* html-loader：将 HTML 文件转换为字符串，支持解析其中的 img 标签路径。
* html-minify-loader: 压缩HTML​，用 html-webpack-plugin 替代，直接使用其 minify 配置：
```js
new HtmlWebpackPlugin({
  template: './src/index.html',
  minify: {
    collapseWhitespace: true,
    removeComments: true
  }
})
```
