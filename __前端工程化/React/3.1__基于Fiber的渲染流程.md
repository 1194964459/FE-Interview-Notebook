# 基于 Fiber 的渲染过程

参考：  
[基于Fiber的Diff算法](https://cloud.tencent.com/developer/article/2159927)

[Fiber详解](./3.0__Fiber详解.md)

Fiber节点，本质是```虚拟DOM信息 + 调度控制信息```，每个 Fiber 节点对应一个 React 元素（如 div、自定义组件）。参考：[Fiber节点](./4.1__Fiber节点_虚拟DOM节点.md)

### 一、渲染流程 (简化版)  
从 “状态更新触发” 到 “真实 DOM 变化” 的完整流程，包含3个步骤(后2个是核心阶段)：
* 调度（Scheduler）：
    * 核心任务：对更新任务进行**优先级排序**，决定何时执行协调阶段。
    * 通过 requestIdleCallback 或自定义调度器（如Scheduler）监听主线程空闲状态，优先处理高优先级任务。

* 协调（Reconciliation）：
    * 特性：**异步可中断**，可被高优先级任务暂停，下次恢复时从上次中断的 Fiber 节点继续执行。
    * 核心任务：
        * 构建 WorkInProgress Fiber 树
        * 执行 Diff 算法对比新旧节点差异
        * 标记 “副作用”（如新增/删除/修改 DOM：Placement/Deletion/Update）。
* 提交（Commit）：
    * 特性：**同步不可中断**，需一次性完成 DOM 操作，避免页面闪烁。
    * 核心任务：
        * 将协调阶段标记的 “副作用” 同步应用到真实 DOM（如插入新节点、删除旧节点），
        * 并执行生命周期钩子（如 useEffect、componentDidMount）。
        * 切换 Fiber 树

### 基于Fiber的渲染流程核心逻辑
| 阶段|	核心目标|	执行特性	|关键操作|
| ---- | ----| ----| ----| 
| 调度阶段 | 任务优先级排序与时机判断|	异步调度	|任务入队、监听主线程空闲、触发协调阶段 |
| 协调阶段 | 找出差异并标记副作用	|异步可中断	|生成 WorkInProgress 树、Fiber 树 Diff、标记副作用（Placement/Update/Deletion）|
| 提交阶段 | 将副作用应用到真实DOM	| 同步不可中断	| 执行 DOM 增删改、触发生命周期/Effect 钩子、切换 Fiber 树|


## 二、渲染流程（详细版）
从 状态变更 触发更新 到 页面DOM更新

setState、useState 触发更新后，就会进入**调度、协调、提交**三个核心步骤，具体流程如下：

### 阶段 1：任务触发与调度（Scheduler）
当组件状态更新后，React 不会立即开始渲染，而是先通过 Scheduler（调度器）对任务进行 “优先级排序”，决定何时执行该任务。

* 根据任务的紧急程度，任务**按优先级分类**（从高到低）：
    * Immediate：同步执行（如 flushSync）
    * UserBlocking：用户交互（点击、输入）
    * Normal：普通更新（如数据渲染）
    * Low：低优先级（如后台计算）
    * Idle：空闲时执行（如统计上报）
* **任务入队**与**调度判断**：
    * Scheduler 将待执行的任务加入“任务队列”，并通过 requestIdleCallback 或 setTimeout 向浏览器请求执行时间。当主线程空闲且当前任务优先级最高时，调度器会触发协调阶段。

### 阶段 2：协调阶段（Reconciliation）—— 异步可中断
「纯计算阶段」，不操作真实 DOM

协调阶段的核心是 **“Diff 算法” 的异步化执行**：通过遍历 Fiber树（链表遍历），对比新旧组件的 type 和 props，找出需要更新、新增或删除的 Fiber 节点，并为这些节点**标记对应的“副作用”**（如 ```Placement 新增、Update 更新、Deletion 删除```）。

由于采用链表遍历（而非传统栈遍历），React 可以在遍历过程中随时中断（如遇到更高优先级任务），下次恢复时直接从上次中断的 Fiber 节点继续执行，无需重新遍历整个树。

**1. 生成 WorkInProgress Fiber 树：**  
React 维护两棵 Fiber 树（**双缓存机制**）：
* **Current 树**：当前页面已渲染的 Fiber 树，与真实DOM一一对应；
* **WorkInProgress树**：正在协调中的 “**临时 Fiber 树**”，基于 Current Fiber 树复制生成（通过 alternate 属性关联两棵树）。
协调阶段的所有 Diff 操作都在 WorkInProgress 树上进行，避免直接修改 Current 树导致页面不稳定。  

**2. Fiber 树遍历与 Diff：**  
从根 Fiber 节点开始，按 “深度优先 + 链表遍历” 顺序（```先处理当前节点 → 再处理子节点 → 最后处理兄弟节点```）遍历 WorkInProgress 树，对每个节点执行以下操作：
* **步骤 1：对比新旧节点**
    * 若当前节点的 type 相同，则复用该节点，仅对比 props 差异，标记 ```“Update” 副作用```；
    * 若 type 不同，则标记当前节点及所有子节点为```“Deletion” 副作用```，并创建新的 Fiber 节点替代，标记 ```“Placement” 副作用```。

* **步骤 2：处理子节点 Diff**
    对组件的子节点，React 采用 “**key 优化**” 的 Diff 策略：通过子节点的 key 快速匹配新旧子节点，减少不必要的删除和重建。

* **步骤 3：标记副作用**
    将需要操作的 Fiber 节点（如新增、更新、删除）加入 **“副作用链表”（effectList）**，供后续提交阶段使用。   

**3. 任务中断与恢复：**
在遍历过程中，React 会定期检查主线程状态：
* 若主线程空闲且无更高优先级任务，继续遍历下一个 Fiber 节点；
* 若主线程繁忙（如处理用户输入、动画）或有更高优先级任务，立即中断遍历，并保存当前中断的 Fiber 节点（nextUnitOfWork）；
* 待主线程再次空闲时，调度器会重新触发协调阶段，从 nextUnitOfWork 节点继续遍历。   

参考：[Fiber树遍历时考虑“时间片”](./4.2__Fiber详解.md)

**4. 协调阶段结束：**
当*整个 WorkInProgress Fiber 树遍历完成，且所有差异都标记完成*后，协调阶段结束，React 会将 “副作用链表”（effectList）传递给**提交阶段**。

### 阶段 3：提交阶段（Commit）—— 同步不可中断
核心任务：
* 将协调阶段标记的 “副作用” 同步应用到真实 DOM（如插入新节点、删除旧节点），
* 并执行生命周期钩子（如 useEffect、componentDidMount）。

由于此阶段直接操作真实 DOM，为避免页面闪烁或状态不一致，提交阶段是**同步不可中断**的，必须一次性执行完成。

具体步骤如下：  
**1. 执行删除操作（Deletion）**：  
先处理 “副作用链表” 中标记为 “Deletion” 的节点：
* 移除对应的真实 DOM 节点；
* 执行组件的卸载钩子（如 componentWillUnmount、useEffect 的清理函数）。 

**2. 执行新增/移动操作（Placement）**：  
处理标记为 “Placement” 的节点：
* 根据 WorkInProgress 树的结构，将新增的真实 DOM 节点插入到正确的位置；
* 若节点需要移动（如列表子节点顺序变化），通过 DOM 操作调整节点位置。 

**3. 执行更新操作（Update）**：  
处理标记为 “Update” 的节点：
* 将协调阶段计算出的 props 差异应用到真实 DOM（如修改 className、style、事件绑定）；
* 对于自定义组件，执行更新相关的生命周期钩子（如 componentDidUpdate）或 useEffect 回调（非清理函数）。

**4. 切换 Fiber 树**：   
提交阶段完成后，React 将 Current Fiber 树 指向 WorkInProgress Fiber 树，此时 WorkInProgress 树成为新的 Current 树，与当前页面的真实 DOM 完全同步。


## 四、React Fiber和传统的React渲染机制 对比
| 维度|	传统渲染机制（栈协调）|	React Fiber|
| ---- |---- |---- 
| 数据结构	|调用栈（递归）|	链表（Fiber 节点 + 指针）|
| 渲染过程	|单阶段、同步、不可中断|	两阶段（调度 + 提交）、可中断、可恢复|
| 优先级控制|	无优先级，按顺序执行	|有调度器，支持多优先级任务|
| 主线程占用|	长时间独占，可能阻塞用户交互|	分块执行，空闲时工作，不阻塞高优先级任务|
| 生命周期兼容性	|旧生命周期安全（只执行一次）|	旧生命周期可能多次执行（已废弃部分）|
| 适用场景	|小型应用、简单 UI	|大型应用、复杂动画、交互密集型场景|

传统渲染机制：基于**调用栈（Stack）**实现组件树遍历，渲染过程是**同步、不可中断**的，一旦开始对比虚拟 DOM 并更新真实 DOM，就必须执行到底，若组件树庞大，会阻塞浏览器的主线程（导致页面卡顿、交互延迟）。

引入Fiber后，由于 “调度阶段可中断并重复执行”，部分生命周期方法可能被多次调用，导致副作用逻辑（如重复发请求）出错。
