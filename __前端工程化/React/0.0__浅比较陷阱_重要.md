# 浅比较“陷阱”
参考：[React中的不可变数据原则](./0.0__不可变数据原则.md)

基本类型比较值，引用类型比较地址！

React中期待的是：**无论是基本、引用类型，当两者的值相同时，就不要更新**。

对于引用类型的值来说，由于**比较的是引用地址 而非 内部值**，然后导致组件误判状态是否变化，进而引发“不更新”或“无效更新”的问题。
* 误更新：传递新对象（内容相同但引用不同）时，浅比较认为 “变化”，触发不必要的重渲染。
* 不更新：修改对象内部属性（引用不变）时，浅比较认为 “未变化”，导致组件不更新。

```js
// 两个对象内容相同但引用不同，浅比较认为“不同”
const obj1 = { name: "Alice" };
const obj2 = { name: "Alice" };
console.log(obj1 === obj2); // false

// 同一对象修改内部属性，引用不变，浅比较认为“相同”
obj1.age = 20;
console.log(obj1 === obj1); // true（引用未变）
```
## 一、函数组件的解决方案
函数组件主要通过 useState 的更新逻辑配合**不可变数据原则**，结合 **useMemo 缓存引用**，避免浅比较陷阱

参考：[不可变数据原则](./0.0__不可变数据原则.md)

1. 解决 “不更新” 问题：修改引用类型时返回新引用
```js
const UserComponent = () => {
  // 初始化对象类型状态
  const [user, setUser] = useState({ name: "Alice", age: 20 });

  const handleAgeIncrease = () => {
    // 错误：直接修改原对象（引用不变，浅比较认为未变化）
    // user.age += 1; 
    // setUser(user); // 组件不会更新

    // 正确：返回新对象（引用变化，浅比较能感知）
    setUser(prevUser => ({
      ...prevUser, // 复制旧对象的所有属性
      age: prevUser.age + 1 // 更新目标属性
    }));
  };

  return <div>Age: {user.age}</div>;
};
```

2. 解决 “误更新” 问题：用 useMemo 缓存引用，useCallback（缓存函数），或者提取为常量（函数组件外）   

当引用类型作为 props 传递给被 React.memo 包装的子组件时，**若内容未变但引用变化，会导致子组件误更新**。此时需用 useMemo 缓存引用，确保内容不变时引用也不变。

参考：[函数组件“误更新”解决方案](./1.0.1__函数式组件_误更新解决.md)

```js
// 父组件
const Parent = () => {
  const [count, setCount] = useState(0);

  // 用 useMemo 缓存对象（内容不变时，引用不变）
  const user = useMemo(() => ({ name: "Alice" }), []); 

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} /> {/* user 引用不变，Child 不会误更新 */}
    </div>
  );
};

// 子组件（用 React.memo 包装，浅比较 props）
const Child = React.memo(({ user }) => {
 ...
});
```

## 二、类组件的解决方案
类组件通过 setState 的更新逻辑和不可变数据原则，结合 ```React.PureComponent``` 或```自定义 shouldComponentUpdate```处理浅比较陷阱。

1. 解决 “不更新” 问题：修改引用类型时返回新引用   

与函数组件同理
```js
class UserComponent extends React.Component {
  state = { user: { name: "Alice", age: 20 } };

  handleAgeIncrease = () => {
    // 错误：直接修改原对象（引用不变，浅比较认为未变化）
    // this.state.user.age += 1;
    // this.setState({ user: this.state.user }); // 组件不会更新

    // 正确：返回新对象（引用变化，浅比较能感知）
    this.setState(prevState => ({
      user: { ...prevState.user, age: prevState.user.age + 1 }
    }));
  };

  render() {
    return <div>Age: {this.state.user.age}</div>;
  }
}
```

2. 解决 “误更新” 问题：优化 shouldComponentUpdate 逻辑
* 自定义 shouldComponentUpdate 时：可实现深比较逻辑（谨慎使用，性能开销较大）。可同时比较 props 和 state
    * 它返回 true（默认）表示需要重渲染，
    * 返回 false 表示跳过本次重渲染。
* 使用 React.PureComponent 时：类组件的优化版本，浅比较！内部实现了具有*浅比较逻辑的 shouldComponentUpdate 方法*，**只有当 props 和 state 都没“浅变化”，才不渲染**，否则，就会重新渲染。

## 总结
| 组件类型|	解决 “不更新” 问题（内部状态）|	解决 “误更新” 问题（传递给子组件）|
| ---- | ---- | ---- | 
| 函数组件|	用 setX(prev => ({ ...prev, ... })) 返回新引用	| 用 useMemo 缓存引用， useCallback 缓存函数 确保内容不变时引用不变|
| 类组件|	用 setState(prev => ({ ...prev, ... })) 返回新引用	|自定义 shouldComponentUpdate 实现深比较，或确保传递的引用不变|