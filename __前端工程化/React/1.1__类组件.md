# 类组件
特点：
* **继承自 React.Component**：必须通过 extends 关键字继承，否则无法使用 React 提供的功能。
* 通过 **this.state 管理状态**：状态**需在 constructor 中初始化**，通过 this.setState() 更新（自动触发重渲染）。
* 生命周期方法：提供如 ```componentDidMount（挂载后）、componentDidUpdate（更新后）、componentWillUnmount（卸载前）```等方法，用于处理副作用和组件生命周期逻辑。
* **this 绑定问题**：类中的自定义方法默认不绑定 this，**需通过箭头函数或 bind 手动绑定，否则调用时 this 会指向 undefined**。
* props 通过 this.props 访问：父组件传递的属性通过 this.props 获取，且不可直接修改（只读）。

```js
import React from 'react';

// 继承 React.Component
class ClassComponent extends React.Component {
  // 初始化状态
  constructor(props) {
    super(props); // 必须调用 super 传递 props

    // 法1：state 初始化
    this.state = { 
        count: 0, // 数字类型
        user: { name: 'Alice', age: 20 }, // 对象类型
        list: [1, 2, 3] // 数组类型
     };
  }

  // 法2：state的第二种初始化方式   
  // state = { count: 0 };

  // 自定义方法（需绑定 this 或使用箭头函数）
  handleClick = () => {
    // 更新状态
    this.setState({ count: this.state.count + 1 });
  };

  // 生命周期方法：组件挂载后执行
  componentDidMount() {
    console.log('组件已挂载');
  }

  // 渲染 JSX
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>加1</button>
      </div>
    );
  }
}

export default ClassComponent;
```

## setState
语法格式：
```js
// 第一个参数为 对象
setState([newState, callback])  // callback中可获取到更新后的值

// 第一个参数为 函数
setState(prev => newState, [callback])
```

注意事项📢：
1. 必须通过 this.setState() 方法更新状态(直接修改 this.state 不会触发组件重渲染)
2. 异步 
    * 如何拿到更新后的值呢？需使用第二个参数（回调函数）：
      ```js
      this.setState({ count: 1 }, () => {
        console.log('更新后的值：', this.state.count); // 正确获取最新值
      });
      ```

    * 依赖旧状态更新（参数是函数）

        React 会将多个连续的 setState 调用批量处理（而非立即执行），合并后只触发一次组件重渲染，以此优化性能。

      示例：连续调用3次setState
      ```js
      // 错误：对象式更新可能因批量处理导致只加 1（而非 2）
      this.setState({ count: this.state.count + 1 });
      this.setState({ count: this.state.count + 1 });

      // 正确：函数式更新，通过 prevState 拿到最新值，确保逻辑合并
      this.setState(prevState => ({ count: prevState.count + 1 }));
      this.setState(prevState => ({ count: prevState.count + 1 }));
      // 合并后 count 最终加 2（两次更新逻辑生效）
      ```

3. 自动合并状态：   
注意：自动合并的仅仅是顶层属性，深层属性不会自动合并（直接覆盖）    

示例：假设组件初始状态为 { name: "Alice", age: 20, info: { city: "Beijing" } }：
```js
// 1. 连续调用对象式 setState
this.setState({ age: 21 }); // 只更新 age
this.setState({ name: "Alicia" }); // 只更新 name

// React 合并后，最终状态为：
// { name: "Alicia", age: 21, info: { city: "Beijing" } }（浅合并顶层属性）

// 2. 注意：深层属性不会自动合并
this.setState({ info: { job: "Engineer" } }); 
// 合并后 info 会被覆盖，变为 { job: "Engineer" }（原 city 丢失）
```

## setState使用时需注意：
参考：[渲染与副作用 详细区分下](./3.1__副作用.md)

React 组件的原则：渲染与副作用分离！

setState是副作用，应该避免在渲染中执行。如：getDerivedStateFromProps → shouldComponentUpdate → render

* **避免在 render 中调用 setState，会导致无限循环**：```render → setState → 触发重渲染 → 再次 render```。
* **不允许在纯函数（无副作用）中使用setState****：如getDerivedStateFromProps、shouldComponentUpdate，setState会破坏器纯性。**
* 推荐在副作用生命周期中使用：componentDidMount、componentDidUpdate，但需注意添加条件判断避免无限循环。

## 性能优化
通过 shouldComponentUpdate 或 React.PureComponent


## 副作用：
使用生命周期方法（componentDidMount 等）

