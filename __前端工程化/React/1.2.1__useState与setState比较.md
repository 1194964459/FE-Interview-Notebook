# useState与setState比较（函数式组件、类组件中的状态）

在 React 中，useState（函数组件）和 this.state（类组件）都是用于管理组件状态的方式。

### 初始化
* 类组件中状态（this.state）：在 constructor 中初始化，并且所有状态集中在一个对象中。
* 函数式组件中的状态：useState函数调用，返回 ```[状态, 更新函数]```, 可声明多个独立状态变量.

### 初始值的特殊性
* this.state：在 constructor 中初始化，**仅执行一次**，后续渲染不会重复执行。
* useState的初始值：
    * 何时生效？ 仅在组件首次渲染时生效
    * 初始值如果需要基于一个函数获取的，这个函数是每次组件渲染 都会执行？还是仅仅首次执行？
```js
// 每次渲染时getInitialValue都会执行，但仅首次使用其返回值
const [count, setCount] = useState(getInitialValue());

// 优化：用函数形式延迟计算（仅首次执行）
const [count, setCount] = useState(() => getInitialValue());
```

### 状态更新方式
一、共同点：  
1. 两者都要求**状态不可直接修改**，必须通过更新函数（setCount 或 setState）触发重新渲染：
```js
// 错误：直接修改不会触发重渲染
count = count + 1; // useState
this.state.count = this.state.count + 1; // 类组件
```

2. 若依赖旧值，才能计算新值，传入的参数必须得是个函数！ 
```js
setCount(prevCount => prevCount + 1);  // 函数组件

this.setState(prevState => ({   // 类组件 
  count: prevState.count + 1
}));
```

3. 都是异步更新的，因此不能在更新后立即获取最新值  
React 会将多个连续的 setState 或 useState 调用批量处理（而非立即执行），合并后只触发一次组件重渲染，以此优化性能。
```js
// useState
setCount(1);
console.log(count); // 仍为旧值（0）

// 类组件
this.setState({ count: 1 });
console.log(this.state.count); // 仍为旧值（0）
```

解决方式：依赖更新后的逻辑需放在更新函数的回调或 useEffect 中：
```js
// useState：用useEffect监听变化
useEffect(() => {
  console.log("最新count:", count);
}, [count]);

// 类组件：setState的第二个参数（回调）
this.setState({ count: 1 }, () => {
  console.log("最新count:", this.state.count);
});
```

二、不同点：
* useState 的更新函数不会自动合并状态，后面设置的会直接覆盖掉之前的。如果状态是对象、数组，需要手动合并：
```js
const [user, setUser] = useState({ name: "", age: 0 });

// 错误：会覆盖原有属性，导致丢失name
setUser({ age: 18 }); 

// 正确：手动合并
setUser(prev => ({ ...prev, age: 18 }));
```

* this.setState 更新状态时，会自动合并对象中的状态属性：
```js
// 直接传新值（自动合并）
this.setState({ age: 18 }); // 仅更新age，保留name
```
* 若 “状态值不变” 时，两者触发渲染的 逻辑是不一样的：
  * setState会重复触发，
  * useState只触发一次 后面值相同的话 不会再触发了   

  原因：**useState 内部做了一层浅比较优化**：如果新状态与旧状态相同（```bject.is(newValue, oldValue)```），则不会触发重新渲染，以此提升性能。
