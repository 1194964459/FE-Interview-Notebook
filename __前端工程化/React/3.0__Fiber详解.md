# Fiber

Fiber出现以前，React 使用 “**栈(Stack)协调器**”：渲染过程是**同步、不可中断**的，一旦开始对比虚拟 DOM 并更新真实 DOM，就必须执行到底，若组件树庞大，会阻塞浏览器的主线程（导致页面卡顿、交互延迟）。

Fiber 是 React 16 引入的**链表型数据结构**，Fiber节点与组件是一一对应的，Fiber节点中包含以下核心信息：
* 组件类型（type）、属性（props）、状态（stateNode）；
* 调度优先级（priority）、过期时间（expirationTime）；
* 链表指针（return/child/sibling），用于异步遍历组件树；
    * return：指向父节点
    * child：第一个子节点
    * sibling：当前节点的下一个兄弟节点
* 双缓存引用（alternate），连接 “当前渲染树（Current Tree）” 和 “工作树（WorkInProgress Tree）”。

参考：[Fiber节点结构](./4.1__Fiber节点_虚拟DOM节点.md)

基于这种链表型的数据结构，React可以通过 “**指针跳转**” 而非 “**递归栈遍历**” 的方式遍历组件树。

这种设计的**核心价值**是**支持渲染过程的中断与恢复**：当遍历到某个 Fiber 节点时，若遇到更高优先级任务（如用户输入），可以暂停遍历并保存当前节点的指针，待后续恢复时直接从该节点继续，无需重新遍历整个树，从而解决了传统递归渲染可能导致的主线程阻塞问题。

## 一、Fiber是如何进行拆分的？
Fiber将渲染工作 拆分成一系列以“Fiber 节点”为单位的独立工作单元。

Fiber节点与组件的关系：一一对应，组件内元素与组件形成“父子 节点关系”。如：
```js
function ParentComponent() {
  return (
    <div className="parent">
      <ChildComponent />
      <span>Hello</span>
    </div>
  );
}
```
ParentComponent 函数组件对应一个 父 Fiber 节点；它内部的```<div>```是这个父 Fiber 节点的 child节点；然后循环处理...，最终**整个组件树会被转化为嵌套的 Fiber 树**，通过 child/sibling/return 指针连接。

## 二、Fiber特性：
拆分、按优先级调度、链表、可中断、

* Fiber将渲染工作 **拆分**成一系列以“Fiber 节点”为单位的独立工作单元，每次只处理一个单元。拆分后 按照优先级排序..
* 基于**链表**实现组件树遍历。有三个指针：child、return、sibling
* **按优先级调度**：引入调度器（Scheduler） 模块，为不同任务分配优先级，按优先级高低执行
* **可中断**：执行过程中若有高优先级任务（如用户点击），可暂停当前工作，先处理高优先级任务，之后再恢复。
* 双缓存机制：当前树、工作树
* 增量渲染

## 三、Fiber树是如何遍历的？
* 基于```链表结构 + 深度优先遍历 * 时间切片```三种技术
    * 时间切片：控制任务执行时长，避免阻塞主线程
* 遍历顺序是```先处理当前节点 → 再处理子节点 → 最后处理兄弟节点```，
* 每处理一个节点就更新 nextUnitOfWork指针，直到最后为null，表示遍历已结束！**中断时**只需保存该指针，**恢复时**直接从该节点继续，**无需重新遍历整棵树**。

**详细流程**：Fiber 架构将渲染任务拆分为 “时间切片”（每个切片的连续执行时间 ≤ 5ms），每次切片内可处理一个或多个 Fiber 节点（**每个节点的处理是不可中断的原子操作**）。深度优先遍历中，整体流程如下：

1. **时间切片启动前**：由 Scheduler 检查主线程是否空闲（无高优先级任务，如用户输入、动画）。
    * 若主线程繁忙或有高优任务：不启动切片，等待主线程空闲后再尝试。
    * 若主线程空闲且无高优任务：启动一个时间切片，从当前 nextUnitOfWork（下一个待处理节点）开始处理。
2. **切片执行中**：
    * 处理当前 nextUnitOfWork 节点（完成 Diff、标记副作用等）。
    * 处理完后，通过 Fiber 指针（child/sibling/return）找到下一个 nextUnitOfWork。
    * 检查**当前切片的总耗时**（从启动到现在）：
        * 若总耗时 ≤ 5ms 且无新的高优任务：继续在当前切片内处理下一个 nextUnitOfWork 节点。
        * 若总耗时 > 5ms 或出现新的高优任务：立即中断切片，保存 nextUnitOfWork（下次恢复的起点），释放主线程。
3. 后续恢复：当主线程再次空闲（高优任务处理完毕），重复步骤 1-2，从上次保存的 nextUnitOfWork 继续处理。


### 案例流程：处理 4 个 Fiber 节点（A、B、C、D），每个节点处理耗时 2ms

**第一步：等待主线程空闲（前提检查）**   
* 用户触发 setState，React 向 Scheduler 提交渲染任务。
* Scheduler 检测到主线程正在处理 “用户输入回调”（高优任务），暂时不调度 React 任务，等待输入处理完毕。
* 输入处理完成，主线程空闲 → Scheduler 通知 React 启动 workLoop（工作循环），开始时间切片。  

**第二步：执行切片，处理节点并检查总耗时（过程检查）**   
* 记录切片启动时间 startTime = T0。
* 处理节点 A（耗时 2ms）→ 当前耗时 T1 - T0 = 2ms ≤ 5ms → 继续处理下一个节点 B。
* 处理节点 B（耗时 2ms）→ 当前耗时 T2 - T0 = 4ms ≤ 5ms → 继续处理下一个节点 C。
* 处理节点 C（耗时 2ms）→ 当前耗时 T3 - T0 = 6ms > 5ms → 触发总耗时检查，暂停渲染，保存 nextUnitOfWork = D，释放主线程。  

**第三步：再次等待主线程空闲（前提检查）**  
* 主线程释放后，优先处理 “动画帧回调”（另一高优任务），React 任务处于等待状态。
* 动画帧处理完成，主线程再次空闲 → Scheduler 通知 React 恢复 workLoop，从 nextUnitOfWork = D 开始。  

**第四步：恢复切片，继续处理并检查总耗时**   
* 重新记录新切片的 startTime = T4（注意：每次恢复都会重新计时，而非延续上一次的耗时）。
* 处理节点 D（耗时 2ms）→ 当前耗时 T5 - T4 = 2ms ≤ 5ms → 无更多节点，切片执行完毕，进入提交阶段（Commit Phase）。

## 四、Fiber 与生命周期的关系
引入Fiber后，由于 “调度阶段可中断并重复执行”，部分生命周期方法可能被多次调用，导致副作用逻辑（如重复发请求）出错。
例如：
* componentWillMount
* componentWillReceiveProps
* componentWillUpdate

因此，React 16.3 引入了新的生命周期方法替代它们，确保在 Fiber 模式下更安全：
* static getDerivedStateFromProps（纯函数，无副作用）
* getSnapshotBeforeUpdate（在 DOM 更新前获取快照）

## 五、并发渲染（Concurrent Rendering）
React 18 引入的新特性，基于 Fiber架构。

允许 React **“同时”处理多个渲染任务**（“同时” 是逻辑上的，而非物理上的多线程，因为 JavaScript 是单线程），**核心是 “允许高优先级任务打断低优先级任务”**，避免页面卡顿。

如何启用并发渲染?   
答：需要通过 React 18 新增的 createRoot 方法创建根节点来激活：
```js
// React 18 前（同步渲染）
import ReactDOM from 'react-dom';
ReactDOM.render(<App />, document.getElementById('root'));

// React 18 后（支持并发渲染）
import { createRoot } from 'react-dom/client';
const root = createRoot(document.getElementById('root'));
root.render(<App />); // 启用并发模式
```

相关 API：
* useTransition：用于标记非紧急的更新，将其设置为低优先级，在空闲时间进行处理，避免阻塞高优先级任务。
* startTransition：与useTransition配合使用，用于触发一个过渡动画，让 React 知道哪些更新可以被延迟。

### 常见误区：
* 并发渲染是 “多线程渲染”？   
错。JavaScript 是单线程，并发渲染的 “并发” 是 “逻辑上的并发”—— 通过 “中断低优先级任务、执行高优先级任务” 模拟多任务并行，而非真正的多线程并行

* Fiber 就是并发渲染？  
错。Fiber 是底层架构，并发渲染是基于 Fiber 的功能。例如：Fiber 还支撑了 “时间切片（Time Slicing）”、“ suspense” 等其他特性，并发渲染只是其中之一。

## 六、拆分后的任务通过 “工作循环” 执行
核心逻辑简化如下：
```js
// 记录当前需要处理的Fiber节点
let nextUnitOfWork = null;

// 工作循环：处理完一个单元，再决定下一个
function workLoop(deadline) {
  // 有工作单元且浏览器有空闲时间
  while (nextUnitOfWork && deadline.timeRemaining() > 0) {
    // 处理当前工作单元，并返回下一个需要处理的单元
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }
  
  // 如果还有未完成的工作，请求浏览器下次空闲时继续
  if (nextUnitOfWork) {
    requestIdleCallback(workLoop);
  }
}

// 启动工作循环
requestIdleCallback(workLoop);

// 处理单个工作单元（Fiber节点）
function performUnitOfWork(fiber) {
  // 1. 处理当前节点（计算props、执行render、对比新旧节点等）
  processCurrentFiber(fiber);
  
  // 2. 确定下一个工作单元（优先级：先子节点，再兄弟节点，最后父节点）
  if (fiber.child) {
    return fiber.child; // 先处理子节点
  }
  let next = fiber;
  while (next) {
    if (next.sibling) {
      return next.sibling; // 再处理兄弟节点
    }
    next = next.return; // 没有子节点和兄弟节点，返回父节点
  }
  return null; // 所有节点处理完毕
}
```