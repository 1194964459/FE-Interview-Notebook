# 函数式组件_误更新解决

先看一个问题场景：

当父组件重渲染时，其内部定义的对象、数组、函数会被**重新创建**（即使内容没变，引用地址也会变化）。如果这些值作为 props 传递给被 React.memo 包装的子组件，子组件会因为“引用变化” 而误判为 props 变化，导致*无效重渲染*。

例如：
```js
// 父组件
const Parent = () => {
  const [count, setCount] = useState(0);
  
  // 每次父组件重渲染，都会创建新的对象和函数（引用变化）
  const user = { name: "Alice" }; 
  const handleClick = () => { console.log("点击"); };

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* 子组件会因 user/handleClick 引用变化而重渲染 */}
      <Child user={user} onClick={handleClick} />
    </div>
  );
};

// 子组件（用 React.memo 包装）
const Child = React.memo(({ user, onClick }) => {
  console.log("子组件重渲染了");
  return <button onClick={onClick}>{user.name}</button>;
});
```

点击父组件按钮时，```count 变化导致父组件重渲染，user 和 handleClick 会被重新创建（引用变化）```，**即使内容没变，Child 也会跟着重渲染** —— 这就是需要优化的问题。

### 解决：
法1：使用 useMemo、useCallback
```js
  // 用 useMemo 缓存对象（空依赖数组：永远返回同一个引用）
  const user = useMemo(() => ({ name: "Alice" }), []); 
```

```js
  // 用 useCallback 缓存函数（空依赖数组：永远返回同一个引用）
  const handleClick = useCallback(() => {
    console.log("点击");
  }, []); 
```

法2：提取为模块级常量(函数组件外，因为每次渲染时，函数组件都会重新执行一次的)
```js
// 定义在组件外部，仅创建一次
const STYLE = { color: 'red', fontSize: '16px' };
const CLASS_NAMES = ['container', 'shadow'];

function MyComponent() {
  return (
    <div 
      style={STYLE}  // 复用同一个对象引用
      className={CLASS_NAMES.join(' ')}  // 复用同一个数组引用
    >
      内容
    </div>
  );
}
```

法3：利用ES6扩展运算符将传递的对象解构。这样组件接收到的便是基本类型的props。
```js
// Don't do this!
function Component(props) {
  const aProp = { someProp: 'someValue' }
  return <AnotherComponent  aProp={aProp} />  
}

// Do this instead :)
function Component(props) {
  const aProp = { someProp: 'someValue' }
  return <AnotherComponent  {...aProp} />  
}
```

这样，当父组件重新渲染时，内部的对象、数组、函数啥的就不会创建。

不过，上述是特殊案例，dependencies 为空。真正的应该为：**dependencies不变时，即使父组件重新渲染，父组件内的对象、数组、函数啥的也不会重新创建，然后React.memo封装的子组件也不会重新渲染**。
```js
const memoizedCallback = useCallback(() => {
  // 函数逻辑
  console.log("点击");
}, [dependencies]); //
```

```js
const memoizedValue = useMemo(() => {
  // 计算逻辑（返回对象、数组等）
  return { name: "Alice" };
}, [dependencies]); // 依赖数组：依赖变化时才重新计算
```