# 闭包陷阱

闭包是啥？闭包 = 函数 + 函数能够访问的自由变量！自由变量指的是“不是函数的参数，也不是函数内定义的变量”

React 变量闭包最核心的问题是**捕获旧值**，导致组件中使用的变量与预期的最新状态/属性不一致。
具体问题场景及表现如下：

1. **定时器/异步操作中的旧值问题**：在 **setTimeout、setInterval 或 Promise 回调**中，闭包会**捕获定义时的变量值**（如 useState 状态），而非执行回调时的最新值。
2. **事件监听器中的旧值问题**：通过 **addEventListener** 添加的事件监听，其回调函数会**捕获绑定时刻的变量**，后续组件状态更新后，监听器仍使用旧值。
3. **依赖项缺失**导致的闭包陷阱：使用 **useEffect、useCallback** 等 Hooks 时，若未将闭包依赖的变量加入依赖数组，Hooks 内部会持续使用旧的闭包值，与外部最新状态脱节。

## 以setTimeout为例，分析闭包陷阱是如何产生的...
```js
import { useState } from "react";

export default function TimerDemo() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        // 点击时，count 是当前值（比如 0）
        setCount(prev => prev + 1)

        // 定时器回调捕获的是“点击瞬间的 count（0）”，而非 1
        setTimeout(() => {
            console.log(`count 的值是：${count}`)
        }, 200);
    };

    return (<>
        {count}
        <button onClick={handleClick}>点击计数</button>;
    </>)
}
```

步骤分解：
1. 初始渲染：组件第一次执行，count 是 0，handleClick 函数被创建。
2. 点击事件触发：
    * setCount(prev => prev + 1) 触发重新渲染，但此时**当前渲染周期的 handleClick 还未销毁**。
    * setTimeout 的回调函数在此时定义，**闭包会捕获 “当前渲染周期” 的 count（值为 0）**。
3. **1 秒后回调执行**：
虽然组件已重新渲染（count 变为 1），但 setTimeout 回调的闭包 “记住” 的是定义时（点击瞬间）的 count（值为 0），所以打印旧值。
4. 闭包的体现
    * setTimeout 的回调函数（无论普通函数还是箭头函数）都引用了外层作用域的变量 count，因此形成闭包。
    * 闭包的特性是 “记住定义时的变量”，而 React 函数组件的每次渲染是独立快照，所以回调会捕获定义时所在渲染周期的旧变量。


疑问❓：上述 handleClick 函数中 `setCount(prev => prev + 1)` 与 `setCount(prev + 1)` 表现一样吗？  
答：一样的！setCount**参数是函数**的意义仅仅提现在连续多次调用setCount修改值；

疑问❓：上述 handleClick 函数中setTimeout的回调是 匿名函数 与 箭头函数 有差别吗？     
答：没差别，都是形成闭包（当前的回调函数+一个自由变量）；它们的**词法作用域是相同的**（内层函数可以访问外层的变量啥的），但是**执行时的this上下文是不一样**的。**定时器回调函数在全局环境中执行**（脱离了原函数的调用栈），严格模式下，this 是 undefined；非严格模式下，this 指向全局对象。