# Hooks

参考：[Hooks](https://www.doubao.com/thread/wad98fe42b51020bf)

Hooks 是从 React 16.8 版本开始引入的特性，它允许开发者在函数组件中使用状态（state）和其他 React 特性。

核心常用 Hooks 包括： 
* 状态管理：useState、useReducer
* 副作用处理：useEffect、useLayoutEffect
* 性能优化：useCallback、useMemo
* 引用与上下文：useRef、useContext
* 高级用法：useImperativeHandle、useDebugValue


### 1. useState：管理组件状态
```js
const [state, setState] = useState(initialValue);
```
注意：setState 是异步的，若新状态依赖于旧状态，应使用函数形式：
```js
setCount(prevCount => prevCount + 1); // 确保基于最新状态更新
```

### 2. useEffect - 处理副作用（异步）
参开：[useEffect 详解](./1.3.1__useEffect.md)

作用：在函数组件中处理副作用（如数据请求、DOM 操作、订阅事件等），替代类组件中的```componentDidMount、componentDidUpdate 和 componentWillUnmount```。
> **useLayoutEffect**：与useEffect类似，不过是 同步的，可能阻塞浏览器渲染，优先使用 useEffect。
```js
useEffect(() => {
  // 副作用逻辑（如请求数据、添加事件监听）
  
  return () => {
    // 清理函数（如移除事件监听、取消订阅）
  };
}, [dependencies]); // 依赖数组：当数组中的值变化时，才会重新执行副作用
```
常见场景：
* 空依赖数组 []：仅在组件挂载时执行一次（类似 componentDidMount）。
* 依赖数组有值：当**依赖项变化时**执行（类似 componentDidMount + componentDidUpdate）。
* 清理函数：在**组件卸载**或**依赖项变化前**执行（类似 componentWillUnmount）。

### 3. useContext - 跨组件共享数据
* 避免通过 props 层层传递。
* 需配合 createContext 创建的 Context 对象使用。

缺点：
* 可能导致不必要的重渲染
当 Context.Provider 的 value 变化时，所有使用 useContext 消费该上下文的组件**都会强制重渲染**，即使组件本身并不依赖变化的部分。并且**无法阻止 Context 触发的 render**
* 因此，不适合频繁变化的数据，仅适用于共享**变化不频繁**的**全局配置数据（如主题、权限）**

```js
// 1. 创建Context
const ThemeContext = React.createContext('light');  // light是默认值
```
```js
// 2. 上层组件提供数据

// 法1：使用默认值：
function App() {
  return (
    <ThemedButton />
  );
}

// 法2：使用 value
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

```js
// 3. 子组件通过useContext获取数据
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button style={{ background: theme === 'dark' ? 'black' : 'white' }}>Click me</button>;
}
```

### 4. useReducer - 复杂状态管理
通过 reducer 函数管理复杂状态（类似 Redux 的思想）  
```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```
* reducer：接收 (state, action) 并返回新状态的函数。
* dispatch：用于触发 action 的函数（通过 action 类型更新状态）。
```js
// 定义reducer
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case 'TOGGLE_TODO':
      return state.map(todo => 
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    default:
      return state;
  }
}

// 使用useReducer
function TodoList() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  const [text, setText] = useState('');
  
  const handleAdd = () => {
    dispatch({ type: 'ADD_TODO', text });
    setText('');
  };
  
  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={handleAdd}>Add</button>
      <ul>
        {todos.map(todo => (
          <li 
            key={todo.id} 
            style={{ textDecoration: todo.done ? 'line-through' : 'none' }}
            onClick={() => dispatch({ type: 'TOGGLE_TODO', id: todo.id })}
          >
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 5.useMemo：缓存计算结果
useMemo 缓存计算结果（通常是对象、数组等引用类型），避免组件重新渲染时“重复计算”

经常 与 React.memo 配合，只有当子组件用 React.memo 包装时，useMemo 缓存引用的作用才会体现（否则无需缓存）。

```js
const memoizedValue = useMemo(() => {
  // 计算逻辑（如复杂的数组处理、数学计算）
  return result;
}, [dependencies]); // 依赖变化时，才会重新计算
```
**若依赖为空，永远返回同一个引用**，如下：
```js
const user = useMemo(() => ({ name: "Alice" }), []); 
```

### 6. useCallback：缓存函数引用
避免因组件重新渲染导致**函数被频繁创建**，优化子组件性能（尤其配合 React.memo 时）。

* 适用场景：缓存需要传递给子组件的回调函数（尤其是子组件用 React.memo 包装时）。
* 与 useMemo 的关系： ```useCallback(fn, deps)``` 等价于 ```useMemo(() => fn, deps)```，前者是专门用于函数的语法糖。

```js
const memoizedCallback = useCallback(() => {
  // 函数逻辑
}, [dependencies]); // 依赖数组：依赖变化时，函数才会重新创建
```

示例：
```js
function Parent() {
  const [count, setCount] = useState(0);
  
  // 缓存handleClick函数，仅当count变化时重新创建
  const handleClick = useCallback(() => {
    console.log(`Count: ${count}`);
  }, [count]);
  
  return <Child onClick={handleClick} />;
}

// 子组件使用React.memo避免不必要的重渲染
const Child = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click</button>;
});
```

### 7. useRef：访问 DOM 或存储可变值
参考：[类组件、函数组件 中的Ref](./Ref.md)

useRef创建的值是持久化的（与渲染无关，首次渲染创建对象  后续渲染直接复用）

ref.current：存储当前值（修改时不会触发组件重渲染）。

示例1：访问Dom，绑定到DOM上
```js
function InputFocus() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus(); // 直接操作DOM
  };
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

示例2：存储可变值：不绑定Dom，仅仅存值
```js
function Timer() {
  const [count, setCount] = useState(0);
  const timerRef = useRef(null); // 存储定时器ID
  
  const start = () => {
    timerRef.current = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
  };
  
  const stop = () => {
    clearInterval(timerRef.current); // 使用存储的定时器ID
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </div>
  );
}
```

### 8. useImperativeHandle：自定义暴露给父组件的实例值
配合 forwardRef 使用，自定义子组件暴露给父组件的 ref 方法或属性，避免暴露整个 DOM 实例。

参考：[函数式组件中 父访问子的属性、方法](./1.0.2__函数式组件_父访问子.md)


### 9. useLayoutEffect：同步执行 DOM 操作
与 useEffect 类似，但***会在 DOM 更新后同步执行（而 useEffect 是异步的）***，适用于需要**立即读取 DOM 布局**的场景（如计算元素尺寸）。

注意：可能阻塞浏览器渲染，优先使用 useEffect，仅在必要时使用。

### 10. useDebugValue - 自定义 Hooks 的调试信息
在 React DevTools 中为自定义 Hook 显示标签，便于调试