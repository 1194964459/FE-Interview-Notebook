# React性能优化
https://www.doubao.com/thread/w4dea2fde4df1f588

减少渲染触发次数 + 降低单次渲染成本。

## 一、 减少不必要的组件重渲染
拆分组件、避免渲染时创建对象/数组、避免渲染阶段执行副作用、shouldComponent等类组件/函数组件其他5项优化手段

1. 类组件中使用 shouldComponentUpdate 或 React.PureComponent
2. 使用 **React.memo 缓存组件**：仅在**组件接收的 props 发生变化时才重新渲染**
3. 用 **useCallback 缓存函数引用**
4. 用 **useMemo 缓存计算结果（通常是对象、数组等引用类型）**，避免组件重新渲染时“重复计算”
5. **拆分组件，缩小更新粒度**，如：将**频繁更新的部分**拆分为独立组件，避免整个页面重渲染
6. **避免在渲染阶段执行副作用**    
  > Fiber 会**中断并重启渲染过程**（如低优先级任务被打断后重新执行），若在 render 中执行副作用（如**请求数据、修改全局变量**），**会导致副作用被重复执行**。将副作用放在提交阶段执行，不会被中断。    

7. 避免渲染时创建新对象/数组    
如 ```style={{ color: 'red' }}``` 每次都会创建新对象，触发不必要的重渲染。可提取为常量或使用useMemo 缓存。   
  [示例](../code/渲染元素属性为对象.jsx)    
  [引用陷阱 常见方案解决](./1.0.1__函数式组件_误更新解决.md)

## 二、列表渲染优化
* 合理使用 key 属性：列表渲染时，key 需唯一且稳定（避免用索引）
* 虚拟列表（大数据列表优化）：可使用 react-window 或 react-virtualized 库

## 三、代码分割与懒加载（React.lazy 和 Suspense）
参考：[React.lazy 与 Suspense](./8.1__React.lazy__suspense.md)

**1. 组件懒加载**  
用 **React.lazy 和 Suspense**实现组件按需加载，**减小初始 bundle 体积，加快首屏加载**：
```js
// 懒加载组件
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 使用时包裹Suspense（提供加载状态）
const App = () => (
  <Suspense fallback={<div>加载中...</div>}>
    <LazyComponent />
  </Suspense>
);
```

**2. 路由级别分割**  
结合路由库（如 React Router）对不同路由页面进行分割，仅加载当前路由所需代码：
```js
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>加载中...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);
```
## 四、其他实用技巧
**1. 使用```React.Fragment```**,
避免添加额外的DOM，简写语法```<></>```。

**3.使用 React.Profiler 定位性能瓶颈**  
通过 Profiler 组件测量组件渲染时间，精准定位需要优化的部分：
```js
<Profiler id="MyComponent" onRender={(id, phase, actualDuration) => {
  console.log(`${id} 渲染耗时: ${actualDuration}ms`);
}}>
  <MyComponent />
</Profiler>
```

**4. 使用 **Web Workers** 处理 heavy 计算**

复杂计算（如数据解析、图表渲染）会阻塞主线程，导致 UI 卡顿。可将计算逻辑放入 Web Worker，避免影响渲染：
```js
// 主线程中创建Worker
const worker = new Worker(new URL('./calculation.worker.js', import.meta.url));

// 发送数据给Worker
worker.postMessage(largeData);

// 接收计算结果
worker.onmessage = (e) => {
  setResult(e.data);
};
```