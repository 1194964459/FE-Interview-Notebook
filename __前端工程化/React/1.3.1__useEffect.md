# useEffect

useEffect 是 React 中用于处理副作用的 Hook，它允许你在函数组件中执行数据获取、订阅、手动修改 DOM 等操作。

### 一、什么是 “副作用”？
在 React 中，“副作用” 指的是组件渲染过程之外的操作，常见场景包括：

* 手动修改 DOM（如操作 canvas、播放动画）
* 数据获取（如 API 请求）
* 订阅事件（如 window.scroll、WebSocket）
* 设置定时器/计时器（setTimeout、setInterval）

### 二、基本语法
* 第一个参数：一个函数，包含副作用逻辑和**可选的清理函数**。
* 第二个参数：**依赖数组（可选）**，决定副作用何时执行。
```js
useEffect(() => {
  // 副作用逻辑（如数据请求、事件监听）
  
  // 可选的清理函数（用于清除副作用）
  return () => {
    // 清理逻辑（如移除事件监听、取消定时器）
  };
}, [dependencies]); // 依赖数组（控制副作用的执行时机）
```

### 三、执行时机与依赖数组
useEffect 的**执行时机完全由依赖数组控制**，依赖数组参数是可选的，共 3 种可能性：

**1. 无依赖数组**  
* 格式：```(useEffect(() => { ... }))```  
* 执行时机：组件每次渲染后都会执行（包括首次渲染和所有更新）。

```js
useEffect(() => {
  console.log("组件渲染完成"); // 首次渲染和每次更新后都会打印
});
```

**2. 依赖数组存在，但为[]**
* 格式：```（useEffect(() => { ... }, [])）```
* 执行时机：**仅在组件首次挂载后执行一次，后续更新不执行**（类似 componentDidMount）。
* 适用场景：初始化操作（如获取初始数据、添加全局事件监听）。
    ```js
    useEffect(() => {
    console.log("组件挂载完成"); // 仅首次渲染后打印
    window.addEventListener("scroll", handleScroll);
    
    // 清理函数：组件卸载前执行
    return () => {
        window.removeEventListener("scroll", handleScroll);
    };
    }, []); // 空数组 → 仅执行一次
    ```

**3. 依赖数组中至少有一个值**
* 格式：```（useEffect(() => { ... }, [dep1, dep2])）```
* 执行时机：
    * 首次挂载后执行一次。
    * 当依赖数组中的任意一个值发生变化时，先执行上一次的清理函数，再执行新的副作用。
    > 类似 componentDidMount + componentDidUpdate
* 适用场景：副作用逻辑依赖外部变量（如 props 或 state），需**在依赖变化时重新执行**。
```js
const [id, setId] = useState(1);

useEffect(() => {
  // 依赖 id：当 id 变化时重新请求数据
  const fetchData = async () => {
    const res = await fetch(`/api/data/${id}`);
    const data = await res.json();
    setData(data);
  };
  fetchData();

  // 清理函数：id 变化时取消当前请求（避免竞态问题）
  return () => {
    // 取消请求的逻辑（如使用 AbortController）
  };
}, [id]); // 依赖 id → id 变化时执行
```

### 四、清理函数
是可选的，**用于在“副作用执行前（依赖变化时）”或“组件卸载前”清除资源**，避免内存泄漏。类似 componentWillUnmount 生命周期干的事！

清理函数是同步的，会阻塞浏览器渲染，避免在其中执行耗时操作（如复杂计算）。

常见清理场景：
* 移除事件监听
* 清除定时器
* 取消网络请求

### 五、注意事项
1. 若副作用中使用了 props、state 或组件内定义的变量，必须将它们加入依赖数组，否则可能捕获到 “过时的状态”
```js
// 错误：依赖了 count 却未加入依赖数组，可能获取到旧值
useEffect(() => {
  console.log(count); 
}, []); // 遗漏 count → 错误

// 正确：包含所有依赖
useEffect(() => {
  console.log(count);
}, [count]); // 依赖 count → 正确
```
2. 清理函数是同步的：   
清理函数会阻塞浏览器渲染，避免在其中执行耗时操作（如复杂计算）。

3. 副作用内尽量使用“函数式更新”（如 setCount(c => c + 1)），避免闭包导致 获取的是旧值。

4. 不要在 useEffect 中直接写异步函数：
useEffect 的回调函数不能是异步函数（会返回 Promise，破坏清理函数逻辑），需**在“内部定义”异步函数 并调用**：
```js
// 正确写法
useEffect(() => {
  // 先定义
  const fetchData = async () => { /* 异步逻辑 */ };
  
  // 再调用  
  fetchData(); 
}, []);
```
下面的这种写法是错误的❌：
```js
useEffect(async () => {
    const res = await fetch("/api/data");
    const data = await res.json();
    console.log(data);
  }, []);
```
因为：async 函数返回 Promise，而 useEffect 期望回调返回 “清理函数”（或 undefined）。此时 React 无法识别返回的 Promise，清理逻辑会完全失效（比如组件卸载时无法取消请求）。
