# 函数式组件中 父组件 如何访问 子组件内的方法、属性？
参考：[类组件、函数组件的Ref ](./Ref.md)

函数组件没有实例，不能像类组件那样直接接收 ref 属性。因此需要通过```forwardRef 配合 useImperativeHandle``` 实现父组件对子组件的访问和操作。

forwardRef 是 React 提供的一个高级函数，用于```将 ref 从父组件“转发”到子组件的 内部DOM元素 或 组件```

## 一、forwardRef
forwardRef **接收一个渲染函数作为参数**，该函数的格式为：```(props, ref) => ReactNode```

与普通函数组件不同，这个渲染函数会接收两个参数：   
* props：父组件传递的属性
* ref：父组件传递的 ref 对象（需要转发给内部元素）
> 📢注意：ref 不是 props，转发的 ref 不会出现在子组件的 props 中，需要单独作为参数接收。

示例：转发 ref 到 DOM 元素

```js
import React, { forwardRef } from'react';

// 1. 使用 forwardRef 创建可接收 ref 的子组件
const CustomInput = forwardRef((props, ref) => {
  // 3. 将父组件传递的 ref 绑定到内部 input 元素
  return <input {...props} ref={ref} />;
});

// 2. 父组件使用 CustomInput 并传递 ref
function ParentComponent() {
  // 创建一个 ref
  const inputRef = React.useRef(null);

  const focusInput = () => {
    // 4. 父组件通过 ref 直接访问子组件内部的 input 元素
    inputRef.current.focus();
  };

  return (
    <div>
      <CustomInput ref={inputRef} placeholder="请输入内容" />
      <button onClick={focusInput}>聚焦输入框</button>
    </div>
  );
}
```

工作流程：
* 父组件创建 inputRef 并传递给 CustomInput 组件。
* CustomInput 通过 forwardRef 接收 ref 参数。
* CustomInput 将 ref 绑定到自身内部的 ```<input> 元素```。
* 父组件通过 inputRef.current 直接访问子组件内部的```<input> 元素```。

## 二、与 useImperativeHandle 配合（自定义暴露内容）

默认情况下，转发的 ref 会直接指向子组件的 DOM 元素。如果希望自定义暴露给父组件的内容（而非直接暴露 DOM 元素），可以结合 useImperativeHandle：

语法如下：
```js
useImperativeHandle(ref, () => ({
  // 自定义暴露的方法或属性
  method1: () => {... },
  property1: value,...
}), [deps]);
```
useImperativeHandle 接收 3 个参数：   
* ref：通过 forwardRef 传递的 ref 对象（需要自定义其暴露内容）。
* createHandle：一个函数，返回值是一个对象，即自定义暴露给父组件的内容（属性或方法）。
* deps：依赖数组，当依赖变化时，createHandle 会重新执行，生成新的暴露内容。

示例：
```js
import React, { forwardRef, useRef, useImperativeHandle } from'react';

const CustomInput = forwardRef((props, ref) => {
  // 子组件内部的真实 DOM ref
  const internalRef = useRef(null);

  // 自定义暴露给父组件的方法（覆盖默认的 ref 行为）
  useImperativeHandle(ref, () => ({
    // 只暴露 focus 方法，不暴露完整 DOM 元素
    focus: () => {
      internalRef.current.focus();
    },
    // 额外暴露一个自定义方法
    clear: () => {
      internalRef.current.value = '';
    }
  }));

  return <input ref={internalRef} {...props} />;
});

// 父组件只能访问到自定义暴露的方法
function Parent() {
  const inputRef = useRef(null);

  const handleClick = () => {
    inputRef.current.focus(); // 调用自定义的 focus 方法
    inputRef.current.clear(); // 调用自定义的 clear 方法
    // inputRef.current.value = 'xxx'; // 错误！无法访问 DOM 原生属性
  };

  return (
    <div>
      <CustomInput placeholder="测试" />
      <button onClick={handleClick}>操作输入框</button>
    </div>
  );
}
```

这里有2个ref：
1. 父组件传递的ref（forwardRef 接收的 ref）  
    * **父组件 “想要访问子组件” 的 “入口”**，但是**这个 ref 本身不直接关联 DOM**，而是**通过 useImperativeHandle 被 “重定向” 到子组件自定义的行为**。

2. 子组件内部的internalRef（useRef 创建的 ref）
    * **直接关联子组件内部的 DOM 元素**，外是隐藏的（父组件无法直接通过父级 ref 访问到这个 internalRef）。

### 为什么子组件要再创建一个 internalRef？
主要是为了 “解耦” 和 “封装”：
* **解耦父组件与 DOM 细节**：父组件不需要知道子组件内部DOM具体实现细节，只需要调用focus 或 clear 等“业务方法” 即可，避免子组件暴漏过多内部细节（破坏封装性）。
    * 如果直接把父级ref 绑定到 DOM（即去掉 internalRef，直接 ref={ref}），父组件就能拿到完整的 DOM 元素
* **自定义暴露的行为**：通过 internalRef 操作 DOM，再通过 useImperativeHandle 把 “经过包装的方法” 暴露给父组件，子组件可以精确控制父组件能做什么。
    * 如：父组件调用 focus 时，子组件确保焦点逻辑正确执行。


## 三、类组件中：父组件如何获取子组件的方法、属性？

```js
import { Component, createRef } from'react';

// 1. 子组件（类组件）：定义公开方法和属性
class ChildComponent extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  // 公开方法（供父组件调用）
  internalMethod = () => {
    this.setState(prev => ({ count: prev.count + 1 }));
  };

  // 公开属性（也可通过 getter 暴露）
  get currentCount() {
    return this.state.count;
  }

  render() {
    return <div>子组件计数：{this.state.count}</div>;
  }
}

// 2. 父组件：通过 ref 访问子组件实例
class ParentComponent extends Component {
  constructor(props) {
    super(props);
    this.childRef = createRef(null); // 创建 ref
  }

  handleClick = () => {
    // 调用子组件的公开方法
    this.childRef.current.internalMethod();
    console.log('子组件当前计数：', this.childRef.current.currentCount);
  };

  render() {
    return (
      <div>
        <ChildComponent ref={this.childRef} /> {/* 绑定 ref 到子组件 */}
        <button onClick={this.handleClick}>调用子组件方法</button>
        <button onClick={this.handleReset}>重置子组件计数</button>
      </div>
    );
  }
}
```
