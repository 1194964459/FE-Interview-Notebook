# 函数组件、类组件 区别

## 两者 state 比较
| 特性	| 类组件（Class Component）| 	函数组件（Function Component）|
| ---- | ---- | ---- | 
| 定义方式	| 在 constructor 中通过 this.state = { ... } 定义	| 通过 useState(initialValue) 定义，每次声明一个独立状态|
| 状态结构	| 所有状态集中在一个对象中	| 多个独立状态变量，各自管理|
| 更新方法	| this.setState(newState) 或 this.setState(prev => newState)	| 每个状态对应独立的更新函数（如 setCount）|
| 对象更新行为	| 自动合并对象字段	| 需手动合并（用扩展运算符等）|
| **依赖旧状态更新**<br/>(参数是函数，而非对象)| 	```this.setState(prevState => { ... })```	| ```setX(prev => { ... })```|
| **异步更新后获取值**	| ```this.setState(..., callback)``` 新增个回调参数	| ```useEffect(() => { ... }, [state])```|

## 其他比较
| 特性	| 类组件（Class Component）| 	函数组件（Function Component）|
| ---- | ---- | ---- | 
| 语法基础 | 基于 ES6 类，继承 React.Component	|基于普通函数，接收 props 并返回 JSX |
| this 关键字 |	存在，需手动绑定事件处理函数 | 	不存在，无需处理 this 绑定 |
| 副作用处理 |	使用生命周期方法（componentDidMount 等） |	使用 useEffect Hook |
| 性能优化	 | 通过 shouldComponentUpdate 或 React.PureComponent  |	通过 React.memo、useMemo、useCallback |

## 类组件与函数组件 组件实例、生命周期、访问内部属性方法 等对比
1.组件实例：
> 核心问题：有无实例？有的话 什么时候开始创建的？实例中有什么？实例存在时间？    
> 函数式组件没有实例，那它又是怎么模拟实现“组件实例”的功能的？

* 类组件的实例：有实例，**当类组件被渲染时，React 会创建该类的实例对象（this）**，用于**存储组件的状态（this.state）、生命周期方法和自定义方法**，实例在**组件挂载后持续存在，直到卸载**。

* 函数组件是“无实例”的：
  * 函数组件本质是**纯函数**，**每次渲染时都会被重新执行**，不存在持久化的实例对象。
    > 纯函数：输入（props 和 state）决定输出（JSX）
    > 为什么每次渲染时都要重新执行？因为它的实例不是持久化的，每次都需要“重新执行函数” 来获取最新的 props 和 state。类组件 每次渲染时(除了第一次)只需要重新执行render即可
  * **组件的状态**通过 useState 等 Hook **存储在 React 内部的 “Hook 存储区”，而非组件实例上**。
  * 函数每次执行时，通过 Hook 接口访问最新状态。

2.生命周期方法
* 类组件：有，
* 函数组件：没有，通过useEffect模拟生命周期逻辑

3.方法和属性的访问
* 类组件：方法都是定义在实例上的，父组件可通过 ref 直接访问实例的方法和属性（如```this.childRef.current.method()```）。
* 函数组件：方法是函数组件内部的局部变量。但是每次渲染时 函数组件都会重新执行一次。父组件需通过 ```forwardRef + useImperativeHandle 手动暴露方法```。


## 类组件/函数组件 浅比较陷阱 及解决方案
参考：  
[React中的不可变数据原则](./0.0__不可变数据原则.md)

[类组件与函数组件 浅比较陷阱及解决方案](./0.0__浅比较陷阱_重要.md)

[函数组件“误更新”解决方案](./1.0.1__函数式组件_误更新解决.md)

## React.memo
用于函数组件，浅比较，是一个高阶组件（HOC）。它通过缓存组件的渲染结果，仅在**组件接收的 props 发生变化时才重新渲染**，否则直接复用上次的渲染结果。
> 状态相关的三种：props、组件内部状态（useState）或上下文（useContext）   
> React.memo，配合 useMemo（缓存对象/数组）和 useCallback（缓存函数）处理引用类型 props，

```js
// 定义函数组件
const MyComponent = (props) => {
  return <div>{props.name}</div>;
};

// 使用 memo 包装（默认浅比较 props）
const MemoizedComponent = React.memo(MyComponent);

// 自定义比较逻辑（可选）
const MemoizedComponent = React.memo(MyComponent, (prevProps, nextProps) => {
  // 返回 true：props 未变化，不重渲染
  // 返回 false：props 变化，需要重渲染
  return prevProps.name === nextProps.name;
});
```

## 最佳实践
* 函数组件：优先使用 React.memo，配合 useMemo（缓存对象/数组）和 useCallback（缓存函数）处理引用类型 props，避免浅比较失效。
* 类组件：
  * 简单场景用 React.PureComponent（自动浅比较 props 和 state）。
  * 复杂场景重写 shouldComponentUpdate，精确控制重渲染时机。
* 避免过度优化：两者都有性能成本（比较 props/state 需要时间），对于渲染成本低的组件，优化可能得不偿失。

## useState与setState比较
参考：[useState与setState比较](./1.2.1__useState与setState比较.md)

