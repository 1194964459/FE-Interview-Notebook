# 函数式组件
* 简洁的函数语法：**无需继承类，也无需 render() 方法**，直接返回 JSX，代码更简洁。
* **无 this 问题**：函数组件中没有 this 关键字，事件处理函数直接定义，无需绑定，避免了类组件中 this 指向的困惑。

* 通过 Hooks 管理状态和副作用：
    * useState：替代类组件的 this.state 和 setState，支持多个独立状态。
    * useEffect：替代类组件的生命周期方法（componentDidMount、componentDidUpdate、componentWillUnmount），统一处理副作用。
    * **props 直接作为参数**：父组件传递的属性通过函数参数获取，更直观。
* 更好的代码复用：通过自定义 Hooks 可以轻松抽取和复用逻辑，比类组件的高阶组件（HOC）或 render props 更简洁。

<br/>

> 疑问❓：react中的函数式组件，必须使用箭头函数定义？
> 答：不是必须，均可以采用“普通函数声明”或“箭头函数表达式”两种方式定义，功能上是等价的。两种方式的区别：
> * 函数提升：普通函数声明存在提升（可以在定义前使用），箭头函数表达式不存在提升（必须先定义后使用）。
> * this 绑定：在函数组件中几乎不影响（因为函数组件没有 this）。

<br/>

```js
import React, { useState, useEffect } from 'react';

// 函数组件（接收 props）
const FunctionComponent = (props) => {
    // 通过 useState 管理状态（替代 this.state 和 this.setState）
    const [count, setCount] = useState(0);
    const [user, setUser] = useState({ name: 'Alice', age: 20 });

    // 通过 useEffect 处理副作用（替代生命周期方法）
    useEffect(() => {
        console.log('组件已挂载或更新');
        return () => {
            console.log('组件即将卸载'); // 清理逻辑，类似 componentWillUnmount
        };
    }, [count]); // 依赖数组：仅当 count 变化时执行

    // 事件处理函数（无需绑定 this）
    const handleClick = () => {
        setCount(count + 1); // 直接调用状态更新函数
    };

    // 直接返回 JSX
    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={handleClick}>加1</button>
        </div>
    );
};

export default FunctionComponent;
```

## useState
```js
const [state, setState] = useState(initialState)
```
其中 useState 的参数 initialValue 可以是**任意类型（基本类型、对象、数组等）**，或**返回初始值的函数（延迟初始化，仅首次执行）**：

```js
// 方式1：直接传递新值（适用于不依赖旧状态）    
setCount(1);

// 方式2：函数形式（适用于新状态依赖旧状态）
setCount(prevCount => prevCount + 1);

// 更新对象：需手动合并旧属性（不会自动合并）
setUser(prevUser => ({
    ...prevUser, // 复制旧对象的所有属性
    age: prevUser.age + 1 // 只更新 age 字段
}));
```

```js
const [count, setCount] = useState(xx)  // 每次渲染斗湖执行
const [count, setCount] = useState(getDefaultCount());   // TODO:每次渲染都会执行getDefaultCount()；不过尽管每次渲染都会执行，但是这个状态值尽在“首次渲染”时才会用采用，后面是只执行 函数不用其返回的值作为状态值
const [count, setCount] = useState(() => getDefaultCount());  // 仅仅首次渲染会执行..

所以，复杂初始化 useState传入的参数 一定要箭头函数
```

异步更新：若需在初始值变化后执行逻辑，需配合 useEffect：
```js
useEffect(() => {
  console.log('更新后的值：', count); // 当 count 变化时执行
}, [count]); // 依赖数组：仅 count 变化时触发
```

示例：
```js
// 函数式组件，类组件也一样
import { useState } from 'react'

export default function Counter() {
    // 声明一个count状态，初始值为0
    const [count, setCount] = useState(0);
    function increment() {
        setCount(count + 1)
        setCount(count + 1)
        setCount(count + 1)
    }

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => increment()}>加1</button>
        </div>
    );
}
```
若想实现 调用三次就增加 3，将 increment 改为函数式更新：
```js
function increment() {​
    sesetCounttAge(a => a + 1); // 函数式更新​
}
```
## 性能优化
通过 React.memo、useMemo、useCallback


## 副作用处理
使用 useEffect Hook
