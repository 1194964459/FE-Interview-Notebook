## Raect类组件中的state、props、method是怎么访问的？
### State
* 初始化：状态需在 constructor 构造函数中初始化（或使用类属性语法简化）。
* 访问时通过 ```this.state.属性名``` 获取。
* 修改必须使用 this.setState() 方法（不能直接修改 this.state）。

### Props
在类组件中通过 ```this.props.属性名``` 访问

## method
类组件中自定义的方法，需要通过 ```this.方法名``` 调用，但**必须处理 this 指向问题**（这是 React 类组件的一个常见 “坑”）。若没绑定this，会直接报错的
```js
class Counter extends React.Component {
  state = { count: 0 };

  // 定义方法
  increment() {
    // 此处的 this 默认是 undefined，需绑定后才指向组件实例
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        {/* 这里会报错！！❌ */}
        <button onClick={this.increment}>+1</button>
      </div>
    );
  }
}
```

### 绑定this有 4 种方法：
1. 构造函数中绑定（推荐，性能更好）
```js
constructor(props) {
    // ...  其他逻辑   
    this.increment = this.increment.bind(this)
}
// 调用时直接写：onClick={this.increment}
```

2. 使用箭头函数定义方法（箭头函数的 this 继承自父作用域）
```js
increment = () => { // 箭头函数自动绑定 this
  this.setState({ count: this.state.count + 1 });
}
// 调用时直接写：onClick={this.increment}
```

3. JSX中绑定（❌每次 render 执行时，都会调用 bind 生成一个新的函数实例。❌）
```js
<button onClick={this.increment.bind(this)}>+1</button>
```

4. 调用时用箭头函数包裹（❌每次渲染生成新箭头函数，导致不必要的渲染❌）
```js
<button onClick={() => this.increment()}>+1</button>
```

📢注意：第3、4种方法在渲染时，都会创建新的函数，导致不必要的渲染，不是很推荐。

推荐优先使用 “constructor 中 bind” 或 “箭头函数定义方法”，避免重复创建函数，优化性能。
