# Object.is 实现

Object.is 的介绍见：

[Object.is](https://github.com/1194964459/FE-Interview-Notebook/blob/main/JS/%E5%AF%B9%E8%B1%A1_%E7%B1%BB_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.0_%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.md)


[==、===、Object.is()相等性判断](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Equality_comparisons_and_sameness)


### 一、宽松相等（==）
双等号（==）不比较类型，不过类型不同时**会执行强制类型类型转换**，并且会按照 IEEE 754 标准对 NaN、-0 和 +0 进行特殊处理（故 NaN != NaN，且 -0 == +0）；
* 如果其中一个操作数为 null 或 undefined，另一个操作数也**必须为 null 或 undefined** 以返回 true。否则返回 false。
```js
console.log('null == undefined：', null == undefined)   // true
console.log('null == ""：', null == '')  // false
console.log('null == 0：', null == 0)  // false
console.log('undefined == ""：', undefined == '')  // false
console.log('undefined == 0：', undefined == 0)  // false

```
* Number 强制转换：只能解析能转化为数字的有效字符串（如：'1'、'-1'）, 'a'是不能转换的 直接返回 NaN，null是特殊情况
  * undefined 转换为 NaN
  * 'a' 转换为 NaN
  * null 转换为 0


### 二. 严格相等（===）
严格相等比较两个值是否相等，遵循下面的规则：
* 两个被比较的值在**比较前都不进行隐式转换**。
* 如果两个被比较的值具有**不同的类型，则认为这两个值不相等**。
* 如果两个被比较的值**类型相同，值也相同**，并且*都不是 number 类型时*，则认为这两个值相等。
* 最后，如果*两个值都是 number 类型*，当**两个都不是 NaN，并且数值相同**，两个值被认为是相等的。

**PS：对于除了数字之外的值，严格相等有着明确的语义：值仅与它自身相等**。注意：此处的“仅”，所以<code>null === undefined  // 结果应为false</code>

对于数字，严格相等有两种特殊情况：
1. 浮点数 0 是不分正负的，所以<code>+0 === -0 === 0</code>，即：三者中的任意两项都是相等的。
2. NaN 与其他任何值都不全等（包括它自身）。

### 三、Objece.is()
Object.is和===比较相似，不会转换被比较的两个值的类型。但他们之间也有2点不同：
* ES5中, NaN与任何值都不相等( 包括它自身 )，但实际上它们是同一个特殊值（表示 “非数字”）。
* ES5中，+0 === -0 === 0，但两者在数学意义上是不同的（例如 1 / +0 是 Infinity，1 / -0 是 -Infinity）。

而 **Object.is 修复了这两个问题**，它的判断逻辑更严格：
* Object.is(+0, -0) 结果为 false
* Object.is(NaN, NaN) 结果为 true
* 其他场景下，Object.is 与 === 行为一致。

```js
console.log(Object.is(NaN, NaN));   // true

console.log(Object.is(+0, 0))  // true
console.log(Object.is(-0, 0))  // false
console.log(Object.is(+0, -0))  // false
```

### **基于严格相等（===）,模拟实现原生Object.is()方法**：    
额，貌似`方法2`更好理解

法1：
```js
Object.is = function(x, y) {
    if (x === y) { 
      // 解决 +0 和 -0 被 === 误判为相等的问题。如果 x 不是 0时，x !== 0为true，直接返回即可。否则解决 +0 === -0 的问题
      return x !== 0 || 1 / x === 1 / y; 
    } else {
      // 解决 NaN 和 NaN 被 === 误判为不相等的问题。只有当 x 和 y 都是 NaN 时，x !== x 和 y !== y 才会同时为 true，最终返回 true；否则返回 false。
      return x !== x && y !== y;  
    }
  };
```
**解析**：满足 `x !== 0` 条件的 x 值 只可能是 +0 或 -0。
```js
1/+0 === Infinity 
1/-0 === -Infinity
Infinity === -Infinity   // false
Infinity === Infinity   // true
-Infinity === -Infinity   // true
```

法2：
```js
function myObjectIs(a, b) {
  // 处理两个NaN不相等的问题
  if (a !== a) {
    return b !== b;
  }
  
  // 处理-0和+0的情况
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  
  // 其他情况使用严格相等
  return a === b;
}

// 测试用例
console.log(myObjectIs(2, 2)); // true
console.log(myObjectIs(2, "2")); // false
console.log(myObjectIs(NaN, NaN)); // true
console.log(myObjectIs(-0, +0)); // false
console.log(myObjectIs(null, null)); // true
console.log(myObjectIs(undefined, undefined)); // true
console.log(myObjectIs({}, {})); // false (不同对象引用)
```
