# 图片懒加载

参考：
* https://zhuanlan.zhihu.com/p/55311726
* https://juejin.cn/post/6905913705507078151

思路：
判断图片所在位置是否在可视区内，图片移到可视区内进行加载，提供四种判断方法：
```js
    使用浏览器原生 loading="lazy" 属性   // 有兼容性问题
    offsetTop < clientHeight + scrollTop // 元素距离"文档顶部"的距离 < 屏幕可视窗口高度 + 元素滚动的高度(浏览器窗口顶部 到 文档顶部之间的距离)
    element.getBoundingClientRect().top < clientHeight  // 元素顶部到可视窗口顶部的距离小于可视窗口的高度。
    IntersectionObserver
```
可以给img标签统一自定义属性data-src='default.png'，当检测到图片出现在窗口之后再补充src属性，此时才会进行图片资源加载。

参考：
* offsetTop等一堆专业名词，请参考：[clientX、Offset](../JS/clientX%20pageX等/readMe.md)
* [IntersectionObserver 详细信息](../JS/clientX%20pageX等/IntersectionObserver.md)
* [可视窗口详细信息](../JS/clientX%20pageX等/可视窗口.md)

```js
function lazyload() {
    const imgs = document.getElementsByTagName('img');
    const len = imgs.length;
    
    // 视口的高度
    const viewHeight = document.documentElement.clientHeight;
    
    // 滚动条高度
    const scrollHeight = document.documentElement.scrollTop || document.body.scrollTop;

    for (let i = 0; i < len; i++) {
        const offsetHeight = imgs[i].offsetTop;
        if (offsetHeight < viewHeight + scrollHeight) {
            const src = imgs[i].dataset.src;
            imgs[i].src = src;
        }
    }
}

// 可以使用节流优化一下
window.addEventListener('scroll', lazyload);
```

法2：
```js
const imgList = document.querySelectorAll(".lazyload");
const observer = new IntersectionObserver(entries => {
    entries.forEach(item => {
        if (item.intersectionRatio) {
            item.target.src = item.target.dataset.origin; // 判断在可视区了，把data-origin的值放到src
            observer.unobserve(item.target); // 已经加载过的图片停止进行监听
        }
    });
});
imgList.forEach(item => observer.observe(item));
```

## 其他 API 额外补充
大多数 JavaScript 处理的是以下坐标系其中一种：

* 相对于窗口：类似于 position: fixed，从 窗口 的顶部和两侧计算得出，用 clientX / clientY 表示
* 相对于文档：类似于 position: absolute，从 文档 的顶部和两侧计算得出，用 pageX / pageY 表示

![JS坐标体系](./icon/lazy-load.jpg)