# Docker


Docker是一种工具，主要是将应用及其依赖（如 Node.js、静态资源、配置）打包成一个「容器」，在开发、测试、生产环境中都能一致运行。
避免出现开发环境



传统部署流程，以前端应用为例：
1. 服务器相关：（应用+依赖+环境）
    * 环境准备：在 Linux 服务器（如 CentOS/Ubuntu）上安装 Web 服务器（Nginx/Apache）
    * 配置Web服务器：解决路由、缓存等问题（如：编辑Nginx配置文件）
2. 部署代码：
    * 本地执行 npm run build 生成静态资源（Vue 是 dist，React 是 build）；
    * 将静态资源上传到服务器的 Web 根目录，如使用FTP
3. 验证访问：浏览器输入服务器 IP / 域名，访问前端应用。

痛点：
* 开发、测试、生产环境可能会因为Node版本、依赖不同，而导致环境不一致（本地能跑，服务器崩了）
* 同一服务器部署多个应用时，**依赖版本冲突**（如 A 应用需 Node 14，B 需 Node 18）；
* 新增服务器、环境（开发、测试）时，需要重新走一遍新的部署流程！


## Docker的好处
1. 环境一致性，杜绝「本地能跑服务器崩」
把应用、依赖、运行环境（Nginx）打包成镜像，镜像在任何支持 Docker 的机器上启动的容器环境完全一致，彻底解决「版本不一致」「依赖缺失」问题。
2. 部署流程简化

无需在服务器手动安装环境、配置依赖，只需 2 条命令即可部署：
```
docker pull 镜像名:版本  # 拉取现成镜像（含应用+环境）
docker run -d -p 80:80 容器名  # 启动容器，自动运行应用
```

3. 可移植性强：迁移时只需复制镜像，无需修改配置；
4. 容器的沙箱隔离性：每个应用运行在独立容器中，拥有自己的文件系统、网络、进程空间：
5. 支撑 CI/CD 自动化，提升迭代效率


## 关键概念：
**镜像**：类似于某个软件的安装包，包含应用 + 依赖 + 环境，是静态只读 不可运行的，应用打包产物，可多次复用

***容器***：镜像的运行实例，是动态的（可读写、正在运行/可运行）。   
类似于双击「微信安装包」后，安装并启动的微信程序。会占用系统资源、有自己的运行状态、可以存储一些临时数据啥的。每个容器都是独立的沙箱环境，互不干扰。可通过命令启动（run）、停止（stop）、重启（restart）、删除（rm）。


## 关键结论
* 镜像 = 静态的「安装包」，容器 = 动态的「运行实例」—— 镜像启动后变成容器，容器停止后还是镜像；
* Dockerfile = 镜像的「制作步骤」，仓库 = 镜像的「存储分发平台」；
* 完整链路：写 Dockerfile → 构建镜像 → 上传仓库 → 下载镜像 → 启动容器。


## 其他相关概念
Linux 服务器（硬件 + Linux 系统）是 “地基”，Web 服务器（Nginx/Apache）是 “房子框架”

### Web 服务器
基本是 Nginx/Apache 两种

### tomcat 与 apache
Apache（全称 Apache HTTP Server）：处理静态资源（HTML/CSS/JS/ 图片）、做反向代理的 “静态资源管家”；

Tomcat（Apache Tomcat）：专门运行 Java 动态应用（JSP、Servlet、Spring Boot 项目）的 “Java 程序容器”；