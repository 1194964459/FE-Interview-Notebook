# WebAssembly

### 一、JS纯解释执行流程：
`JS 源码 → 解析为 AST → 解释器逐行翻译成机器码 → 逐行执行`
启动快，无需完整编译即可启动

运行时逐行翻译转为机器码，转完一行就执行一行，没有 “优化”“缓存” 步骤，

缺点：
1. 重复工作：比如一个循环执行 10000 次，解释器要把循环体代码重复翻译 10000 次，完全没有优化空间；
2. 在计算密集型场景（如循环、复杂函数）中性能极差。

### 二、编译型语言（如 C++）的流程是：
`源码 → 编译器提前编译为机器码（.exe 文件） → 运行时直接执行机器码`

运行快

编译结果会做优化、缓存，方便后续复用

### 三、JIT（Just In Time）即时编译 流程
结合了*编译执行(运行快)*和*解释执行(启动快)*的优点，在运行时进行优化

1. 初始时会先按照解释执行的流程来，将JS源码 边解释、边执行，执行时会收集执行信息（比如变量的实际类型、函数调用次数、循环执行次数）。
2. 识别热点代码，热点代码指的是被频繁调用的函数、或被多次执行的循环
3. 编译器优化：将热点代码 编译为 **优化后的机器码，并缓存在内存中**
4. 后续再执行某段热点代码时，直接复用 缓存的机器码 即可。

若代码有变化，会再次出发解释执行、热点代码收集...

## WebAssembly
WebAssembly 本质是 “将 C/C++/Rust 等原生代码，编译为浏览器 JS 引擎能高效执行的二进制指令”，

特点：
* 加载/执行快（接近 C/C++ 原生性能）；
* 二进制格式体积小，网络传输快；
* 安全：在浏览器沙箱中运行，不直接访问系统资源；
* 兼容：能和 JS 无缝交互，适配所有现代浏览器。

通过 “**静态类型、紧凑二进制格式、JIT 编译优化、沙箱隔离**”，在浏览器中实现接近原生的性能，同时通过 JS 桥接，承接 JS 搞不定的计算密集型任务（如图像、音视频、3D渲染等），与 JS 互补协同。





