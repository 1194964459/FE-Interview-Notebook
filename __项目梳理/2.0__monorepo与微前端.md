# monorepo 与 微前端

技术栈：monorepo + Lerna + pnpm/yarn

monorepo（单一代码仓库）是一种代码管理方式，在**一个单一的代码仓库**中管理**多个相关联的项目或模块**，而不是将它们分散到多个独立的仓库中。

特点：
* 共享依赖和工具配置（如 ESLint、TypeScript 等）
* 跨项目代码引用很方便（直接本地引用），无需发布 npm 包
* 统一的版本控制和 CI/CD 流程

潜在挑战：
* **仓库体积**可能随时间变得庞大
* 需要合理规划**权限管理**

## monorepo
三种依赖：
* 根目录：公共依赖，
* 子项目中单独装的包：私有依赖
* 内部包之间的依赖：具会自动在 node_modules 中创建软链接（symlink），将 A 对 B 的引用指向仓库内的 B 源码，无需发布到 npm。

scope指定单独的子包

常用工具：workspaces(npm、pnpm、yarn)、nx、lerna

monorepo中每个子包可以独立做哪些事情？答：**独立开发、测试、打包构建**、独立发布到npm仓库、**独立管理依赖**
```js
// 根目录 package.json
{
  "name": "my-monorepo",
  "private": true, // 必须设为 private，避免被发布到 npm
  "workspaces": [
    "packages/*", // 所有子项目放在 packages 目录下（支持通配符）
    "apps/*"      // 可选：单独存放应用类项目
  ],
}
```

## 循环依赖怎么解决？
package A 依赖package B，package B依赖package A

1. 提取公共模块 package C，将 A 和 B 都需要的通用逻辑（如类型定义、工具函数）移到 C 中；
2. 使用 “依赖注入” 解耦，`A(new B())`, `A 接收 B 的实例，B 接收 A 的实例`


madge：生成依赖关系图（可视化），直观展示循环依赖；
turborepo/nx：构建时会自动检测循环依赖并报错（基于任务依赖图）。

## 一、传统多仓库是如何协作的？
每个项目都放在一个单独的仓库中，项目间是完全隔离的。当项目 A 依赖项目 B 时，需要将 B 打包发布为 npm 包，A才能通过 npm install 引入。

* 而且**为解决一个问题，不同的项目都会提交对应的 PR**，也挺繁琐的，后续排查、追溯问题成本高

* 多仓库中，**每个仓库都需要独立维护一套工程化配置**（如 ESLint、Prettier、TypeScript、构建工具（Vite/Webpack）），**重复劳动，然后也可能因为规范不一致而导致代码风格错乱**等问题
> Monorepo 支持「根目录共享配置」，从根源上保证了所有项目的「工具版本、代码风格、构建流程」的一致性。


## 二、Monorepo有哪些替代方案？
* 传统的多仓库模式
* 混杂模式：介于monorepo、多仓库间的混合模式，将关联紧密的项目放在一个仓库，而关联较弱的项目单独建仓。
* Git Submodule/Git Subtree
* 本地开发环境：npm link；生产环境：私有包管理，如公司内部 npm 源

参考：[Monorepo有哪些替代方案？](https://www.doubao.com/thread/w257af16772696f6f)


### Git Submodule是什么？怎么用？
Git Submodule 允许在一个 Git 仓库（主仓库）中包含另一个 Git 仓库（子仓库），基本操作：
* **添加子模块**：在主仓库中，使用命令 `git submodule add <url> <path>`，其中 `<url>` 是子仓库的地址，`<path>` 是子仓库在主仓库中存放的路径。例如：`git submodule add https://github.com/example/component-library.git components` ，会在主仓库的 components 目录下添加 component-library 子仓库。

* **克隆包含子模块的仓库**：**克隆时，默认只会克隆主仓库**。 子模块需要执行 `git submodule init` 和 `git submodule update` 来初始化和更新子模块

* **更新子模块**：*进入子模块目录*，拉取最新代码（如 git pull），然后在主仓库中提交对子模块状态的更改（记录子模块新的提交哈希值）。


### 发npm包与Git Submodule模式的区别：
Git Submodule：子仓库的代码以源码形式存在主仓库的目录中。
npm包：安装在node_modules目录下，开发者使用的是编译或打包后的代码


[workspace、手动 npm link 或发布npm包到仓库，三个比较一下；还有更好的方式吗](https://www.doubao.com/thread/wb3c19765735a65ee)  
三者都是管理本地包依赖的：
* 发npm包：多个包之间是完全隔离的，适合跨团队共享。但是每次都需要发包、安装新包...
* npm link：临时跨仓库调试，仅本地有效
* workspace：npm、pnpm、yarn都有对应的workspace，会将依赖提升到根目录，代码修改后实时生效，比较适合Monorepo 多包长期协作场景

## 三、npm、pnpm、yarn 三者对比
通过 npm、pnpm、yarn 安装的包：
* 先从 npm 仓库（或镜像）下载包到 全局缓存目录（第一次安装时）；
* 再将缓存中的包复制/链接到当前项目的 node_modules 中（供项目代码直接引用）。

所以安装的包会存在两个地方：项目本地的 node_modules 和 包管理器的全局缓存目录（用于复用，避免重复下载）。

不同包管理器的全局缓存位置，以Mac电脑为主：
* npm：~/.npm（~ 代表用户目录）
* yarn：~/.yarn/cache
* pnpm：~/.pnpm-store

### 不同包管理器如何处理 “从全局缓存到项目” 的过程？

npm/yarn：从全局缓存**复制文件**到项目 node_modules。
缺点：如果多个项目依赖同一个包，每个项目的 node_modules 中都会有一份完整的复制，占用磁盘空间多（比如 10 个项目用 react@18，就有 10 份复制）。

pnpm：从全局缓存硬链接到项目 node_modules（而不是复制）。
硬链接的特性是：多个链接指向同一个文件，磁盘上只存一份数据。
优点：10 个项目用 react@18，磁盘上只有 1 份 react 数据，所有项目通过硬链接引用，极大节省空间。


**安装速度**(从快到慢排序)：pnpm > yarn > npm   
**磁盘空间利用率**（从高到低排序）：pnpm > yarn > npm   
**是否有幽灵依赖**（未声明却可引用）：pnpm 没有（仅允许显式声明的依赖）、yarn存在（但比 npm 更可控），npm存在（子依赖可能被提升到根目录）

* pnpm：    
    下面的1、2的描述指的是采用 “内容寻址存储” 和硬链接

    1. 全局存储：所有安装过的包会被缓存到一个全局仓库（如 ~/.pnpm-store），相同版本的包仅存储一次，通过 硬链接 链接到项目的 node_modules 中（硬链接不占用额外磁盘空间）。
    2. 虚拟存储目录（.pnpm）：项目的 node_modules 下会生成一个 .pnpm 目录，存放所有包的硬链接，而实际引用的包（如 react）则通过 符号链接（symlink） 指向 .pnpm 中的对应版本，确保依赖版本精确匹配。
    3. **严格的依赖隔离：默认不 “提升” 依赖**（hoist），每个包只能访问自己声明的依赖，避免不同项目间的版本冲突（例如 A 依赖 lodash@4.17.0，B 依赖 lodash@4.17.20，会分别链接到各自版本，互不干扰）。

    >  全局缓存到项目（硬链接）、项目内（软链接，实现跨包引用）

* yarn：基于缓存的并行安装，
* npm：早期采用扁平依赖树，后来有优化成嵌套模式；缓存机制较基础，重复安装相同包时效率一般；

yarn与npm的缺点：**依赖 hoisting（提升）**可能导致幽灵依赖、版本冲突（不同子项目依赖同一包的不同版本时，可能被覆盖）。



[什么是Workspaces特性？](https://www.doubao.com/thread/w5ca2a17f9fb57cab)
* 依赖共享与提升：当多个子包依赖同一个相同的 npm 包时，Workspaces 会将依赖统一安装到根目录的 node_modules 中，而非在每个子包中重复安装
* 简化跨包引用：子包之间可以像引用外部 npm 包一样直接依赖，无需手动 npm link 或发布到仓库。
    > 子包 B 依赖子包 A 时，只需在 B 的 package.json 中声明 "dependencies": { `"package-a": "workspace:*"` }或者用版本号替代`workspace:*`，Workspaces 会自动处理本地符号链接，确保 B 始终使用最新的 A 代码。


[monorepo中的每个子包，相当于都是独立的呗...独立开发、构建、部署啥的，那他很真正的一个单独的项目有什么区别？](https://www.doubao.com/thread/wcbad1b6c63d48209)

monorepo中每个子包可以独立做哪些事情？答：独立开发、测试、打包构建、独立发布到npm仓库、独立管理依赖

## 四、微前端
微前端是一种**将前端应用拆分为多个小型、独立、可自治的 “微应用”**，再将它们整合为一个完整产品的架构模式。核心是 “**分而治之**”，让**不同团队**能独立开发、部署微应用，同时**用户**感知到的是一个统一的 App。
> 每个微应用可以看作一个 “迷你前端项目”

**各微应用有独立的代码仓库，可独立开发、部署**。**每个应用用可自主选择技术栈，互不干扰**，如 A 用 React，B 用 Vue，C 用 Angular。

疑问：微前端 分而治之，那是怎么整合在一起呢？
答：通过**基座应用（Shell）** 将多个独立的微应用（MicroApp）有机地组合在一起，微前端的 “容器”，负责统筹所有微应用，主要作用包括：
* 统一的公共UI：如侧边栏、页脚等
* 提供全局基础设施：权限管理、全局状态、路由分发
* 微应用之间的隔离与通信

微前端技术选型：
* qiankun（推荐，阿里系，国内主流）
* single-spa（微前端鼻祖，偏底层）
* Micro-App（京东系，基于 Web Components）
* 模块联邦 Module Federation（Webpack 5 内置，偏代码共享）


## 微前端 与 monorepo 有什么区别？
* 微前端：解决 “应用级” 的拆分与整合，核心是 **runtime 层面的独立与协同**，每个应用可以有自己独立的仓库啥的..
* Monorepo：解决 “仓库级” 的组织与共享，核心是 **开发/构建层面的效率与规范**，只有一个仓库..


| 维度| 	微前端|  	Monorepo| 
| ---- | ---- | ---- | 
| 本质定位| 前端**架构模式**（解决 “应用级” 整合问题）	| **代码管理策略**（解决 “仓库级” 组织问题）| 
| 核心目标|  **多应用独立开发、独立部署、 runtime 整合**	| 多项目**共享代码**、统一**工程规范**、简化**依赖管理**| 
| “分治” 的对象	| 独立的 “微应用”（如：电商的商品页、购物车页、结算页）| 	同一个仓库下的 “子项目/模块”（如：组件库、工具库、APP 项目）| 
| 运行时关系| 	多个微应用在浏览器中**独立运行或组合运行**| 子项目通常是**编译/构建时依赖关系**（如 APP 依赖组件库）| 
| 技术核心|  应用加载、路由分发、状态隔离、样式隔离	| 仓库管理、依赖 hoisting、构建工具（如 Turborepo）| 

两者可独立使用，也可结合使用（最常见）

结合使用时的目录结构如下：
```js
monorepo-root/
├── packages/          # 共享包
│   ├── ui-components/ # 公共组件库
│   ├── utils/         # 工具函数库
│   └── api/           # 接口封装库
├── apps/              # 应用项目
│   ├── web-app/       # 网页应用
│   └── mobile-app/    # 移动端应用
```