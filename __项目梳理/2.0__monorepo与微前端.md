# monorepo 与 微前端

技术栈：monorepo + Lerna + pnpm/yarn

monorepo（单一代码仓库）是一种代码管理方式，在**一个单一的代码仓库**中管理**多个相关联的项目或模块**，而不是将它们分散到多个独立的仓库中。

特点：
* 共享依赖和工具配置（如 ESLint、TypeScript 等）
* 跨项目代码引用很方便（直接本地引用），无需发布 npm 包
* 统一的版本控制和 CI/CD 流程

潜在挑战：
* **仓库体积**可能随时间变得庞大
* 需要合理规划**权限管理**

常用工具：workspaces(npm、pnpm、yarn)、nx、lerna

monorepo中每个子包可以独立做哪些事情？答：**独立开发、测试、打包构建**、独立发布到npm仓库、**独立管理依赖**

## 一、传统多仓库是如何协作的？
每个项目都放在一个单独的仓库中，项目间是完全隔离的。当项目 A 依赖项目 B 时，需要将 B 打包发布为 npm 包，A才能通过 npm install 引入。

* 而且**为解决一个问题，不同的项目都会提交对应的 PR**，也挺繁琐的，后续排查、追溯问题成本高

* 多仓库中，**每个仓库都需要独立维护一套工程化配置**（如 ESLint、Prettier、TypeScript、构建工具（Vite/Webpack）），**重复劳动，然后也可能因为规范不一致而导致代码风格错乱**等问题
> Monorepo 支持「根目录共享配置」，从根源上保证了所有项目的「工具版本、代码风格、构建流程」的一致性。


## 二、Monorepo有哪些替代方案？
* 传统的多仓库模式
* 混杂模式：介于monorepo、多仓库间的混合模式，将关联紧密的项目放在一个仓库，而关联较弱的项目单独建仓。
* Git Submodule/Git Subtree
* 本地开发环境：npm link；生产环境：私有包管理，如公司内部 npm 源

参考：[Monorepo有哪些替代方案？](https://www.doubao.com/thread/w257af16772696f6f)


### Git Submodule是什么？怎么用？
Git Submodule 允许在一个 Git 仓库（主仓库）中包含另一个 Git 仓库（子仓库），基本操作：
* **添加子模块**：在主仓库中，使用命令 `git submodule add <url> <path>`，其中 `<url>` 是子仓库的地址，`<path>` 是子仓库在主仓库中存放的路径。例如：`git submodule add https://github.com/example/component-library.git components` ，会在主仓库的 components 目录下添加 component-library 子仓库。

* **克隆包含子模块的仓库**：**克隆时，默认只会克隆主仓库**。 子模块需要执行 `git submodule init` 和 `git submodule update` 来初始化和更新子模块

* **更新子模块**：*进入子模块目录*，拉取最新代码（如 git pull），然后在主仓库中提交对子模块状态的更改（记录子模块新的提交哈希值）。


### 发npm包与Git Submodule模式的区别：
Git Submodule：子仓库的代码以源码形式存在主仓库的目录中。
npm包：安装在node_modules目录下，开发者使用的是编译或打包后的代码


[workspace、手动 npm link 或发布npm包到仓库，三个比较一下；还有更好的方式吗](https://www.doubao.com/thread/wb3c19765735a65ee)  
三者都是管理本地包依赖的：
* 发npm包：多个包之间是完全隔离的，适合跨团队共享。但是每次都需要发包、安装新包...
* npm link：临时跨仓库调试，仅本地有效
* workspace：npm、pnpm、yarn都有对应的workspace，会将依赖提升到根目录，代码修改后实时生效，比较适合Monorepo 多包长期协作场景

## 三、npm、pnpm、yarn 三者对比
**安装速度**(从快到慢排序)：pnpm > yarn > npm   
**磁盘空间利用率**（从高到低排序）：pnpm > yarn > npm   
**是否有幽灵依赖**（未声明却可引用）：pnpm 没有（仅允许显式声明的依赖）、yarn存在（但比 npm 更可控），npm存在（子依赖可能被提升到根目录）

* pnpm：采用「内容寻址存储」+ 硬链接/符号链接，全局存储不重复包；依赖树严格非扁平
* yarn：基于缓存的并行安装，
* npm：早期采用扁平依赖树，后来有优化成嵌套模式；缓存机制较基础，重复安装相同包时效率一般；


[什么是Workspaces特性？](https://www.doubao.com/thread/w5ca2a17f9fb57cab)
* 依赖共享与提升：当多个子包依赖同一个相同的 npm 包时，Workspaces 会将依赖统一安装到根目录的 node_modules 中，而非在每个子包中重复安装
* 简化跨包引用：子包之间可以像引用外部 npm 包一样直接依赖，无需手动 npm link 或发布到仓库。
    > 子包 B 依赖子包 A 时，只需在 B 的 package.json 中声明 "dependencies": { "package-a": "workspace:*" }，Workspaces 会自动处理本地符号链接，确保 B 始终使用最新的 A 代码。


[monorepo中的每个子包，相当于都是独立的呗...独立开发、构建、部署啥的，那他很真正的一个单独的项目有什么区别？](https://www.doubao.com/thread/wcbad1b6c63d48209)

monorepo中每个子包可以独立做哪些事情？答：独立开发、测试、打包构建、独立发布到npm仓库、独立管理依赖

## 四、微前端
微前端是一种**将前端应用拆分为多个小型、独立、可自治的 “微应用”**，再将它们整合为一个完整产品的架构模式。核心是 “**分而治之**”，让**不同团队**能独立开发、部署微应用，同时**用户**感知到的是一个统一的 App。
> 每个微应用可以看作一个 “迷你前端项目”

**各微应用有独立的代码仓库，可独立开发、部署**。**每个应用用可自主选择技术栈，互不干扰**，如 A 用 React，B 用 Vue，C 用 Angular。

疑问：微前端 分而治之，那是怎么整合在一起呢？
答：通过**基座应用（Shell）** 将多个独立的微应用（MicroApp）有机地组合在一起，微前端的 “容器”，负责统筹所有微应用，主要作用包括：
* 统一的公共UI：如侧边栏、页脚等
* 提供全局基础设施：权限管理、全局状态、路由分发
* 微应用之间的隔离与通信

微前端技术选型：
* qiankun（推荐，阿里系，国内主流）
* single-spa（微前端鼻祖，偏底层）
* Micro-App（京东系，基于 Web Components）
* 模块联邦 Module Federation（Webpack 5 内置，偏代码共享）


## 微前端 与 monorepo 有什么区别？
* 微前端：解决 “应用级” 的拆分与整合，核心是 **runtime 层面的独立与协同**，每个应用可以有自己独立的仓库啥的..
* Monorepo：解决 “仓库级” 的组织与共享，核心是 **开发/构建层面的效率与规范**，只有一个仓库..


| 维度| 	微前端|  	Monorepo| 
| ---- | ---- | ---- | 
| 本质定位| 前端**架构模式**（解决 “应用级” 整合问题）	| **代码管理策略**（解决 “仓库级” 组织问题）| 
| 核心目标|  **多应用独立开发、独立部署、 runtime 整合**	| 多项目**共享代码**、统一**工程规范**、简化**依赖管理**| 
| “分治” 的对象	| 独立的 “微应用”（如：电商的商品页、购物车页、结算页）| 	同一个仓库下的 “子项目/模块”（如：组件库、工具库、APP 项目）| 
| 运行时关系| 	多个微应用在浏览器中**独立运行或组合运行**| 子项目通常是**编译/构建时依赖关系**（如 APP 依赖组件库）| 
| 技术核心|  应用加载、路由分发、状态隔离、样式隔离	| 仓库管理、依赖 hoisting、构建工具（如 Turborepo）| 

两者可独立使用，也可结合使用（最常见）

结合使用时的目录结构如下：
```js
monorepo-root/
├── packages/          # 共享包
│   ├── ui-components/ # 公共组件库
│   ├── utils/         # 工具函数库
│   └── api/           # 接口封装库
├── apps/              # 应用项目
│   ├── web-app/       # 网页应用
│   └── mobile-app/    # 移动端应用
```