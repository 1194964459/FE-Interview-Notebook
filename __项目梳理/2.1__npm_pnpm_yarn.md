# npm、pnpm、yarn 比较

## Yarn为什么会产生？
早期 npm 在 “**速度、版本一致性、稳定性、离线能力**” 上的短板

**1. 速度**：
    (1) 串行下载：一个下载完之后才能下载另一个
    (2) 重复下载：每次安装依赖，无论该包是否已下载过，npm 都会重新从远程仓库下载，重复消耗网络资源和时间
    
    > yarn： 并行下载，引入 全局缓存（下载过的包会缓存到本地，后续项目复用无需重复下载）

**2.一致性**：
    早期npm没锁定依赖的精确版本：是“模糊版本”（如 ^1.2.3，表示兼容 1.x.x 最新版），这样不同时间、环境拉取的版本可能不一致
    (包版本：主版本、次版本、修订版本。版本范围符号：^（次+修订可修改） ~（仅修订版本） > < )
    
    > yarn：自动生成 yarn.lock 锁定文件，安装时会记录所有依赖（包括直接依赖、间接依赖）的精确版本、下载地址、校验值

    > npm在 v5 版本才借鉴 yarn 推出 package-lock.json    

**3.安装过程不稳定**，当网络波动或下载大文件时容易“下载中断”“校验失败”，也没重试机制；
    
    > Yarn解决：引入校验、重试机制

4.早期 npm 完全依赖网络，缺乏**离线安装**能力
     
    > Yarn解决：基于全局缓存实现 离线安装


## npm 与 yarn 的问题
1. “拷贝式存储”

2. 为了减少依赖嵌套深度（避免 node_modules/a/node_modules/b/node_modules/c 这种多层嵌套），采用**扁平化逻辑**；a 依赖 b，b 依赖 c，c这种间接依赖可能被提升到根目录，造成“幽灵依赖”，另外幽灵依赖扁平化后只能保留一个版本（通常是最新版），会有**版本冲突的隐患**。

通过 npm、pnpm、yarn 安装的包：
* 先从 npm 仓库（或镜像）下载包到 全局缓存目录（第一次安装时）；
* 再将缓存中的包复制/链接到当前项目的 node_modules 中（供项目代码直接引用）。

所以安装的包会存在两个地方：项目本地的 node_modules 和 包管理器的全局缓存目录（用于复用，避免重复下载）。

不同包管理器的全局缓存位置，以Mac电脑为主：
* npm：~/.npm（~ 代表用户目录）
* yarn：~/.yarn/cache
* pnpm：~/.pnpm-store

### 不同包管理器如何处理 “从全局缓存到项目” 的过程？

npm/yarn：从全局缓存**复制文件**到项目 node_modules。
缺点：如果多个项目依赖同一个包，每个项目的 node_modules 中都会有一份完整的复制，占用磁盘空间多（比如 10 个项目用 react@18，就有 10 份复制）。

pnpm：从全局缓存硬链接到项目 node_modules（而不是复制）。
硬链接的特性是：多个链接指向同一个文件，磁盘上只存一份数据。
优点：10 个项目用 react@18，磁盘上只有 1 份 react 数据，所有项目通过硬链接引用，极大节省空间。


**安装速度**(从快到慢排序)：pnpm > yarn > npm   
**磁盘空间利用率**（从高到低排序）：pnpm > yarn > npm   
**是否有幽灵依赖**（未声明却可引用）：pnpm 没有（仅允许显式声明的依赖）、yarn存在（但比 npm 更可控），npm存在（子依赖可能被提升到根目录）

* pnpm：    
    下面的1、2的描述指的是采用 “内容寻址存储” 和硬链接

    1. 全局存储：所有安装过的包会被缓存到一个全局仓库（如 ~/.pnpm-store），相同版本的包仅存储一次，通过 硬链接 链接到项目的 node_modules 中（硬链接不占用额外磁盘空间）。
    2. **虚拟存储目录**（.pnpm）：项目的 node_modules 下会生成一个 **.pnpm 目录，存放所有包的硬链接**，而*实际引用的包*（如 react）则通过 符号链接（symlink） 指向 .pnpm 中的对应版本，确保依赖版本精确匹配。
    3. **严格的依赖隔离：默认不 “提升” 依赖**（hoist），每个包只能访问自己声明的依赖，避免不同项目间的版本冲突（例如 A 依赖 lodash@4.17.0，B 依赖 lodash@4.17.20，会分别链接到各自版本，互不干扰）。

    >  全局缓存到项目（硬链接）、项目内（软链接，实现跨包引用）

* yarn：基于缓存的并行安装，
* npm：早期采用扁平依赖树，后来有优化成嵌套模式；缓存机制较基础，重复安装相同包时效率一般；

yarn与npm的缺点：**依赖 hoisting（提升）**可能导致**幽灵依赖**、版本冲突（不同子项目依赖同一包的不同版本时，可能被覆盖）。

## 硬链接与软链接
在包管理器（或操作系统）中，硬链接是指对**同一个文件**有多个名称（硬链接和原始文件共享相同的 inode 和数据块），删除任一名称不会影响文件本身，直到所有名称都被删除；


而软链接是一个**独立的文件**，它存储的是指向原始文件的路径，类似于快捷方式；软链接的内容是一个路径，而不是文件数据本身。
