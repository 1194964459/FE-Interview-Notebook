# Echarts 

参考：https://echarts.apache.org/handbook/zh/best-practices/canvas-vs-svg

Echarts优化：
https://www.doubao.com/thread/we4015e04e6d80a73


* 数据采样（减少渲染点数，sampling配置） 
* Canvas渲染（减少 DOM 节点开销） 
* 关闭动画：动画会增加渲染帧计算，大数据场景可关闭
* 基于dataZoom 组件，数据按时间/范围分片加载，初始只加载可见范围内的数据
* WebGL 加速（适合超大数据）


![echarts](./icon/echarts.jpg)
![echarts2](./icon/echarts2.jpg)

数据采样/降采样：当数据量非常大时，直接渲染所有数据点性能会比较差。数据采样就是在不丢失关键信息（像数据的峰值、谷值、趋势变化的拐点等）的前提下，筛选出一部分最能代表原始数据特征的点进行渲染，从而降低渲染负担。

核心是通过减少实际渲染的数据点数量，

## 使用 Canvas渲染？SVG渲染？
在 v5.3.0 中使用虚拟 DOM 技术对 SVG 渲染器进行了重构，从而使其渲染性能提升了 2~10 倍，在某些特殊场景中甚至能有数十倍的提升

### canvas渲染：
* 基于Canvas绘制，Canvas 是一个单一的 DOM 元素，其内部绘制的图形（如线条、矩形等）是像素的集合，并非独立的 DOM 节点。内部绘制的元素是不能直接做DOM 事件绑定的，需通过其他方式：
    * ① 类似于事件委托，监听Canvas元素本身的DOM事件，
    * ② 获取事件在 Canvas 中的坐标，(如通过getBoundingClientRect()转换）)，手动判断当前落在哪个绘制图形的范围内了？
* canvas的内存占用，主要取决于“像素画布”的尺寸大小，如果画布尺寸比较大 会占用比较多的内存。
* 适合绘制图形元素数量较多（这一般是由数据量大导致）的图表。


### SVG渲染：
* SVG为每个图形创建独立的 DOM 节点，每个节点会占用额外的内存（存储属性、样式、事件等信息）。
    * 当数据量很大时，大量 DOM 节点会导致内存急剧增加，甚至引发浏览器卡顿。
    * 支持对每个SVG元素做DOM 事件绑定，交互响应更细腻。

* 缩放时，清晰度不受影响。
* 适合处理中小数据量图标、有高清需求、适合复杂交互的


## 矢量图与位图
矢量图不会失真，存储的是“图形的数学描述”。
* 当要渲染一张矢量图时，寿险读取矢量图的数学指令（比如圆的圆心、半径）进行解析；
* 然后根据当前屏幕的 “像素密度（PPI）”，计算出这个圆需要占用多少个物理像素点，屏幕越高清 占用的像素越多

    > 像素密度（PPI，Pixels Per Inch）：每英寸（2.54 厘米）屏幕上的物理像素数量，计算公式：
    > `PPI = √(横向物理像素² + 纵向物理像素²) ÷ 屏幕对角线长度（英寸）`

两者的区别：
* 矢量图是 “动态适配像素”，
* 位图存的是 “固定数量的像素点”，
    > 比如：50×50 像素，放大 2 倍后，只能把原有像素拉伸成 200×200，像素点被强行放大，就会模糊失真。

有无锯齿？
* 矢量图时没锯齿的：无论放大多少倍，边缘始终由数学计算生成，通过抗锯齿优化保持平滑，无原生锯齿。
* 位图：放大后像素拉伸，边缘直接出现明显锯齿（本质是像素断层）。