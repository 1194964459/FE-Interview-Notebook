# 长列表渲染
参考：
https://juejin.cn/post/7354940230301057033

https://juejin.cn/post/7031923575044964389?from=search-suggest#heading-4

如：后端返回10万条数据渲染，直接渲染会导致页面长时间卡顿甚至崩溃。

核心解决思路：避免一次性创建所有 DOM 节点，通过 “按需渲染” 或 “虚拟化” 思想，只渲染当前视口内可见的数据，从而将 DOM 节点数量控制在几百个以内，实现流畅交互。

主要方式：
1. 直接渲染10w条数据，会触发大量的重绘重排，强烈不推荐！
2. 分片渲染 + requestAnimationFrame/setTimeout 
    > 此处若使用setTimeout而不是requestAnimationFrame，页面会有一段时间是空白的，会闪屏
3. 虚拟滚动列表
4. 懒加载：每次加载一部分数据，滚动到页面底部触底时再加载另外一批数据，直到最后加载完或者用户不滚动页面。
    > 参考：[懒加载与判断是否在可视窗口内](../JS/clientX%20pageX等/___滚动各种情况__.md)
5. 基于成熟的虚拟列表库，如：vue-virtual-scroller	
6. 配合后端优化：分页加载


## 一、createDocumentFragment
用于创建一个文档片段，文档片段本身并不存在于 DOM 树中，它只存在于内存中。

如果不使用文档片段，将多个 DOM 元素逐个添加到真实 DOM 树时，每添加一个元素都会触发一次浏览器对DOM 的重排（reflow）。

改进：使用DocumentFragment，可以将所有需要添加的元素先添加到内存中的DocumentFragment，然后一次性将DocumentFragment 添加到真实DOM 树中。这样只需要触发一次重排。

```js
const list = document.getElementById('myList');
const fragment = document.createDocumentFragment();
const data = ['苹果', '香蕉', '橙子', '葡萄'];
data.forEach((item) => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
});
list.appendChild(fragment);
```

## 二、分片渲染
将十万条数据拆分成多个 “分片”（如每片 100 条），利用requestIdleCallback或setTimeout分批创建 DOM，利用浏览器空闲时每次渲染一个分片，直到所有分片完成。

创建DOM时，先基于createDocumentFragment()批量创建文档片段，然后再将这些文档片段一次性插到页面中。

这种方式不是阻塞主线程，但最终仍会创建十万个 DOM 节点，不适用长列表滚动场景。

注意：分片渲染和分页渲染是不一样的。
* 分片渲染：前端在获取到全部数据后，自行管理渲染的批次和时机。用户感知不到数据是分批次渲染的
* 分页渲染：需要前端和后端配合完成。需要前端点击页码、“上一页”“下一页” 按钮等操作。后端提供接口支持根据页码和每页数据量获取对应数据。

```js
<ul id="list"></ul>
<script>
  // 模拟10万条数据
  const data = Array.from({ length: 100000 }, (_, i) => `第 ${i + 1} 条数据`);
  const list = document.getElementById('list');
  const chunkSize = 100; // 每片100条
  let currentChunk = 0;

  // 分片渲染函数
  function renderChunk() {
    const start = currentChunk * chunkSize;
    const end = Math.min(start + chunkSize, data.length);
    const fragment = document.createDocumentFragment(); // 减少重排：先存到文档片段

    for (let i = start; i < end; i++) {
      const li = document.createElement('li');
      li.textContent = data[i];
      fragment.appendChild(li);
    }

    list.appendChild(fragment);
    currentChunk++;

    // 未渲染完，继续下一片
    if (currentChunk * chunkSize < data.length) {
      requestIdleCallback(renderChunk); // 浏览器空闲时执行
      // 兼容性兜底：setTimeout(renderChunk, 0);
    }
  }

  // 启动渲染
  renderChunk();
</script>
```

## 三、虚拟滚动/虚拟列表
只渲染可视区+上下缓冲区的数据

这种方式：创建的DOM节点数少了好多，性能优异

参考：[原生js实现虚拟滚动](./原生js实现虚拟滚动.html)

* 计算每条数据的高度（固定高度最简单，动态高度需额外处理）。
* 计算当前视口内数据的起始/结束索引。
* 监听滚动事件，实时更新渲染内容。

起始索引怎么算？scrollTop/itemHeight,，即：容器滚动的距离/每条数据的固定高度。**通过transform: translateY()让渲染区域 “对齐” 滚动位置，造成 “10万条数据在渲染” 的视觉效果**。
```js
// 计算跳过的完整条数（向下取整，确保只跳过整数条）
const startIndex = Math.floor(scrollTop / itemHeight); 
// 偏移距离 = 完整条数 × 单条高度（确保对齐到完整项）
const offsetY = startIndex * itemHeight; 
content.style.transform = `translateY(${offsetY}px)`;
```

### transform：translateY()的重要性
为什么不用 top/margin-top？
transform属性的操作是由浏览器的合成线程处理的，不会触发重排，只会触发重绘，在某些情况下甚至可以直接在 GPU 层处理，性能极高。如果使用top、margin-top等属性来改变元素位置，会触发重排。比较消耗性能，造成页面卡顿。

**虚拟列表的核心**是：
* 给容器设置一个虚假的总高度（totalHeight = 数据总数 × 单条高度），让滚动条 “以为” 列表很长。
* 但实际只渲染视口内的少量数据（比如当前可视区 + 缓冲数据）。

如果去掉 transform会怎样？
* 容器的滚动条是基于 “虚假总高度” 生成的（比如总高度 10000px），可以正常拖动。
* 但**渲染的内容永远从容器顶部开始**，和滚动条的位置完全脱节。

如果不用 transform 偏移，用户会看到 “第 11 条数据出现在容器最顶部”，但滚动条明明滚了 300px—— 视觉上完全不匹配，仿佛滚动 “卡住” 了。

## 四、基于成熟的虚拟列表库
如：vue-virtual-scroller	