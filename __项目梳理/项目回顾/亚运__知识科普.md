# 亚运·知识科普

基于webAR SDK做前端AR开发，这个webARSDK会暴漏一些方法、事件给我们，通过调用这些来获取AR能力。

除了底层SLAM算法、3D渲染相关的，其余都我们来做的。出了问题后也是我们前端团队先来排查、定位问题。
如果是算法相关的就找算法同学，自己能修改的渲染、接口问题 就自己来，搞不了的 请教一下渲染同学。界面UI、业务逻辑啥的都是前端实现的。

前端实现的具体业务：
* 进入AR页面时的加载（加载中的进度、加载失败）、
* 与定位相关的数据权限的申请，如蓝牙、GPS、摄像头；（权限也分3层校验：手机、支付宝、小程序）
* 不同定位状态的实现（定位前的引导提示、定位中、定位成功、定位失败、失败的具体原因的呈现），定位成功后音频、


AR平台：
> POI点：在哪体验AR功能、导航点位（园区入口、某个具体的看台等）；
> POI打点、通过接口获取POI点、POI点挂载模型资源等。
> 采集数据后建图、地图部署、定位配置（园区、建筑、区块来）

```js
    // 资源加载：初始化加载、加载进度、加载完成、加载失败
    AREngine.subscribe(cityar.InitResourceStartEventArgs.ClassType, this.OnInitResourceStart, this)
    AREngine.subscribe(cityar.InitResourceUpdateEventArgs.ClassType, this.OnInitResourceUpdate, this)
    AREngine.subscribe(cityar.InitResourceDoneEventArgs.ClassType, this.OnInitResourceDone, this)
    AREngine.subscribe(cityar.InitResourceFailureEventArgs.ClassType, this.OnInitResourceFailure, this)
    
    // 读取POI的状态（成功、失败）；若成功了则开始走定位逻辑..
    AREngine.subscribe(know.ShowExperienceSuccessEventArgs.ClassType, this.OnShowExperienceSuccess, this)
    AREngine.subscribe(know.ShowExperienceFailureEventArgs.ClassType, this.OnShowExperienceFailure, this)
    
    // 定位请求 成功、失败..
    AREngine.subscribe(stxr.LocateRequestSuccessEventArgs.ClassType, this.OnXRSessionLocateSuccess, this)
    AREngine.subscribe(stxr.LocateRequestFailureEventArgs.ClassType, this.OnXRSessionLocateFailure, this)
    AREngine.subscribe(stxr.LocateRequestingFailureEventArgs.ClassType, this.OnXRSessionLocatingFailure, this)

    // 知识科普动画播放结束
    AREngine.unsubscribe(know.KnowAnimationEventArgs.ClassType, this.KnowAnimationEnd, this)
```

cityAR中Experience，一次AR体验过程：
```js
declare class ExperienceComponent {
    private m_ExperiecenInfos;
    private m_ExpericeController;
    constructor();

    // XR引擎初始化成功后添加Experience
    AddExperience<T extends stxr.BaseExperience>(experienceName: string, experience: (new () => T)): void;

    // OnShowExperienceSuccess
    GetExperience(experienceName: string): stxr.BaseExperience;
        
    // 知识科普等模型资源，加载完成后
    EnterExperience(expName: string, context?: any): void;
    Enter(mapKey: string): void;
 
    Update(elapseSeconds: number): void;

    // 前端页面卸载时调用
    Leave(mapKey: string): void;
    LeaveCurrent(): void;
}
```

## 如何实现点击点击三维的运动科普项目 在 2D页面中展示呢？
在 Three.js 中，判断点击的是**模型的哪个面片**，主要通过射线来检测与场景中物体的相交情况。

```js
// 当鼠标点击屏幕时，获取鼠标的屏幕坐标，然后从相机位置 向 鼠标点击的屏幕位置 发射一条射线。
const raycaster = new THREE.Raycaster(); 
const mouse = new THREE.Vector2();
function onMouseClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
}

// 进行射线检测：使用射线与场景中的物体进行相交检测，
const intersects = raycaster.intersectObjects(scene.children);

// 判断点击的面片是哪个？
if (intersects.length > 0) {
    const clickedObject = intersects[0].object;
    const faceIndex = intersects[0].faceIndex; // 获取相交面片的索引
    console.log('点击的物体是:', clickedObject.name);
    console.log('点击的面片索引是:', faceIndex);
}
```

亚运项目中的源码是：
```js
async onRaycast(e) {
    const { pageX, pageY } = e.detail
    console.info(`onRaycast ${pageX} ${pageY}`)
    const screenPoint = new stxr.Vector3(pageX, pageY, 0)
    const ray = stxr.Camera.main.ScreenPointToRay(screenPoint)
    const hit = stxr.Ref()
    if (stxr.Physics.Raycast(ray, hit)) {  
        const poi = this.PrefYYHPosAndImage[this.poiIdx]
        if (!poi) return
        const sportInfo = await getSportInfoByHitPoly(poi.resource.resourceId, hit.target.transform.name)
        sportInfo && this.selectSportInfo(sportInfo)
    }
}
```