# 为什么React有Fiber架构，vue却不需要?
（同样的问题：为什么Vue3不需要时间分片？）

Fiber是啥？它是 React 为解决 “同步渲染阻塞浏览器主线程” 问题而设计的**可中断、可恢复的，按优先级调度的引擎**。

React中当组件状态变化时，React不知道“具体哪个节点需要更新？”，然后会从触发更新的组件开始，递归遍历整个子组件树。任务庞大、还是同步工作，因此会阻塞主线程。

参考：[Fiber详解](../__前端工程化/React/3.0__Fiber详解.md)

## Vue 为啥不需要Fiber？
通过**响应式机制、编译时优化**，从**根源上**避免了“同步遍历庞大任务”的产生，因此不需要单独的 “Fiber 调度架构”。

### 1. 响应式机制：精准定位变更范围
参考：[Vue 响应式原理](../Vue/2.0__响应式实现.md)

当状态变化时，Vue 能精准知道 “哪些组件/DOM 节点依赖了这个状态”（即 “依赖收集”），然后只通知这些依赖进行更新，而非遍历整个组件树。

这种“精准推送”从根源上缩小了更新范围，既然任务本身就很小，然后也就不需要 “拆分任务 + 调度” 来避免阻塞。

### 2. 编译时优化：提前 “标记” 更新点，减少运行时计算
* **静态节点提升**：将**静态节点提升到渲染函数外**，只在首次渲染时创建，后续更新直接复用，不参与对比。
* **补丁标记（Patch Flags）**：为**动态节点**添加标记，明确告知运行时 “这个节点的哪些属性可能变化”（如PatchFlag.CLASS表示只有 class 变化）。
* **缓存事件处理函数**：避免每次渲染都创建新的事件处理函数，减少不必要的更新。

### 3. Vue3内也有调度逻辑
* 当状态变化时，Vue 会**将更新任务放入 “微任务队列”**（而非依赖requestIdleCallback），等待当前主线程任务完成后执行。
* 对于**多个连续的状态更新，Vue 会自动 “批处理”，合并为一次更新**，避免多次渲染。


