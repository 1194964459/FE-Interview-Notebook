# Vue与React比较
主要围绕：
* Vue是什么？核心设计理念...
* React是？
* Vue和React的区别？分别从UI描述方式（模版/JSX）、数据追踪(自动追踪/手动更新)、数据流、编译时优化、社区生态
* Vue的优缺点
* React的优缺点

**Vue是一个渐进式框架**，开发者可从简单的视图渲染 逐步扩展到复杂应用（如加入路由、状态管理），学习曲线平缓。路由、状态等都是官方提供的，生态统一

React是“用于构建用户界面的 JavaScript 库”，专注于视图层，不包含上层的路由、状态管理等工具。开发者需从社区中挑选第三方库并且集成的。React主打的是：**函数式编程 + JSX融合**，强调**组件的纯函数特性**（**输入的状态 决定 输出的UI**），通过 JSX 将 HTML 与 JS 逻辑紧密结合。

Vue与React**都有**：组件化、虚拟Dom、生命周期、都是状态驱动视图的（避免手动更新 DOM）...

## 一、Vue 与 React 的区别
**1. UI描述方式：模板 vs JSX**   
* Vue：
    * 默认使用 **HTML 模板**（`<template>` 标签），通过**指令描述动态逻辑**(如：v-if、v-for、v-bind)，与 HTML 语法很接近。
    * **模版、逻辑是分离的**，模板在 `<template>`，逻辑在 `<script>`

* React：
    * **使用JSX**，是在**JS中编写类似HTML的内容**。**UI、逻辑是在一起的**
    * 动态逻辑通过JS语法实现，如：if、for、三元表达式等。动态逻辑都是用中括号{}包裹着，如：
        ```
        <div>
            {show && <p>Hello {name}</p>}
            <button onClick={handleClick}>点击</button>
        </div>
        ```

**2. 数据追踪方式**：Vue是**自动响应式**、React需**手动追踪更新**
* Vue：基于 Proxy（Vue 3） 或 Object.defineProperty（Vue 2） 实现 自动响应式。
    * 可直接修改数据，如 count.value++
    * 可精确到对象的某个属性，**更新时只触发依赖该属性的组件**。
* React：无自动响应式系统，依赖 手动声明更新：
    * **状态是不可变的**（immutable），修改状态必须通过 setState（类组件）或 setXxx（useState）触发更新。
    * **更新时默认触发 整个组件重渲染**（需手动用 React.memo/useMemo 优化）。

**3. 数据流模式**：都支持“单向数据流”，父传递给子组件的props不能修改（是只读的）子组件若与父组件通信：
    * Vue是“子组件emit、父组件v-on监听”。（参考：[Vue组件通信](../Vue/1.1__组件通信与状态管理.md)）
    * React是“父组件 props传递回调函数，子组件调用该函数传递数据”。 （参考：[React组件通信](../__前端工程化/React/React组件通信_状态管理方式.md)）

    不过：
    * React是**严格的单向数据流**，子组件若想修改数据，必须通过父组件传递的 **回调函数** 通知父组件，由父组件更新自身状态（setState），再通过 props 将新数据 “下发” 给子组件。
    * Vue支持**双向绑定（v-model），父子组件之间 并不是严格的“单向数据流”**。
        * **表单元素**：`v-model="数据"` 等价于 `v-bind（绑定值） + v-on（监听输入事件）的组合`。
        * **组件通信**：v-model 简化父子组件双向同步（等同于：父传 modelValue + 子 emit update:modelValue）。
        ```js
            // 父组件：
            const bookTitle = ref('测试')
            <MyComponent v-model:title="bookTitle" />
        ```
        ```js
            // 子组件
            <script setup>
                const title = defineModel('title')
            </script>

            <templatetemplate>
                <input type="text" v-model="title" />
            </>
        ```
**4. 是否有编译时优化？**
* Vue：模板在编译阶段可以进行“静态分析优化”：标记静态节点，Diff时直接忽略。
* React：没有编译时优化，JSX直接转为渲染函数 React.createElement 调用。

**5. 社区与生态**：
* Vue：官方主导，生态精简且统一
* React：社区驱动，生态庞大且灵活

## 二、Vue的优缺点：
优点：
* **学习门槛低，上手快**：模板语法接近原生 HTML，文档完善
* **开发效率高、开箱即用**：
    * 单文件组件**模版**、逻辑结构清晰
    * 内置响应式系统
    * 采用Vite构建，十分便捷，不需要像传统的 Webpack 那样进行繁琐的配置。
    * 官方提供**全套解决方案**（Vue Router 路由、Pinia 状态管理、Vite 构建工具），生态统一，**减少 “选择成本”**。
* **渐进式框架：可按需引入功能**
* **性能优化自动化**
    * **模板编译时 标记静态节点**，Diff时直接忽略。
    * Vue 3 基于 Proxy 的**响应式系统，能精准追踪状态依赖**，避免不必要的组件重渲染。

缺点：
* **很多都定制的，灵活性受限**：如模版语法有固定规则、官方工具链 默认配置较强
* 大型项目协作 与 TS类型支持 较弱
* **跨端生态 相对薄弱**：Vue Native 等跨端方案成熟度低，服务端渲染方案（如 Nuxt.js）生态不如 React 的 Next.js 完善。

## 三、React的优缺点：
优点：
* **灵活性极高**，适配复杂场景
    * JSX 允许 HTML 与 JavaScript 逻辑深度融合，复杂 UI 逻辑（如条件渲染、循环）可直接在组件中编写，无需依赖指令。
    * 核心仅关注 UI 渲染，其他功能（路由、状态管理）由社区生态提供，可根据需求自由组合
* 与TS深度集成、工程化工具链灵活（Webpack/Rollup/Vite 均可适配）
* **跨端与生态成熟度领先**
    * 跨端方案丰富：React Native 可开发原生 App，Next.js 支持服务端渲染（SSR）和静态站点生成（SSG），Remix 适合全栈开发。
    * 社区生态庞大，开源组件、解决方案（如表单处理、状态管理）覆盖几乎所有场景。
* **函数式编程友好**，逻辑复用高效

缺点：
* **学习曲线陡峭**
* **手动优化成本高**：默认情况下，父组件更新会触发所有子组件重渲染，需手动使用 React.memo/useMemo/useCallback 优化，增加代码复杂度。
* **虚拟 DOM 全量比对**，可能引发性能问题（如：万级数据列表）