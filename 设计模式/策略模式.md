# 策略模式

定义一系列 “算法/策略”，将其**封装成独立对象**，可动态切换使用，避免大量if-else判断。

**前端场景**：表单验证（不同字段用不同验证策略）、支付方式选择（微信/支付宝/银行卡对应不同支付逻辑）、排序算法切换。

```js
// 1. 定义所有验证策略（算法）
const ValidatorStrategies = {
  // 非空验证
  required: (value, msg) => {
    return value.trim() === '' ? msg : '';
  },
  // 手机号验证
  phone: (value, msg) => {
    const reg = /^1[3-9]\d{9}$/;
    return !reg.test(value) ? msg : '';
  },
  // 最小长度验证
  minLength: (value, min, msg) => {
    return value.length < min ? msg : '';
  }
};

// 2. 验证器类（统一调用策略）
class Validator {
  constructor() {
    this.rules = []; // 存储验证规则
  }

  // 添加验证规则（关联字段和策略）
  addRule(value, strategy, msg) {
    // 拆分策略（如“minLength:6”拆分为策略名和参数）
    const [strategyName, ...params] = strategy.split(':');
    this.rules.push(() => {
      // 调用对应策略，传入参数
      return ValidatorStrategies[strategyName](value, ...params, msg);
    });
  }

  // 执行所有验证
  validate() {
    for (const rule of this.rules) {
      const errorMsg = rule();
      if (errorMsg) return errorMsg; // 有错误则返回提示
    }
    return ''; // 无错误
  }
}

// 3. 使用（表单验证）
const formData = { phone: '123456', password: '123' };
const validator = new Validator();

// 添加验证规则
validator.addRule(formData.phone, 'required', '手机号不能为空');
validator.addRule(formData.phone, 'phone', '手机号格式错误');
validator.addRule(formData.password, 'minLength:6', '密码至少6位');

// 执行验证
const error = validator.validate();
if (error) {
  console.log('验证失败：', error); // 验证失败：手机号格式错误
} else {
  console.log('验证通过');
}
```
