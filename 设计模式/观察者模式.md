# 观察者模式
参考：
https://refactoringguru.cn/design-patterns/observer
https://juejin.cn/post/6844903686737494030
https://juejin.cn/post/6862112623417098248

**观察者模式**：被观察者（如 “数据对象”）内部维护一个观察者数组，当数据变化时，被观察者会遍历数组，直接调用每个观察者的 update 方法。   
例：Vue 2 的响应式（Dep 作为被观察者，Watcher 作为观察者，Dep 直接通知 Watcher 更新）。

**发布订阅模式**：发布者 只需要向事件总线发送 “特定事件”，订阅者 只需向事件总线订阅该事件；双方完全不知道对方存在。   
例：Vue 的 EventBus、浏览器的 addEventListener（document 相当于事件总线，*点击元素* 发布事件，*监听函数*订阅事件）。


**样例1：**
```js
// 被观察者（Subject）
class Subject {
  constructor() {
    this.observers = []; // 直接持有观察者列表
  }
  // 添加观察者
  addObserver(observer) {
    this.observers.push(observer);
  }
  // 通知所有观察者
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

// 观察者（Observer）
class Observer {
  update(data) {
    console.log("收到更新：", data); // 被观察者直接调用
  }
}

// 使用
const subject = new Subject();
const observer1 = new Observer();
subject.addObserver(observer1); // 被观察者需主动添加观察者
subject.notify("数据变了"); // 被观察者直接通知
```

## 发布订阅 与 观察者模式的 关系：
1. 共同点：
观察者模式与发布订阅模式都是定义了一个 **一对多的依赖关系**，当有关*状态发生变更时则执行相应的更新*。

2. 不同点：
观察者模式与发布订阅模式的核心区别在于：**是否存在第三方 “事件总线”**。

    通信方式：
    * 观察者模式：**直接通信**。“被观察者”直接持有“观察者列表”，主动通知观察者。两者是**强耦合**的！
    * 发布订阅：**间接通信**。发布者、订阅者 两者**不直接交互、互不感知**，通过事件总线传递消息。两者是**解耦的**！

    核心角色：   
    * 观察着模式：观察者（Observer）、被观察者（Subject/Observable）  
    * 发布者（Publisher）、订阅者（Subscriber）、事件总线（Event Bus）

    事件管理：
    * 事件类型固定，无法灵活扩展
    * 支持自定义事件名，可动态添加多种事件类型
